===============================
/// Check if in given vector of numbers, are any two numbers closer to each other than
/// given threshold.
/// >>> has_close_elements(vec![1.0, 2.0, 3.0], 0.5)
/// false
/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
/// true
fn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {

===============================
-----------------------------
/// Check if in given vector of numbers, are any two numbers closer to each other than
/// given threshold.
/// >>> has_close_elements(vec![1.0, 2.0, 3.0], 0.5)
/// false
/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
/// true
fn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {

    let mut distances = vec![];
    for i in 0..numbers.len() - 1 {
        for j in i + 1..numbers.len() {
            distances.push((numbers[i] - numbers[j]).abs());
        }
    }
    distances.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
    distances.iter().fold(false, |acc, x| {
        acc || (*x <= threshold) && (!acc || *x <= threshold - threshold)
    })
}

fn main() {
    let candidate = has_close_elements;
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);
}

-----------------------------
/// Check if in given vector of numbers, are any two numbers closer to each other than
/// given threshold.
/// >>> has_close_elements(vec![1.0, 2.0, 3.0], 0.5)
/// false
/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
/// true
fn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {

    // check if there are any close numbers
    let close_numbers = numbers
        .iter()
        .tuple_combinations()
        .any(|(n1, n2)| {
            let abs_diff = (n1 - n2).abs();
            abs_diff < threshold
        });

    close_numbers
}

fn main() {
    let candidate = has_close_elements;
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);
}

-----------------------------
/// Check if in given vector of numbers, are any two numbers closer to each other than
/// given threshold.
/// >>> has_close_elements(vec![1.0, 2.0, 3.0], 0.5)
/// false
/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
/// true
fn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {

    let mut seen: HashSet<f64> = HashSet::new();
    for number in &numbers {
        for seen_number in &seen {
            if (number - seen_number).abs() < threshold {
                return true;
            }
        }
        seen.insert(*number);
    }
    false
}

fn main() {
    let candidate = has_close_elements;
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);
}

-----------------------------
/// Check if in given vector of numbers, are any two numbers closer to each other than
/// given threshold.
/// >>> has_close_elements(vec![1.0, 2.0, 3.0], 0.5)
/// false
/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
/// true
fn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {

    if numbers.len() <= 1 {
        false
    } else {
        for i in 0..numbers.len() {
            for j in (i + 1)..numbers.len() {
                if (numbers[i] - numbers[j]).abs() < threshold {
                    return true;
                }
            }
        }
        false
    }
}

fn main() {
    let candidate = has_close_elements;
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);
}

-----------------------------
/// Check if in given vector of numbers, are any two numbers closer to each other than
/// given threshold.
/// >>> has_close_elements(vec![1.0, 2.0, 3.0], 0.5)
/// false
/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
/// true
fn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {

    let mut closest_pair = None;
    for (i, value) in numbers.iter().enumerate() {
        for (j, other_value) in numbers.iter().enumerate() {
            if i == j {
                continue;
            }

            if (*value - *other_value).abs() < threshold {
                if closest_pair.is_none() {
                    closest_pair = Some((i, j));
                } else {
                    let (first_index, second_index) = closest_pair.unwrap();
                    if (numbers[first_index] - numbers[second_index]).abs()
                        > (numbers[i] - numbers[j]).abs()
                    {
                        closest_pair = Some((i, j));
                    }
                }
            }
        }
    }

    closest_pair.is_some()
}

fn main() {
    let candidate = has_close_elements;
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);
}

===============================
/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
/// separate those group into separate strings and return the vector of those.
/// Separate groups are balanced (each open brace is properly closed) and not nested within each other
/// Ignore any spaces in the input string.
/// >>> separate_paren_groups(String::from("( ) (( )) (( )( ))"))
/// vec![String::from("()"), String::from("(())"), String::from("(()())")]
fn separate_paren_groups(paren_string: String) -> Vec<String> {

===============================
-----------------------------
/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
/// separate those group into separate strings and return the vector of those.
/// Separate groups are balanced (each open brace is properly closed) and not nested within each other
/// Ignore any spaces in the input string.
/// >>> separate_paren_groups(String::from("( ) (( )) (( )( ))"))
/// vec![String::from("()"), String::from("(())"), String::from("(()())")]
fn separate_paren_groups(paren_string: String) -> Vec<String> {

    let mut cur_paren = String::new();
    let mut res = Vec::new();
    let mut balance = 0;

    for ch in paren_string.chars() {
        if ch == '(' {
            if balance > 0 {
                cur_paren.push(ch);
            } else {
                if !cur_paren.is_empty() {
                    res.push(cur_paren);
                }
                cur_paren = String::from("(");
            }
            balance += 1;
        } else if ch == ')' {
            balance -= 1;
            if balance > 0 {
                cur_paren.push(ch);
            } else {
                if !cur_paren.is_empty() {
                    res.push(cur_paren);
                }
                cur_paren = String::from(")");
            }
        }
    }

    if balance != 0 {
        panic!("Unbalanced parenthesis in input");
    }

    if !cur_paren.is_empty() {
        res.push(cur_paren);
    }
    res
}

fn main() {
    let candidate = separate_paren_groups;
    assert_eq!(candidate(String::from("(()()) ((())) () ((())()())")), vec![String::from("(()())"), String::from("((()))"), String::from("()"), String::from("((())()())")]);
    assert_eq!(candidate(String::from("() (()) ((())) (((())))")), vec![String::from("()"), String::from("(())"), String::from("((()))"), String::from("(((())))")]);
    assert_eq!(candidate(String::from("(()(())((())))")), vec![String::from("(()(())((())))")]);
    assert_eq!(candidate(String::from("( ) (( )) (( )( ))")), vec![String::from("()"), String::from("(())"), String::from("(()())")]);
}

-----------------------------
/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
/// separate those group into separate strings and return the vector of those.
/// Separate groups are balanced (each open brace is properly closed) and not nested within each other
/// Ignore any spaces in the input string.
/// >>> separate_paren_groups(String::from("( ) (( )) (( )( ))"))
/// vec![String::from("()"), String::from("(())"), String::from("(()())")]
fn separate_paren_groups(paren_string: String) -> Vec<String> {

    let mut result = Vec::new();
    let mut current = String::new();
    let mut open = false;
    for char in paren_string.chars() {
        match char {
            '(' => {
                if open {
                    current.push(char);
                } else {
                    open = true;
                    result.push(current);
                    current = String::new();
                }
            }
            ')' => {
                if open {
                    open = false;
                    current.push(char);
                } else {
                    current.push(char);
                }
            }
            ' ' => {}
            other => current.push(other),
        }
    }
    result.push(current);
    result
}

fn main() {
    let candidate = separate_paren_groups;
    assert_eq!(candidate(String::from("(()()) ((())) () ((())()())")), vec![String::from("(()())"), String::from("((()))"), String::from("()"), String::from("((())()())")]);
    assert_eq!(candidate(String::from("() (()) ((())) (((())))")), vec![String::from("()"), String::from("(())"), String::from("((()))"), String::from("(((())))")]);
    assert_eq!(candidate(String::from("(()(())((())))")), vec![String::from("(()(())((())))")]);
    assert_eq!(candidate(String::from("( ) (( )) (( )( ))")), vec![String::from("()"), String::from("(())"), String::from("(()())")]);
}

-----------------------------
/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
/// separate those group into separate strings and return the vector of those.
/// Separate groups are balanced (each open brace is properly closed) and not nested within each other
/// Ignore any spaces in the input string.
/// >>> separate_paren_groups(String::from("( ) (( )) (( )( ))"))
/// vec![String::from("()"), String::from("(())"), String::from("(()())")]
fn separate_paren_groups(paren_string: String) -> Vec<String> {

    let mut output: Vec<String> = Vec::new();
    let mut buffer: Vec<char> = Vec::new();

    for character in paren_string.chars() {
        match character {
            '(' => buffer.push(character),
            ')' => {
                if let Some('(') = buffer.last() {
                    buffer.pop();
                    if buffer.is_empty() {
                        output.push(String::from("()"));
                    } else {
                        buffer.push(character);
                    }
                } else {
                    buffer.push(character);
                }
            }
            ' ' => {
                // do nothing
            }
            _ => {
                buffer.push(character);
            }
        }
    }

    // If the last element of the buffer is '(', add the result to the output and reset the buffer.
    if let Some('(') = buffer.last() {
        output.push(buffer.into_iter().collect());
        buffer.clear();
    }

    output
}

fn main() {
    let candidate = separate_paren_groups;
    assert_eq!(candidate(String::from("(()()) ((())) () ((())()())")), vec![String::from("(()())"), String::from("((()))"), String::from("()"), String::from("((())()())")]);
    assert_eq!(candidate(String::from("() (()) ((())) (((())))")), vec![String::from("()"), String::from("(())"), String::from("((()))"), String::from("(((())))")]);
    assert_eq!(candidate(String::from("(()(())((())))")), vec![String::from("(()(())((())))")]);
    assert_eq!(candidate(String::from("( ) (( )) (( )( ))")), vec![String::from("()"), String::from("(())"), String::from("(()())")]);
}

-----------------------------
/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
/// separate those group into separate strings and return the vector of those.
/// Separate groups are balanced (each open brace is properly closed) and not nested within each other
/// Ignore any spaces in the input string.
/// >>> separate_paren_groups(String::from("( ) (( )) (( )( ))"))
/// vec![String::from("()"), String::from("(())"), String::from("(()())")]
fn separate_paren_groups(paren_string: String) -> Vec<String> {

    let mut result: Vec<String> = vec![];
    let mut sub_string = String::new();
    let mut stack: Vec<char> = vec![];

    for ch in paren_string.chars() {
        match ch {
            '(' => stack.push('('),
            ')' => {
                match stack.pop() {
                    Some('(') => {
                        if sub_string.len() > 0 {
                            result.push(sub_string);
                            sub_string = String::new();
                        }
                    }
                    None => return result,
                    _ => panic!("Impossible state"),
                }
            }
            _ => sub_string.push(ch),
        }
    }

    if stack.len() > 0 {
        result.push(sub_string);
    }

    result
}

fn main() {
    let candidate = separate_paren_groups;
    assert_eq!(candidate(String::from("(()()) ((())) () ((())()())")), vec![String::from("(()())"), String::from("((()))"), String::from("()"), String::from("((())()())")]);
    assert_eq!(candidate(String::from("() (()) ((())) (((())))")), vec![String::from("()"), String::from("(())"), String::from("((()))"), String::from("(((())))")]);
    assert_eq!(candidate(String::from("(()(())((())))")), vec![String::from("(()(())((())))")]);
    assert_eq!(candidate(String::from("( ) (( )) (( )( ))")), vec![String::from("()"), String::from("(())"), String::from("(()())")]);
}

-----------------------------
/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
/// separate those group into separate strings and return the vector of those.
/// Separate groups are balanced (each open brace is properly closed) and not nested within each other
/// Ignore any spaces in the input string.
/// >>> separate_paren_groups(String::from("( ) (( )) (( )( ))"))
/// vec![String::from("()"), String::from("(())"), String::from("(()())")]
fn separate_paren_groups(paren_string: String) -> Vec<String> {

    // TODO
    let mut result = Vec::new();
    let mut paren_stack = Vec::new();
    let mut last_group_start = 0;
    for (i, c) in paren_string.chars().enumerate() {
        if c == '(' {
            paren_stack.push(c);
        } else if c == ')' {
            if paren_stack.is_empty() {
                return vec![String::from("Parse Error")];
            }
            paren_stack.pop();
        }
        if i == paren_string.len() - 1 {
            if !paren_stack.is_empty() {
                return vec![String::from("Parse Error")];
            }
            result.push(paren_string[last_group_start..i + 1].to_string());
        }
    }
    result
}

fn main() {
    let candidate = separate_paren_groups;
    assert_eq!(candidate(String::from("(()()) ((())) () ((())()())")), vec![String::from("(()())"), String::from("((()))"), String::from("()"), String::from("((())()())")]);
    assert_eq!(candidate(String::from("() (()) ((())) (((())))")), vec![String::from("()"), String::from("(())"), String::from("((()))"), String::from("(((())))")]);
    assert_eq!(candidate(String::from("(()(())((())))")), vec![String::from("(()(())((())))")]);
    assert_eq!(candidate(String::from("( ) (( )) (( )( ))")), vec![String::from("()"), String::from("(())"), String::from("(()())")]);
}

===============================
/// Given a positive floating point number, it can be decomposed into
/// and integer part (largest integer smaller than given number) and decimals
/// (leftover part always smaller than 1).
/// Return the decimal part of the number.
/// >>> truncate_number(3.5)
/// 0.5
fn truncate_number(number: f64) -> f64 {

===============================
-----------------------------
/// Given a positive floating point number, it can be decomposed into
/// and integer part (largest integer smaller than given number) and decimals
/// (leftover part always smaller than 1).
/// Return the decimal part of the number.
/// >>> truncate_number(3.5)
/// 0.5
fn truncate_number(number: f64) -> f64 {

    let integer_part = number.floor() as i64;
    let decimals = number - (integer_part as f64);
    decimals
}

fn main() {
    let candidate = truncate_number;
    assert_eq!(candidate(3.5), 0.5);
    assert_eq!(candidate(1.25), 0.25);
    assert_eq!(candidate(123.0), 0.0);
}

-----------------------------
/// Given a positive floating point number, it can be decomposed into
/// and integer part (largest integer smaller than given number) and decimals
/// (leftover part always smaller than 1).
/// Return the decimal part of the number.
/// >>> truncate_number(3.5)
/// 0.5
fn truncate_number(number: f64) -> f64 {

    let mut num_str = number.to_string();
    let index = num_str.find('.').unwrap();
    let integer_part = num_str.drain(0..index).collect::<String>();
    let decimals = num_str.drain(index + 1..).collect::<String>();
    let float_num = decimals.parse::<f64>().unwrap();
    let result = float_num / (10.0_f64).powf(integer_part.parse::<f64>().unwrap());
    result
}

fn main() {
    let candidate = truncate_number;
    assert_eq!(candidate(3.5), 0.5);
    assert_eq!(candidate(1.25), 0.25);
    assert_eq!(candidate(123.0), 0.0);
}

-----------------------------
/// Given a positive floating point number, it can be decomposed into
/// and integer part (largest integer smaller than given number) and decimals
/// (leftover part always smaller than 1).
/// Return the decimal part of the number.
/// >>> truncate_number(3.5)
/// 0.5
fn truncate_number(number: f64) -> f64 {

    number.fract()
}

fn main() {
    let candidate = truncate_number;
    assert_eq!(candidate(3.5), 0.5);
    assert_eq!(candidate(1.25), 0.25);
    assert_eq!(candidate(123.0), 0.0);
}

-----------------------------
/// Given a positive floating point number, it can be decomposed into
/// and integer part (largest integer smaller than given number) and decimals
/// (leftover part always smaller than 1).
/// Return the decimal part of the number.
/// >>> truncate_number(3.5)
/// 0.5
fn truncate_number(number: f64) -> f64 {

    let digits = number.to_string().split('.').collect::<Vec<&str>>();
    let digits = digits[1].parse::<f64>().unwrap_or(0.0);
    digits
}

fn main() {
    let candidate = truncate_number;
    assert_eq!(candidate(3.5), 0.5);
    assert_eq!(candidate(1.25), 0.25);
    assert_eq!(candidate(123.0), 0.0);
}

-----------------------------
/// Given a positive floating point number, it can be decomposed into
/// and integer part (largest integer smaller than given number) and decimals
/// (leftover part always smaller than 1).
/// Return the decimal part of the number.
/// >>> truncate_number(3.5)
/// 0.5
fn truncate_number(number: f64) -> f64 {

    let x = number.fract();
    if x >= 0.5 {
        x - 1.0
    } else {
        x
    }
}

fn main() {
    let candidate = truncate_number;
    assert_eq!(candidate(3.5), 0.5);
    assert_eq!(candidate(1.25), 0.25);
    assert_eq!(candidate(123.0), 0.0);
}

===============================
/// You're given a vector of deposit and withdrawal operations on a bank account that starts with
/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
/// at that point function should return true. Otherwise it should return false.
/// >>> below_zero(vec![1, 2, 3])
/// false
/// >>> below_zero(vec![1, 2, -4, 5])
/// true
fn below_zero(operations: Vec<isize>) -> bool {

===============================
-----------------------------
/// You're given a vector of deposit and withdrawal operations on a bank account that starts with
/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
/// at that point function should return true. Otherwise it should return false.
/// >>> below_zero(vec![1, 2, 3])
/// false
/// >>> below_zero(vec![1, 2, -4, 5])
/// true
fn below_zero(operations: Vec<isize>) -> bool {

    let mut total = 0;

    for operation in operations {
        total += operation;

        if total < 0 {
            return true;
        }
    }

    return false;
}

fn main() {
    let candidate = below_zero;
    assert_eq!(candidate(Vec::<isize>::new()), false);
    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);
    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);
    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);
    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);
    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);
}

-----------------------------
/// You're given a vector of deposit and withdrawal operations on a bank account that starts with
/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
/// at that point function should return true. Otherwise it should return false.
/// >>> below_zero(vec![1, 2, 3])
/// false
/// >>> below_zero(vec![1, 2, -4, 5])
/// true
fn below_zero(operations: Vec<isize>) -> bool {

    let mut balance = 0;
    for op in operations {
        if op < 0 {
            balance += op;
        } else {
            balance += op;
        }
        if balance < 0 {
            return true;
        }
    }
    return false;
}

fn main() {
    let candidate = below_zero;
    assert_eq!(candidate(Vec::<isize>::new()), false);
    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);
    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);
    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);
    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);
    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);
}

-----------------------------
/// You're given a vector of deposit and withdrawal operations on a bank account that starts with
/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
/// at that point function should return true. Otherwise it should return false.
/// >>> below_zero(vec![1, 2, 3])
/// false
/// >>> below_zero(vec![1, 2, -4, 5])
/// true
fn below_zero(operations: Vec<isize>) -> bool {

    let mut bal = 0;
    for i in operations {
        bal += i;
        if bal < 0 {
            return true;
        }
    }
    false
}

fn main() {
    let candidate = below_zero;
    assert_eq!(candidate(Vec::<isize>::new()), false);
    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);
    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);
    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);
    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);
    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);
}

-----------------------------
/// You're given a vector of deposit and withdrawal operations on a bank account that starts with
/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
/// at that point function should return true. Otherwise it should return false.
/// >>> below_zero(vec![1, 2, 3])
/// false
/// >>> below_zero(vec![1, 2, -4, 5])
/// true
fn below_zero(operations: Vec<isize>) -> bool {

    let mut balance = 0;
    for oper in operations.iter() {
        balance = balance + oper;
        if balance < 0 {
            return true;
        }
    }
    false
}

fn main() {
    let candidate = below_zero;
    assert_eq!(candidate(Vec::<isize>::new()), false);
    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);
    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);
    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);
    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);
    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);
}

-----------------------------
/// You're given a vector of deposit and withdrawal operations on a bank account that starts with
/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
/// at that point function should return true. Otherwise it should return false.
/// >>> below_zero(vec![1, 2, 3])
/// false
/// >>> below_zero(vec![1, 2, -4, 5])
/// true
fn below_zero(operations: Vec<isize>) -> bool {

    let mut balance = 0;
    for operation in operations {
        if operation > 0 {
            balance += operation;
        } else {
            balance -= operation;
        }
        if balance < 0 {
            return true;
        }
    }
    false
}

fn main() {
    let candidate = below_zero;
    assert_eq!(candidate(Vec::<isize>::new()), false);
    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);
    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);
    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);
    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);
    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);
}

===============================
/// For a given vector of input numbers, calculate Mean Absolute Deviation
/// around the mean of this dataset.
/// Mean Absolute Deviation is the average absolute difference between each
/// element and a centerpoint (mean in this case):
/// MAD = average | x - x_mean |
/// >>> mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0])
/// 1.0
fn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {

===============================
-----------------------------
/// For a given vector of input numbers, calculate Mean Absolute Deviation
/// around the mean of this dataset.
/// Mean Absolute Deviation is the average absolute difference between each
/// element and a centerpoint (mean in this case):
/// MAD = average | x - x_mean |
/// >>> mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0])
/// 1.0
fn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {

    let mean = mean(numbers);

    let abs_deviations = numbers
        .iter()
        .map(|x| (x - &mean).abs())
        .collect::<Vec<f64>>();
    mean(abs_deviations)
}

fn main() {
    let candidate = mean_absolute_deviation;
    assert_eq!(candidate(vec![1.0, 2.0]), 0.5);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0]), 1.0);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), 1.2);
}

-----------------------------
/// For a given vector of input numbers, calculate Mean Absolute Deviation
/// around the mean of this dataset.
/// Mean Absolute Deviation is the average absolute difference between each
/// element and a centerpoint (mean in this case):
/// MAD = average | x - x_mean |
/// >>> mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0])
/// 1.0
fn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {

    let mean = mean(numbers);
    let mut sum = 0.0;
    for x in numbers {
        sum += (x - mean).abs();
    }
    sum / (numbers.len() as f64)
}

fn main() {
    let candidate = mean_absolute_deviation;
    assert_eq!(candidate(vec![1.0, 2.0]), 0.5);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0]), 1.0);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), 1.2);
}

-----------------------------
/// For a given vector of input numbers, calculate Mean Absolute Deviation
/// around the mean of this dataset.
/// Mean Absolute Deviation is the average absolute difference between each
/// element and a centerpoint (mean in this case):
/// MAD = average | x - x_mean |
/// >>> mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0])
/// 1.0
fn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {

    let mean = mean(numbers);
    let mut diffs: f64 = 0.0;
    for number in numbers.iter() {
        diffs += (number - &mean).abs();
    }
    diffs / numbers.len() as f64
}

fn main() {
    let candidate = mean_absolute_deviation;
    assert_eq!(candidate(vec![1.0, 2.0]), 0.5);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0]), 1.0);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), 1.2);
}

-----------------------------
/// For a given vector of input numbers, calculate Mean Absolute Deviation
/// around the mean of this dataset.
/// Mean Absolute Deviation is the average absolute difference between each
/// element and a centerpoint (mean in this case):
/// MAD = average | x - x_mean |
/// >>> mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0])
/// 1.0
fn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {

    // We need to calculate the mean first, for that we need to sum all the elements in the vector
    let sum_of_numbers: f64 = numbers.iter().sum();
    // We divide by number of elements to get the mean
    let mean: f64 = sum_of_numbers / numbers.len() as f64;
    // Now we calculate the average absolute difference for each element and the mean
    // The absolute difference is the distance to the centerpoint
    let average_absolute_difference: f64 = numbers
        .iter()
        .map(|x| (x - &mean).abs())
        .sum::<f64>()
        / numbers.len() as f64;
    // Then we return the result
    return average_absolute_difference;
}

fn main() {
    let candidate = mean_absolute_deviation;
    assert_eq!(candidate(vec![1.0, 2.0]), 0.5);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0]), 1.0);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), 1.2);
}

-----------------------------
/// For a given vector of input numbers, calculate Mean Absolute Deviation
/// around the mean of this dataset.
/// Mean Absolute Deviation is the average absolute difference between each
/// element and a centerpoint (mean in this case):
/// MAD = average | x - x_mean |
/// >>> mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0])
/// 1.0
fn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {

    let mean: f64 = mean(numbers.clone());
    let mut acc = 0.0;

    for number in numbers {
        acc += (number - mean).abs();
    }

    acc / numbers.len() as f64
}

fn main() {
    let candidate = mean_absolute_deviation;
    assert_eq!(candidate(vec![1.0, 2.0]), 0.5);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0]), 1.0);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), 1.2);
}

===============================
/// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'
/// >>> intersperse(vec![], 4)
/// Vec::<isize>::new()
/// >>> intersperse(vec![1, 2, 3], 4)
/// vec![1, 4, 2, 4, 3]
fn intersperse(numbers: Vec<isize>, delimeter: isize) -> Vec<isize> {

===============================
-----------------------------
/// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'
/// >>> intersperse(vec![], 4)
/// Vec::<isize>::new()
/// >>> intersperse(vec![1, 2, 3], 4)
/// vec![1, 4, 2, 4, 3]
fn intersperse(numbers: Vec<isize>, delimeter: isize) -> Vec<isize> {

    numbers
        .into_iter()
        .zip(numbers.into_iter().skip(1))
        .fold(vec![], |mut acc, (a, b)| {
            acc.push(a);
            acc.push(delimeter);
            acc.push(b);
            acc
        })
}

fn main() {
    let candidate = intersperse;
    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());
    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);
    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);
}

-----------------------------
/// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'
/// >>> intersperse(vec![], 4)
/// Vec::<isize>::new()
/// >>> intersperse(vec![1, 2, 3], 4)
/// vec![1, 4, 2, 4, 3]
fn intersperse(numbers: Vec<isize>, delimeter: isize) -> Vec<isize> {

    let mut results: Vec<isize> = vec![];
    for (i, number) in numbers.iter().enumerate() {
        results.push(*number);
        if i < numbers.len() - 1 {
            results.push(delimeter);
        }
    }
    results
}

fn main() {
    let candidate = intersperse;
    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());
    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);
    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);
}

-----------------------------
/// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'
/// >>> intersperse(vec![], 4)
/// Vec::<isize>::new()
/// >>> intersperse(vec![1, 2, 3], 4)
/// vec![1, 4, 2, 4, 3]
fn intersperse(numbers: Vec<isize>, delimeter: isize) -> Vec<isize> {

    let mut new_numbers = Vec::new();
    let mut is_first = true;
    for number in numbers.iter() {
        if is_first {
            is_first = false;
        } else {
            new_numbers.push(delimeter);
        }
        new_numbers.push(*number);
    }
    new_numbers
}

fn main() {
    let candidate = intersperse;
    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());
    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);
    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);
}

-----------------------------
/// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'
/// >>> intersperse(vec![], 4)
/// Vec::<isize>::new()
/// >>> intersperse(vec![1, 2, 3], 4)
/// vec![1, 4, 2, 4, 3]
fn intersperse(numbers: Vec<isize>, delimeter: isize) -> Vec<isize> {

    let mut interspersed: Vec<isize> = vec![];
    let mut is_empty = numbers.is_empty();
    for number in numbers {
        if is_empty {
            is_empty = false;
        } else {
            interspersed.push(delimeter);
        }
        interspersed.push(number);
    }
    return interspersed;
}

fn main() {
    let candidate = intersperse;
    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());
    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);
    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);
}

-----------------------------
/// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'
/// >>> intersperse(vec![], 4)
/// Vec::<isize>::new()
/// >>> intersperse(vec![1, 2, 3], 4)
/// vec![1, 4, 2, 4, 3]
fn intersperse(numbers: Vec<isize>, delimeter: isize) -> Vec<isize> {

    let mut result = Vec::<isize>::new();
    for i in 0..numbers.len() {
        result.push(numbers[i]);
        if i != numbers.len() - 1 {
            result.push(delimeter);
        }
    }
    result
}

fn main() {
    let candidate = intersperse;
    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());
    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);
    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);
}

===============================
/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
/// For each of the group, output the deepest level of nesting of parentheses.
/// E.g. (()()) has maximum two levels of nesting while ((())) has three.
/// >>> parse_nested_parens(String::from("(()()) ((())) () ((())()())"))
/// vec![2, 3, 1, 3]
fn parse_nested_parens(paren_string: String) -> Vec<isize> {

===============================
-----------------------------
/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
/// For each of the group, output the deepest level of nesting of parentheses.
/// E.g. (()()) has maximum two levels of nesting while ((())) has three.
/// >>> parse_nested_parens(String::from("(()()) ((())) () ((())()())"))
/// vec![2, 3, 1, 3]
fn parse_nested_parens(paren_string: String) -> Vec<isize> {

    let mut result = Vec::new();
    let mut depth = 0;
    for c in paren_string.chars() {
        match c {
            '(' => depth += 1,
            ')' => depth -= 1,
            _ => {
                if c.is_whitespace() {
                    continue;
                }
                panic!("Unrecognized character: {}", c);
            }
        }
        result.push(depth);
    }
    result
}

fn main() {
    let candidate = parse_nested_parens;
    assert_eq!(candidate(String::from("(()()) ((())) () ((())()())")), vec![2, 3, 1, 3]);
    assert_eq!(candidate(String::from("() (()) ((())) (((())))")), vec![1, 2, 3, 4]);
    assert_eq!(candidate(String::from("(()(())((())))")), vec![4]);
}

-----------------------------
/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
/// For each of the group, output the deepest level of nesting of parentheses.
/// E.g. (()()) has maximum two levels of nesting while ((())) has three.
/// >>> parse_nested_parens(String::from("(()()) ((())) () ((())()())"))
/// vec![2, 3, 1, 3]
fn parse_nested_parens(paren_string: String) -> Vec<isize> {

    // Parse the paren string into a vector of chars
    let paren_vec: Vec<char> = paren_string.chars().collect();
    // Initialize a vector to store the result.
    let mut result: Vec<isize> = Vec::new();
    // Initialize a counter to track the number of levels of nesting.
    let mut level: isize = 0;
    // Loop through the paren_vec
    for p in paren_vec {
        // If the character is open paren, increment the level of nesting.
        if p == '(' {
            level += 1;
        }
        // If the character is closed paren, decrement the level of nesting.
        if p == ')' {
            level -= 1;
        }
        // Push the level of nesting to the result vector.
        result.push(level);
    }
    // Return the result vector.
    result
}

fn main() {
    let candidate = parse_nested_parens;
    assert_eq!(candidate(String::from("(()()) ((())) () ((())()())")), vec![2, 3, 1, 3]);
    assert_eq!(candidate(String::from("() (()) ((())) (((())))")), vec![1, 2, 3, 4]);
    assert_eq!(candidate(String::from("(()(())((())))")), vec![4]);
}

-----------------------------
/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
/// For each of the group, output the deepest level of nesting of parentheses.
/// E.g. (()()) has maximum two levels of nesting while ((())) has three.
/// >>> parse_nested_parens(String::from("(()()) ((())) () ((())()())"))
/// vec![2, 3, 1, 3]
fn parse_nested_parens(paren_string: String) -> Vec<isize> {

    let mut result = vec![];
    let mut nesting_level = 0;
    for paren in paren_string.split_whitespace() {
        let paren_length = paren.len();
        if paren.starts_with('(') && paren.ends_with(')') {
            nesting_level += 1;
            result.push(nesting_level);
        } else {
            if nesting_level > 0 {
                result.push(nesting_level);
            }
            nesting_level = 0;
        }
    }
    result
}

fn main() {
    let candidate = parse_nested_parens;
    assert_eq!(candidate(String::from("(()()) ((())) () ((())()())")), vec![2, 3, 1, 3]);
    assert_eq!(candidate(String::from("() (()) ((())) (((())))")), vec![1, 2, 3, 4]);
    assert_eq!(candidate(String::from("(()(())((())))")), vec![4]);
}

-----------------------------
/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
/// For each of the group, output the deepest level of nesting of parentheses.
/// E.g. (()()) has maximum two levels of nesting while ((())) has three.
/// >>> parse_nested_parens(String::from("(()()) ((())) () ((())()())"))
/// vec![2, 3, 1, 3]
fn parse_nested_parens(paren_string: String) -> Vec<isize> {

    let paren_string = paren_string.trim_end();
    let groups = paren_string.split(' ');
    let mut maxes: Vec<isize> = Vec::new();
    for group in groups {
        if group.is_empty() {
            continue;
        }
        let mut max_depth = 0;
        let mut stack: Vec<char> = Vec::new();
        for c in group.chars() {
            match c {
                '(' => stack.push('('),
                ')' => {
                    if stack.pop().is_some() {
                        // A closing parenthesis is found and a corresponding opening
                        // parenthesis is popped from the stack.
                        max_depth = max_depth.max(stack.len() as isize);
                    } else {
                        // A closing parenthesis is found but there is no corresponding
                        // opening parenthesis in the stack.
                        max_depth = max_depth.max(stack.len() as isize);
                        break;
                    }
                }
                _ => panic!("Character {} cannot appear in a paren string", c),
            }
        }
        // If the stack is not empty at the end of a group, that means the group
        // is unbalanced.
        if !stack.is_empty() {
            max_depth = max_depth.max(stack.len() as isize);
        }
        maxes.push(max_depth);
    }
    maxes
}

fn main() {
    let candidate = parse_nested_parens;
    assert_eq!(candidate(String::from("(()()) ((())) () ((())()())")), vec![2, 3, 1, 3]);
    assert_eq!(candidate(String::from("() (()) ((())) (((())))")), vec![1, 2, 3, 4]);
    assert_eq!(candidate(String::from("(()(())((())))")), vec![4]);
}

-----------------------------
/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
/// For each of the group, output the deepest level of nesting of parentheses.
/// E.g. (()()) has maximum two levels of nesting while ((())) has three.
/// >>> parse_nested_parens(String::from("(()()) ((())) () ((())()())"))
/// vec![2, 3, 1, 3]
fn parse_nested_parens(paren_string: String) -> Vec<isize> {

    let mut result = Vec::new();
    let mut deepest_level = 0;
    for (i, paren) in paren_string.chars().enumerate() {
        if paren == '(' {
            deepest_level += 1;
        } else if paren == ')' {
            deepest_level -= 1;
            if deepest_level < 0 {
                deepest_level = 0;
            }
            result.push(deepest_level);
        }
    }
    result
}

fn main() {
    let candidate = parse_nested_parens;
    assert_eq!(candidate(String::from("(()()) ((())) () ((())()())")), vec![2, 3, 1, 3]);
    assert_eq!(candidate(String::from("() (()) ((())) (((())))")), vec![1, 2, 3, 4]);
    assert_eq!(candidate(String::from("(()(())((())))")), vec![4]);
}

===============================
/// Filter an input vector of strings only for ones that contain given substring
/// >>> filter_by_substring(vec![], String::from("a"))
/// Vec::<String>::new()
/// >>> filter_by_substring(vec![String::from("abc"), String::from("bacd"), String::from("cde"), String::from("array")], String::from("a"))
/// vec![String::from("abc"), String::from("bacd"), String::from("array")]
fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {

===============================
-----------------------------
/// Filter an input vector of strings only for ones that contain given substring
/// >>> filter_by_substring(vec![], String::from("a"))
/// Vec::<String>::new()
/// >>> filter_by_substring(vec![String::from("abc"), String::from("bacd"), String::from("cde"), String::from("array")], String::from("a"))
/// vec![String::from("abc"), String::from("bacd"), String::from("array")]
fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {

    let mut result: Vec<String> = Vec::new();
    for string in strings {
        if string.contains(&substring) {
            result.push(string);
        }
    }
    result
}

fn main() {
    let candidate = filter_by_substring;
    assert_eq!(candidate(Vec::<String>::new(), String::from("john")), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("xxx"), String::from("asd"), String::from("xxy"), String::from("john doe"), String::from("xxxAAA"), String::from("xxx")], String::from("xxx")), vec![String::from("xxx"), String::from("xxxAAA"), String::from("xxx")]);
    assert_eq!(candidate(vec![String::from("xxx"), String::from("asd"), String::from("aaaxxy"), String::from("john doe"), String::from("xxxAAA"), String::from("xxx")], String::from("xx")), vec![String::from("xxx"), String::from("aaaxxy"), String::from("xxxAAA"), String::from("xxx")]);
    assert_eq!(candidate(vec![String::from("grunt"), String::from("trumpet"), String::from("prune"), String::from("gruesome")], String::from("run")), vec![String::from("grunt"), String::from("prune")]);
}

-----------------------------
/// Filter an input vector of strings only for ones that contain given substring
/// >>> filter_by_substring(vec![], String::from("a"))
/// Vec::<String>::new()
/// >>> filter_by_substring(vec![String::from("abc"), String::from("bacd"), String::from("cde"), String::from("array")], String::from("a"))
/// vec![String::from("abc"), String::from("bacd"), String::from("array")]
fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {

    strings.into_iter()
        .filter(|string| string.contains(substring.as_str()))
        .collect()
}

fn main() {
    let candidate = filter_by_substring;
    assert_eq!(candidate(Vec::<String>::new(), String::from("john")), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("xxx"), String::from("asd"), String::from("xxy"), String::from("john doe"), String::from("xxxAAA"), String::from("xxx")], String::from("xxx")), vec![String::from("xxx"), String::from("xxxAAA"), String::from("xxx")]);
    assert_eq!(candidate(vec![String::from("xxx"), String::from("asd"), String::from("aaaxxy"), String::from("john doe"), String::from("xxxAAA"), String::from("xxx")], String::from("xx")), vec![String::from("xxx"), String::from("aaaxxy"), String::from("xxxAAA"), String::from("xxx")]);
    assert_eq!(candidate(vec![String::from("grunt"), String::from("trumpet"), String::from("prune"), String::from("gruesome")], String::from("run")), vec![String::from("grunt"), String::from("prune")]);
}

-----------------------------
/// Filter an input vector of strings only for ones that contain given substring
/// >>> filter_by_substring(vec![], String::from("a"))
/// Vec::<String>::new()
/// >>> filter_by_substring(vec![String::from("abc"), String::from("bacd"), String::from("cde"), String::from("array")], String::from("a"))
/// vec![String::from("abc"), String::from("bacd"), String::from("array")]
fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {

    // if substring is empty return empty vector
    if substring.is_empty() {
        return vec![];
    }

    // find all strings that contain given substring
    let mut found_strings: Vec<String> = vec![];
    for string in &strings {
        if string.contains(&substring) {
            found_strings.push(string.clone());
        }
    }

    found_strings
}

fn main() {
    let candidate = filter_by_substring;
    assert_eq!(candidate(Vec::<String>::new(), String::from("john")), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("xxx"), String::from("asd"), String::from("xxy"), String::from("john doe"), String::from("xxxAAA"), String::from("xxx")], String::from("xxx")), vec![String::from("xxx"), String::from("xxxAAA"), String::from("xxx")]);
    assert_eq!(candidate(vec![String::from("xxx"), String::from("asd"), String::from("aaaxxy"), String::from("john doe"), String::from("xxxAAA"), String::from("xxx")], String::from("xx")), vec![String::from("xxx"), String::from("aaaxxy"), String::from("xxxAAA"), String::from("xxx")]);
    assert_eq!(candidate(vec![String::from("grunt"), String::from("trumpet"), String::from("prune"), String::from("gruesome")], String::from("run")), vec![String::from("grunt"), String::from("prune")]);
}

-----------------------------
/// Filter an input vector of strings only for ones that contain given substring
/// >>> filter_by_substring(vec![], String::from("a"))
/// Vec::<String>::new()
/// >>> filter_by_substring(vec![String::from("abc"), String::from("bacd"), String::from("cde"), String::from("array")], String::from("a"))
/// vec![String::from("abc"), String::from("bacd"), String::from("array")]
fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {

    strings.into_iter()
        .filter(|string| string.contains(&substring))
        .collect()
}

fn main() {
    let candidate = filter_by_substring;
    assert_eq!(candidate(Vec::<String>::new(), String::from("john")), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("xxx"), String::from("asd"), String::from("xxy"), String::from("john doe"), String::from("xxxAAA"), String::from("xxx")], String::from("xxx")), vec![String::from("xxx"), String::from("xxxAAA"), String::from("xxx")]);
    assert_eq!(candidate(vec![String::from("xxx"), String::from("asd"), String::from("aaaxxy"), String::from("john doe"), String::from("xxxAAA"), String::from("xxx")], String::from("xx")), vec![String::from("xxx"), String::from("aaaxxy"), String::from("xxxAAA"), String::from("xxx")]);
    assert_eq!(candidate(vec![String::from("grunt"), String::from("trumpet"), String::from("prune"), String::from("gruesome")], String::from("run")), vec![String::from("grunt"), String::from("prune")]);
}

-----------------------------
/// Filter an input vector of strings only for ones that contain given substring
/// >>> filter_by_substring(vec![], String::from("a"))
/// Vec::<String>::new()
/// >>> filter_by_substring(vec![String::from("abc"), String::from("bacd"), String::from("cde"), String::from("array")], String::from("a"))
/// vec![String::from("abc"), String::from("bacd"), String::from("array")]
fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {

    strings
        .into_iter()
        .filter(|string| string.contains(substring.as_str()))
        .collect()
}

fn main() {
    let candidate = filter_by_substring;
    assert_eq!(candidate(Vec::<String>::new(), String::from("john")), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("xxx"), String::from("asd"), String::from("xxy"), String::from("john doe"), String::from("xxxAAA"), String::from("xxx")], String::from("xxx")), vec![String::from("xxx"), String::from("xxxAAA"), String::from("xxx")]);
    assert_eq!(candidate(vec![String::from("xxx"), String::from("asd"), String::from("aaaxxy"), String::from("john doe"), String::from("xxxAAA"), String::from("xxx")], String::from("xx")), vec![String::from("xxx"), String::from("aaaxxy"), String::from("xxxAAA"), String::from("xxx")]);
    assert_eq!(candidate(vec![String::from("grunt"), String::from("trumpet"), String::from("prune"), String::from("gruesome")], String::from("run")), vec![String::from("grunt"), String::from("prune")]);
}

===============================
/// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.
/// Empty sum should be equal to 0 and empty product should be equal to 1.
/// >>> sum_product(vec![])
/// (0, 1)
/// >>> sum_product(vec![1, 2, 3, 4])
/// (10, 24)
fn sum_product(numbers: Vec<isize>) -> (isize, isize) {

===============================
-----------------------------
/// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.
/// Empty sum should be equal to 0 and empty product should be equal to 1.
/// >>> sum_product(vec![])
/// (0, 1)
/// >>> sum_product(vec![1, 2, 3, 4])
/// (10, 24)
fn sum_product(numbers: Vec<isize>) -> (isize, isize) {

    let sum: isize = numbers.iter().sum();
    let product: isize = numbers.iter().product();
    (sum, product)
}

fn main() {
    let candidate = sum_product;
    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));
    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));
    assert_eq!(candidate(vec![100, 0]), (100, 0));
    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));
    assert_eq!(candidate(vec![10]), (10, 10));
}

-----------------------------
/// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.
/// Empty sum should be equal to 0 and empty product should be equal to 1.
/// >>> sum_product(vec![])
/// (0, 1)
/// >>> sum_product(vec![1, 2, 3, 4])
/// (10, 24)
fn sum_product(numbers: Vec<isize>) -> (isize, isize) {

    numbers.iter().fold((0, 1), |(s, p), n| (s + n, p * n))
}

fn main() {
    let candidate = sum_product;
    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));
    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));
    assert_eq!(candidate(vec![100, 0]), (100, 0));
    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));
    assert_eq!(candidate(vec![10]), (10, 10));
}

-----------------------------
/// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.
/// Empty sum should be equal to 0 and empty product should be equal to 1.
/// >>> sum_product(vec![])
/// (0, 1)
/// >>> sum_product(vec![1, 2, 3, 4])
/// (10, 24)
fn sum_product(numbers: Vec<isize>) -> (isize, isize) {

    numbers.iter().fold((0, 1), |acc, &x| {
        (acc.0 + x, acc.1 * x)
    })
}

fn main() {
    let candidate = sum_product;
    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));
    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));
    assert_eq!(candidate(vec![100, 0]), (100, 0));
    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));
    assert_eq!(candidate(vec![10]), (10, 10));
}

-----------------------------
/// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.
/// Empty sum should be equal to 0 and empty product should be equal to 1.
/// >>> sum_product(vec![])
/// (0, 1)
/// >>> sum_product(vec![1, 2, 3, 4])
/// (10, 24)
fn sum_product(numbers: Vec<isize>) -> (isize, isize) {

    let mut sum = 0;
    let mut product = 1;
    for i in 0..numbers.len() {
        sum += numbers[i];
        product *= numbers[i];
    }
    (sum, product)
}

fn main() {
    let candidate = sum_product;
    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));
    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));
    assert_eq!(candidate(vec![100, 0]), (100, 0));
    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));
    assert_eq!(candidate(vec![10]), (10, 10));
}

-----------------------------
/// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.
/// Empty sum should be equal to 0 and empty product should be equal to 1.
/// >>> sum_product(vec![])
/// (0, 1)
/// >>> sum_product(vec![1, 2, 3, 4])
/// (10, 24)
fn sum_product(numbers: Vec<isize>) -> (isize, isize) {

    let mut sum = 0;
    let mut product = 1;
    for number in numbers {
        sum += number;
        product *= number;
    }
    (sum, product)
}

fn main() {
    let candidate = sum_product;
    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));
    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));
    assert_eq!(candidate(vec![100, 0]), (100, 0));
    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));
    assert_eq!(candidate(vec![10]), (10, 10));
}

===============================
/// From a given vector of integers, generate a vector of rolling maximum element found until given moment
/// in the sequence.
/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])
/// vec![1, 2, 3, 3, 3, 4, 4]
fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {

===============================
-----------------------------
/// From a given vector of integers, generate a vector of rolling maximum element found until given moment
/// in the sequence.
/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])
/// vec![1, 2, 3, 3, 3, 4, 4]
fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {

    let mut result = Vec::with_capacity(numbers.len());
    let mut max = numbers[0];
    for &number in numbers.iter() {
        max = number.max(max);
        result.push(max);
    }
    result
}

fn main() {
    let candidate = rolling_max;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);
    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);
    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);
}

-----------------------------
/// From a given vector of integers, generate a vector of rolling maximum element found until given moment
/// in the sequence.
/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])
/// vec![1, 2, 3, 3, 3, 4, 4]
fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {

    let mut rolling_max: Vec<isize> = Vec::new();
    rolling_max.push(numbers[0]);
    for i in 1..numbers.len() {
        rolling_max.push(numbers[i].max(rolling_max[i - 1]));
    }
    rolling_max
}

fn main() {
    let candidate = rolling_max;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);
    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);
    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);
}

-----------------------------
/// From a given vector of integers, generate a vector of rolling maximum element found until given moment
/// in the sequence.
/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])
/// vec![1, 2, 3, 3, 3, 4, 4]
fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {

    // TODO: Implement the function
    let mut max_vec = Vec::new();
    for x in &numbers {
        let mut max_val = *x;
        for y in &numbers {
            if max_val < *y {
                max_val = *y;
            }
        }
        max_vec.push(max_val);
    }

    max_vec
}

fn main() {
    let candidate = rolling_max;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);
    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);
    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);
}

-----------------------------
/// From a given vector of integers, generate a vector of rolling maximum element found until given moment
/// in the sequence.
/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])
/// vec![1, 2, 3, 3, 3, 4, 4]
fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {

    if numbers.is_empty() {
        return numbers;
    }
    let mut max = numbers[0];
    let mut rolling_max = Vec::with_capacity(numbers.len());
    rolling_max.push(max);
    for number in numbers.iter().skip(1) {
        max = if number > &max { *number } else { max };
        rolling_max.push(max);
    }
    rolling_max
}

fn main() {
    let candidate = rolling_max;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);
    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);
    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);
}

-----------------------------
/// From a given vector of integers, generate a vector of rolling maximum element found until given moment
/// in the sequence.
/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])
/// vec![1, 2, 3, 3, 3, 4, 4]
fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {

    let mut current_max = numbers[0];
    let mut result = vec![];
    for number in &numbers {
        if *number > current_max {
            current_max = *number;
        }
        result.push(current_max);
    }
    result
}

fn main() {
    let candidate = rolling_max;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);
    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);
    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);
}

===============================
/// Find the shortest palindrome that begins with a supplied string.
/// Algorithm idea is simple:
/// - Find the longest postfix of supplied string that is a palindrome.
/// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
/// >>> make_palindrome(String::from(""))
/// String::from("")
/// >>> make_palindrome(String::from("cat"))
/// String::from("catac")
/// >>> make_palindrome(String::from("cata"))
/// String::from("catac")
fn make_palindrome(string: String) -> String {

===============================
-----------------------------
/// Find the shortest palindrome that begins with a supplied string.
/// Algorithm idea is simple:
/// - Find the longest postfix of supplied string that is a palindrome.
/// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
/// >>> make_palindrome(String::from(""))
/// String::from("")
/// >>> make_palindrome(String::from("cat"))
/// String::from("catac")
/// >>> make_palindrome(String::from("cata"))
/// String::from("catac")
fn make_palindrome(string: String) -> String {

    let reverse_string = string.chars().rev().collect::<String>();
    let palindromic_suffix_length = longest_palindromic_suffix_length(string.clone());
    let palindromic_prefix_length = longest_palindromic_prefix_length(reverse_string.clone());
    let mut result_string = String::new();
    let reverse_prefix = reverse_string[..palindromic_prefix_length].to_string();
    for i in 0..palindromic_suffix_length {
        result_string.push(string[i]);
    }
    for i in 0..(palindromic_prefix_length - palindromic_suffix_length) {
        result_string.push(reverse_prefix[i]);
    }
    for i in 0..palindromic_suffix_length {
        result_string.push(reverse_string[i]);
    }
    result_string
}

fn main() {
    let candidate = make_palindrome;
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("x")), String::from("x"));
    assert_eq!(candidate(String::from("xyz")), String::from("xyzyx"));
    assert_eq!(candidate(String::from("xyx")), String::from("xyx"));
    assert_eq!(candidate(String::from("jerry")), String::from("jerryrrej"));
}

-----------------------------
/// Find the shortest palindrome that begins with a supplied string.
/// Algorithm idea is simple:
/// - Find the longest postfix of supplied string that is a palindrome.
/// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
/// >>> make_palindrome(String::from(""))
/// String::from("")
/// >>> make_palindrome(String::from("cat"))
/// String::from("catac")
/// >>> make_palindrome(String::from("cata"))
/// String::from("catac")
fn make_palindrome(string: String) -> String {

    let suffix_index = longest_suffix_index(string);

    if suffix_index == 0 {
        return string;
    }

    let prefix_index = string.len() - suffix_index;

    let prefix = &string[0..prefix_index];
    let suffix = &string[prefix_index..];

    let mut reversed_prefix = prefix.chars().rev().collect::<String>();
    reversed_prefix.push_str(suffix);

    reversed_prefix
}

fn main() {
    let candidate = make_palindrome;
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("x")), String::from("x"));
    assert_eq!(candidate(String::from("xyz")), String::from("xyzyx"));
    assert_eq!(candidate(String::from("xyx")), String::from("xyx"));
    assert_eq!(candidate(String::from("jerry")), String::from("jerryrrej"));
}

-----------------------------
/// Find the shortest palindrome that begins with a supplied string.
/// Algorithm idea is simple:
/// - Find the longest postfix of supplied string that is a palindrome.
/// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
/// >>> make_palindrome(String::from(""))
/// String::from("")
/// >>> make_palindrome(String::from("cat"))
/// String::from("catac")
/// >>> make_palindrome(String::from("cata"))
/// String::from("catac")
fn make_palindrome(string: String) -> String {

    let reversed_string = string.chars().rev().collect::<String>();
    let mut longest_palindrome = String::from("");

    // Go through each character of the reversed string and see if we can find a match in the original string.
    for (index, char) in reversed_string.chars().enumerate() {
        let mut string_char = string.chars().rev().nth(index).unwrap();
        while string_char != char {
            if string_char == reversed_string.chars().nth(index).unwrap() {
                // If we've reached the beginning of the string, stop.
                if string_char == string.chars().nth(0).unwrap() {
                    break;
                }
                // Otherwise, move the starting index backwards and check again.
                string_char = string.chars().nth(string_char.len_utf8() - 1).unwrap();
            } else {
                // If we've found the shortest palindrome, stop and use it.
                if longest_palindrome.len() > index {
                    break;
                }
                // Otherwise, keep going.
                longest_palindrome = format!("{}{}", longest_palindrome, string_char);
                string_char = string.chars().nth(string_char.len_utf8() - 1).unwrap();
            }
        }
    }

    let mut palindrome = String::from(string);
    palindrome.push_str(&reversed_string[..longest_palindrome.len()]);
    palindrome
}

fn main() {
    let candidate = make_palindrome;
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("x")), String::from("x"));
    assert_eq!(candidate(String::from("xyz")), String::from("xyzyx"));
    assert_eq!(candidate(String::from("xyx")), String::from("xyx"));
    assert_eq!(candidate(String::from("jerry")), String::from("jerryrrej"));
}

-----------------------------
/// Find the shortest palindrome that begins with a supplied string.
/// Algorithm idea is simple:
/// - Find the longest postfix of supplied string that is a palindrome.
/// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
/// >>> make_palindrome(String::from(""))
/// String::from("")
/// >>> make_palindrome(String::from("cat"))
/// String::from("catac")
/// >>> make_palindrome(String::from("cata"))
/// String::from("catac")
fn make_palindrome(string: String) -> String {

    let mut suffix = string.clone();
    let mut prefix = String::new();
    let mut result = String::new();

    while !suffix.is_empty() && is_palindrome(&suffix) {
        let mut char_iter = suffix.chars();
        let mut char_iter_rev = suffix.chars().rev();
        let suffix_char = char_iter.next().unwrap();
        let suffix_rev_char = char_iter_rev.next().unwrap();

        prefix.push(suffix_char);
        suffix = String::from(suffix_rev_char) + &suffix.clone();
    }

    result = string.clone() + &prefix.clone();

    result.clone()
}

fn main() {
    let candidate = make_palindrome;
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("x")), String::from("x"));
    assert_eq!(candidate(String::from("xyz")), String::from("xyzyx"));
    assert_eq!(candidate(String::from("xyx")), String::from("xyx"));
    assert_eq!(candidate(String::from("jerry")), String::from("jerryrrej"));
}

-----------------------------
/// Find the shortest palindrome that begins with a supplied string.
/// Algorithm idea is simple:
/// - Find the longest postfix of supplied string that is a palindrome.
/// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
/// >>> make_palindrome(String::from(""))
/// String::from("")
/// >>> make_palindrome(String::from("cat"))
/// String::from("catac")
/// >>> make_palindrome(String::from("cata"))
/// String::from("catac")
fn make_palindrome(string: String) -> String {

    let mut prefix_palindrome = string.clone();
    let mut suffix_palindrome = string;
    let mut suffix_reversed: String;

    while !is_palindrome(&suffix_palindrome) {
        suffix_reversed = String::from(suffix_palindrome.chars().rev().collect::<String>());
        let prefix_len = prefix_palindrome.len();
        let suffix_len = suffix_palindrome.len();

        if prefix_len >= suffix_len {
            prefix_palindrome.truncate(prefix_len - 1);
        } else {
            suffix_palindrome.truncate(suffix_len - 1);
        }

        prefix_palindrome.push_str(&suffix_reversed);
    }
    String::from(&prefix_palindrome)
}

fn main() {
    let candidate = make_palindrome;
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("x")), String::from("x"));
    assert_eq!(candidate(String::from("xyz")), String::from("xyzyx"));
    assert_eq!(candidate(String::from("xyx")), String::from("xyx"));
    assert_eq!(candidate(String::from("jerry")), String::from("jerryrrej"));
}

===============================
/// Input are two strings a and b consisting only of 1s and 0s.
/// Perform binary XOR on these inputs and return result also as a string.
/// >>> string_xor(String::from("010"), String::from("110"))
/// String::from("100")
fn string_xor(a: String, b: String) -> String {

===============================
-----------------------------
/// Input are two strings a and b consisting only of 1s and 0s.
/// Perform binary XOR on these inputs and return result also as a string.
/// >>> string_xor(String::from("010"), String::from("110"))
/// String::from("100")
fn string_xor(a: String, b: String) -> String {

    assert_eq!(a.len(), b.len());
    let mut result = String::with_capacity(a.len());
    for (a, b) in a.chars().zip(b.chars()) {
        result.push(match (a, b) {
            ('0', '0') => '0',
            ('0', '1') => '1',
            ('1', '0') => '1',
            ('1', '1') => '0',
            _ => panic!("invalid character"),
        });
    }
    result
}

fn main() {
    let candidate = string_xor;
    assert_eq!(candidate(String::from("111000"), String::from("101010")), String::from("010010"));
    assert_eq!(candidate(String::from("1"), String::from("1")), String::from("0"));
    assert_eq!(candidate(String::from("0101"), String::from("0000")), String::from("0101"));
}

-----------------------------
/// Input are two strings a and b consisting only of 1s and 0s.
/// Perform binary XOR on these inputs and return result also as a string.
/// >>> string_xor(String::from("010"), String::from("110"))
/// String::from("100")
fn string_xor(a: String, b: String) -> String {

    let mut result = String::new();
    let a_chars: Vec<char> = a.chars().collect();
    let b_chars: Vec<char> = b.chars().collect();
    if a.len() == 0 || b.len() == 0 {
        return result;
    }
    let mut i = 0;
    let mut j = 0;
    while i < a.len() && j < b.len() {
        result.push(match (a_chars[i] == '1', b_chars[j] == '1') {
            (true, true) => '0',
            (true, false) => '1',
            (false, true) => '1',
            (false, false) => '0',
        });
        i += 1;
        j += 1;
    }
    if i < a.len() {
        result.push_str(&a[i..]);
    } else if j < b.len() {
        result.push_str(&b[j..]);
    }
    result
}

fn main() {
    let candidate = string_xor;
    assert_eq!(candidate(String::from("111000"), String::from("101010")), String::from("010010"));
    assert_eq!(candidate(String::from("1"), String::from("1")), String::from("0"));
    assert_eq!(candidate(String::from("0101"), String::from("0000")), String::from("0101"));
}

-----------------------------
/// Input are two strings a and b consisting only of 1s and 0s.
/// Perform binary XOR on these inputs and return result also as a string.
/// >>> string_xor(String::from("010"), String::from("110"))
/// String::from("100")
fn string_xor(a: String, b: String) -> String {

    assert_eq!(a.len(), b.len());
    let mut res = String::new();
    let mut carry = 0;
    let mut a_itr = a.chars().rev();
    let mut b_itr = b.chars().rev();
    while let (Some(a_bit), Some(b_bit)) = (a_itr.next(), b_itr.next()) {
        let (x, c) = if a_bit == '0' && b_bit == '0' {
            (0, carry)
        } else if a_bit == '1' && b_bit == '0' {
            (1, 1)
        } else if a_bit == '0' && b_bit == '1' {
            (1, 1)
        } else if a_bit == '1' && b_bit == '1' {
            (0, 0)
        } else {
            unreachable!()
        };
        res.push((x ^ c) as char);
        carry = c;
    }
    res.chars().rev().collect()
}

fn main() {
    let candidate = string_xor;
    assert_eq!(candidate(String::from("111000"), String::from("101010")), String::from("010010"));
    assert_eq!(candidate(String::from("1"), String::from("1")), String::from("0"));
    assert_eq!(candidate(String::from("0101"), String::from("0000")), String::from("0101"));
}

-----------------------------
/// Input are two strings a and b consisting only of 1s and 0s.
/// Perform binary XOR on these inputs and return result also as a string.
/// >>> string_xor(String::from("010"), String::from("110"))
/// String::from("100")
fn string_xor(a: String, b: String) -> String {

    let a = a.chars().collect::<Vec<char>>();
    let b = b.chars().collect::<Vec<char>>();
    let mut result = Vec::new();
    let mut carry = 0;

    for i in 0..std::cmp::max(a.len(), b.len()) {
        let a_val = match a.get(i) {
            Some(x) => *x,
            None => '0',
        };
        let b_val = match b.get(i) {
            Some(x) => *x,
            None => '0',
        };

        let xor_val = a_val ^ b_val;

        let current_sum = xor_val as u8 + carry;

        match current_sum {
            0 => result.push('0'),
            1 => result.push('1'),
            2 => {
                carry = 1;
                result.push('0');
            }
            3 => {
                carry = 1;
                result.push('1');
            }
            _ => panic!("unreachable: {:?}", current_sum),
        }
    }

    if carry != 0 {
        result.push(carry as char)
    }

    result.reverse();
    result.iter().collect()
}

fn main() {
    let candidate = string_xor;
    assert_eq!(candidate(String::from("111000"), String::from("101010")), String::from("010010"));
    assert_eq!(candidate(String::from("1"), String::from("1")), String::from("0"));
    assert_eq!(candidate(String::from("0101"), String::from("0000")), String::from("0101"));
}

-----------------------------
/// Input are two strings a and b consisting only of 1s and 0s.
/// Perform binary XOR on these inputs and return result also as a string.
/// >>> string_xor(String::from("010"), String::from("110"))
/// String::from("100")
fn string_xor(a: String, b: String) -> String {

    assert_eq!(a.len(), b.len());
    let mut result = String::with_capacity(a.len());
    for i in 0..a.len() {
        let a_bit = a.chars().nth(i).unwrap();
        let b_bit = b.chars().nth(i).unwrap();
        let res = match (a_bit, b_bit) {
            ('1', '1') => '0',
            ('0', '0') => '0',
            _ => '1',
        };
        result.push(res);
    }
    result
}

fn main() {
    let candidate = string_xor;
    assert_eq!(candidate(String::from("111000"), String::from("101010")), String::from("010010"));
    assert_eq!(candidate(String::from("1"), String::from("1")), String::from("0"));
    assert_eq!(candidate(String::from("0101"), String::from("0000")), String::from("0101"));
}

===============================
/// Out of vector of strings, return the longest one. Return the first one in case of multiple
/// strings of the same length. Return None in case the input vector is empty.
/// >>> longest(vec![])
/// None
/// >>> longest(vec![String::from("a"), String::from("b"), String::from("c")])
/// Some(String::from("a"))
/// >>> longest(vec![String::from("a"), String::from("bb"), String::from("ccc")])
/// Some(String::from("ccc"))
fn longest(strings: Vec<String>) -> Option<String> {

===============================
-----------------------------
/// Out of vector of strings, return the longest one. Return the first one in case of multiple
/// strings of the same length. Return None in case the input vector is empty.
/// >>> longest(vec![])
/// None
/// >>> longest(vec![String::from("a"), String::from("b"), String::from("c")])
/// Some(String::from("a"))
/// >>> longest(vec![String::from("a"), String::from("bb"), String::from("ccc")])
/// Some(String::from("ccc"))
fn longest(strings: Vec<String>) -> Option<String> {

    let mut longest_string: Option<String> = None;
    for string in strings {
        if longest_string.is_none() || longest_string.unwrap().len() < string.len() {
            longest_string = Some(string);
        }
    }
    longest_string
}

fn main() {
    let candidate = longest;
    assert_eq!(candidate(Vec::<String>::new()), None);
    assert_eq!(candidate(vec![String::from("x"), String::from("y"), String::from("z")]), Some(String::from("x")));
    assert_eq!(candidate(vec![String::from("x"), String::from("yyy"), String::from("zzzz"), String::from("www"), String::from("kkkk"), String::from("abc")]), Some(String::from("zzzz")));
}

-----------------------------
/// Out of vector of strings, return the longest one. Return the first one in case of multiple
/// strings of the same length. Return None in case the input vector is empty.
/// >>> longest(vec![])
/// None
/// >>> longest(vec![String::from("a"), String::from("b"), String::from("c")])
/// Some(String::from("a"))
/// >>> longest(vec![String::from("a"), String::from("bb"), String::from("ccc")])
/// Some(String::from("ccc"))
fn longest(strings: Vec<String>) -> Option<String> {

    strings.iter().fold(None, |max, str| {
        match max {
            Some(ref m) => {
                match str.len().cmp(&m.len()) {
                    Ordering::Equal => Some(str.clone()),
                    Ordering::Greater => Some(str.clone()),
                    Ordering::Less => max
                }
            }
            None => Some(str.clone())
        }
    })
}

fn main() {
    let candidate = longest;
    assert_eq!(candidate(Vec::<String>::new()), None);
    assert_eq!(candidate(vec![String::from("x"), String::from("y"), String::from("z")]), Some(String::from("x")));
    assert_eq!(candidate(vec![String::from("x"), String::from("yyy"), String::from("zzzz"), String::from("www"), String::from("kkkk"), String::from("abc")]), Some(String::from("zzzz")));
}

-----------------------------
/// Out of vector of strings, return the longest one. Return the first one in case of multiple
/// strings of the same length. Return None in case the input vector is empty.
/// >>> longest(vec![])
/// None
/// >>> longest(vec![String::from("a"), String::from("b"), String::from("c")])
/// Some(String::from("a"))
/// >>> longest(vec![String::from("a"), String::from("bb"), String::from("ccc")])
/// Some(String::from("ccc"))
fn longest(strings: Vec<String>) -> Option<String> {

    strings
        .iter()
        .max_by(|a, b| a.len().cmp(&b.len()))
        .map(|s| s.to_string())
}

fn main() {
    let candidate = longest;
    assert_eq!(candidate(Vec::<String>::new()), None);
    assert_eq!(candidate(vec![String::from("x"), String::from("y"), String::from("z")]), Some(String::from("x")));
    assert_eq!(candidate(vec![String::from("x"), String::from("yyy"), String::from("zzzz"), String::from("www"), String::from("kkkk"), String::from("abc")]), Some(String::from("zzzz")));
}

-----------------------------
/// Out of vector of strings, return the longest one. Return the first one in case of multiple
/// strings of the same length. Return None in case the input vector is empty.
/// >>> longest(vec![])
/// None
/// >>> longest(vec![String::from("a"), String::from("b"), String::from("c")])
/// Some(String::from("a"))
/// >>> longest(vec![String::from("a"), String::from("bb"), String::from("ccc")])
/// Some(String::from("ccc"))
fn longest(strings: Vec<String>) -> Option<String> {

    if strings.is_empty() {
        None
    } else {
        let mut longest_len = 0;
        let mut longest_string = None;
        for s in strings.iter() {
            if s.len() > longest_len {
                longest_len = s.len();
                longest_string = Some(s.to_string());
            }
        }
        longest_string
    }
}

fn main() {
    let candidate = longest;
    assert_eq!(candidate(Vec::<String>::new()), None);
    assert_eq!(candidate(vec![String::from("x"), String::from("y"), String::from("z")]), Some(String::from("x")));
    assert_eq!(candidate(vec![String::from("x"), String::from("yyy"), String::from("zzzz"), String::from("www"), String::from("kkkk"), String::from("abc")]), Some(String::from("zzzz")));
}

-----------------------------
/// Out of vector of strings, return the longest one. Return the first one in case of multiple
/// strings of the same length. Return None in case the input vector is empty.
/// >>> longest(vec![])
/// None
/// >>> longest(vec![String::from("a"), String::from("b"), String::from("c")])
/// Some(String::from("a"))
/// >>> longest(vec![String::from("a"), String::from("bb"), String::from("ccc")])
/// Some(String::from("ccc"))
fn longest(strings: Vec<String>) -> Option<String> {

    if strings.is_empty() {
        return None;
    }
    let mut longest = &strings[0];
    for string in strings {
        if string.len() > longest.len() {
            longest = string;
        }
    }
    Some(longest.to_string())
}

fn main() {
    let candidate = longest;
    assert_eq!(candidate(Vec::<String>::new()), None);
    assert_eq!(candidate(vec![String::from("x"), String::from("y"), String::from("z")]), Some(String::from("x")));
    assert_eq!(candidate(vec![String::from("x"), String::from("yyy"), String::from("zzzz"), String::from("www"), String::from("kkkk"), String::from("abc")]), Some(String::from("zzzz")));
}

===============================
/// Return a greatest common divisor of two integers a and b
/// >>> greatest_common_divisor(3, 5)
/// 1
/// >>> greatest_common_divisor(25, 15)
/// 5
fn greatest_common_divisor(a: isize, b: isize) -> isize {

===============================
-----------------------------
/// Return a greatest common divisor of two integers a and b
/// >>> greatest_common_divisor(3, 5)
/// 1
/// >>> greatest_common_divisor(25, 15)
/// 5
fn greatest_common_divisor(a: isize, b: isize) -> isize {

    if a == 0 {
        return b.abs();
    }
    if b == 0 {
        return a.abs();
    }
    let mut a = a;
    let mut b = b;
    while a != b {
        if a > b {
            a -= b;
        } else {
            b -= a;
        }
    }
    a.abs()
}

fn main() {
    let candidate = greatest_common_divisor;
    assert_eq!(candidate(3, 7), 1);
    assert_eq!(candidate(10, 15), 5);
    assert_eq!(candidate(49, 14), 7);
    assert_eq!(candidate(144, 60), 12);
}

-----------------------------
/// Return a greatest common divisor of two integers a and b
/// >>> greatest_common_divisor(3, 5)
/// 1
/// >>> greatest_common_divisor(25, 15)
/// 5
fn greatest_common_divisor(a: isize, b: isize) -> isize {

    if b == 0 {
        a
    } else {
        greatest_common_divisor(b, a % b)
    }
}

fn main() {
    let candidate = greatest_common_divisor;
    assert_eq!(candidate(3, 7), 1);
    assert_eq!(candidate(10, 15), 5);
    assert_eq!(candidate(49, 14), 7);
    assert_eq!(candidate(144, 60), 12);
}

-----------------------------
/// Return a greatest common divisor of two integers a and b
/// >>> greatest_common_divisor(3, 5)
/// 1
/// >>> greatest_common_divisor(25, 15)
/// 5
fn greatest_common_divisor(a: isize, b: isize) -> isize {

    if b == 0 {
        return a;
    } else {
        return greatest_common_divisor(b, a % b);
    }
}

fn main() {
    let candidate = greatest_common_divisor;
    assert_eq!(candidate(3, 7), 1);
    assert_eq!(candidate(10, 15), 5);
    assert_eq!(candidate(49, 14), 7);
    assert_eq!(candidate(144, 60), 12);
}

-----------------------------
/// Return a greatest common divisor of two integers a and b
/// >>> greatest_common_divisor(3, 5)
/// 1
/// >>> greatest_common_divisor(25, 15)
/// 5
fn greatest_common_divisor(a: isize, b: isize) -> isize {

    if b == 0 {
        a
    } else {
        greatest_common_divisor(b, a % b)
    }
}

fn main() {
    let candidate = greatest_common_divisor;
    assert_eq!(candidate(3, 7), 1);
    assert_eq!(candidate(10, 15), 5);
    assert_eq!(candidate(49, 14), 7);
    assert_eq!(candidate(144, 60), 12);
}

-----------------------------
/// Return a greatest common divisor of two integers a and b
/// >>> greatest_common_divisor(3, 5)
/// 1
/// >>> greatest_common_divisor(25, 15)
/// 5
fn greatest_common_divisor(a: isize, b: isize) -> isize {

    let a = if a < 0 { -a } else { a };
    let b = if b < 0 { -b } else { b };
    let mut x = a;
    let mut y = b;
    while x != 0 {
        let t = x;
        x = y % x;
        y = t;
    }
    if y > 0 {
        y
    } else {
        -y
    }
}

fn main() {
    let candidate = greatest_common_divisor;
    assert_eq!(candidate(3, 7), 1);
    assert_eq!(candidate(10, 15), 5);
    assert_eq!(candidate(49, 14), 7);
    assert_eq!(candidate(144, 60), 12);
}

===============================
/// Return vector of all prefixes from shortest to longest of the input string
/// >>> all_prefixes(String::from("abc"))
/// vec![String::from("a"), String::from("ab"), String::from("abc")]
fn all_prefixes(string: String) -> Vec<String> {

===============================
-----------------------------
/// Return vector of all prefixes from shortest to longest of the input string
/// >>> all_prefixes(String::from("abc"))
/// vec![String::from("a"), String::from("ab"), String::from("abc")]
fn all_prefixes(string: String) -> Vec<String> {

    let mut prefixes = Vec::<String>::new();
    let chars: Vec<char> = string.chars().collect();
    for i in 0..chars.len() {
        let mut prefix = String::new();
        for j in 0..i + 1 {
            prefix.push(chars[j]);
        }
        prefixes.push(prefix);
    }
    prefixes
}

fn main() {
    let candidate = all_prefixes;
    assert_eq!(candidate(String::from("")), Vec::<String>::new());
    assert_eq!(candidate(String::from("asdfgh")), vec![String::from("a"), String::from("as"), String::from("asd"), String::from("asdf"), String::from("asdfg"), String::from("asdfgh")]);
    assert_eq!(candidate(String::from("WWW")), vec![String::from("W"), String::from("WW"), String::from("WWW")]);
}

-----------------------------
/// Return vector of all prefixes from shortest to longest of the input string
/// >>> all_prefixes(String::from("abc"))
/// vec![String::from("a"), String::from("ab"), String::from("abc")]
fn all_prefixes(string: String) -> Vec<String> {

    // TODO: Complete me
    // HINT: Try using .chars() method
    // HINT: Try using Vec::push()
    // HINT: Try using String::from() to convert a char into a String
    // HINT: Try using String::from_iter() to convert a Vec<char> into a String
    // HINT: Try using String::len() to get the length of a String
    // HINT: Try using String::chars() to get a vector of chars from a String
    // HINT: Try using Iterator::take() to get a vector of chars from a String
    // HINT: Try using Iterator::enumerate() to get index and item
    // HINT: Try using Iterator::map() to convert an Iterator<Item=char> to Iterator<Item=String>
    // HINT: Try using Iterator::fold() to convert an Iterator<Item=String> to String
    // HINT: Try using String::push_str()
    // HINT: Try using String::push()
    // HINT: Try using String::from_iter()
    // HINT: Try using .clone()
    // HINT: Try using Vec::push()
    // HINT: Try using Vec::clone()
    vec![
        String::from("a"),
        String::from("ab"),
        String::from("abc"),
    ]
}

fn main() {
    let candidate = all_prefixes;
    assert_eq!(candidate(String::from("")), Vec::<String>::new());
    assert_eq!(candidate(String::from("asdfgh")), vec![String::from("a"), String::from("as"), String::from("asd"), String::from("asdf"), String::from("asdfg"), String::from("asdfgh")]);
    assert_eq!(candidate(String::from("WWW")), vec![String::from("W"), String::from("WW"), String::from("WWW")]);
}

-----------------------------
/// Return vector of all prefixes from shortest to longest of the input string
/// >>> all_prefixes(String::from("abc"))
/// vec![String::from("a"), String::from("ab"), String::from("abc")]
fn all_prefixes(string: String) -> Vec<String> {

    let mut prefixes = Vec::<String>::new();
    for i in (0..=string.len()).rev() {
        prefixes.push(string[0..i].to_string());
    }
    prefixes
}

fn main() {
    let candidate = all_prefixes;
    assert_eq!(candidate(String::from("")), Vec::<String>::new());
    assert_eq!(candidate(String::from("asdfgh")), vec![String::from("a"), String::from("as"), String::from("asd"), String::from("asdf"), String::from("asdfg"), String::from("asdfgh")]);
    assert_eq!(candidate(String::from("WWW")), vec![String::from("W"), String::from("WW"), String::from("WWW")]);
}

-----------------------------
/// Return vector of all prefixes from shortest to longest of the input string
/// >>> all_prefixes(String::from("abc"))
/// vec![String::from("a"), String::from("ab"), String::from("abc")]
fn all_prefixes(string: String) -> Vec<String> {

    let mut prefixes: Vec<String> = Vec::new();
    let mut prefix: String = String::new();
    for character in string.chars() {
        prefix.push(character);
        prefixes.push(String::from(prefix.clone()));
    }
    prefixes
}

fn main() {
    let candidate = all_prefixes;
    assert_eq!(candidate(String::from("")), Vec::<String>::new());
    assert_eq!(candidate(String::from("asdfgh")), vec![String::from("a"), String::from("as"), String::from("asd"), String::from("asdf"), String::from("asdfg"), String::from("asdfgh")]);
    assert_eq!(candidate(String::from("WWW")), vec![String::from("W"), String::from("WW"), String::from("WWW")]);
}

-----------------------------
/// Return vector of all prefixes from shortest to longest of the input string
/// >>> all_prefixes(String::from("abc"))
/// vec![String::from("a"), String::from("ab"), String::from("abc")]
fn all_prefixes(string: String) -> Vec<String> {

    let mut all_prefixes = Vec::new();
    all_prefixes.push(String::from(""));
    for character in string.chars() {
        let mut new_prefixes = Vec::new();
        for prefix in all_prefixes.iter() {
            new_prefixes.push(prefix.to_string() + &character.to_string());
        }
        all_prefixes = new_prefixes;
    }
    all_prefixes
}

fn main() {
    let candidate = all_prefixes;
    assert_eq!(candidate(String::from("")), Vec::<String>::new());
    assert_eq!(candidate(String::from("asdfgh")), vec![String::from("a"), String::from("as"), String::from("asd"), String::from("asdf"), String::from("asdfg"), String::from("asdfgh")]);
    assert_eq!(candidate(String::from("WWW")), vec![String::from("W"), String::from("WW"), String::from("WWW")]);
}

===============================
/// Return a string containing space-delimited numbers starting from 0 upto n inclusive.
/// >>> string_sequence(0)
/// String::from("0")
/// >>> string_sequence(5)
/// String::from("0 1 2 3 4 5")
fn string_sequence(n: isize) -> String {

===============================
-----------------------------
/// Return a string containing space-delimited numbers starting from 0 upto n inclusive.
/// >>> string_sequence(0)
/// String::from("0")
/// >>> string_sequence(5)
/// String::from("0 1 2 3 4 5")
fn string_sequence(n: isize) -> String {

    let mut result = String::new();
    for x in 0..n + 1 {
        if x > 0 {
            result.push(' ')
        }
        result.push_str(x.to_string().as_str());
    }
    result
}

fn main() {
    let candidate = string_sequence;
    assert_eq!(candidate(0), String::from("0"));
    assert_eq!(candidate(3), String::from("0 1 2 3"));
    assert_eq!(candidate(10), String::from("0 1 2 3 4 5 6 7 8 9 10"));
}

-----------------------------
/// Return a string containing space-delimited numbers starting from 0 upto n inclusive.
/// >>> string_sequence(0)
/// String::from("0")
/// >>> string_sequence(5)
/// String::from("0 1 2 3 4 5")
fn string_sequence(n: isize) -> String {

    if n < 0 {
        return String::from("");
    }
    let mut s = String::new();
    for i in 0..(n + 1) {
        s += &i.to_string();
        if i < n {
            s += " ";
        }
    }
    s
}

fn main() {
    let candidate = string_sequence;
    assert_eq!(candidate(0), String::from("0"));
    assert_eq!(candidate(3), String::from("0 1 2 3"));
    assert_eq!(candidate(10), String::from("0 1 2 3 4 5 6 7 8 9 10"));
}

-----------------------------
/// Return a string containing space-delimited numbers starting from 0 upto n inclusive.
/// >>> string_sequence(0)
/// String::from("0")
/// >>> string_sequence(5)
/// String::from("0 1 2 3 4 5")
fn string_sequence(n: isize) -> String {

    let mut s: String = "".to_string();
    for i in 0..=n {
        if s.len() > 0 {
            s.push_str(" ");
        }
        s.push_str(&i.to_string());
    }
    s
}

fn main() {
    let candidate = string_sequence;
    assert_eq!(candidate(0), String::from("0"));
    assert_eq!(candidate(3), String::from("0 1 2 3"));
    assert_eq!(candidate(10), String::from("0 1 2 3 4 5 6 7 8 9 10"));
}

-----------------------------
/// Return a string containing space-delimited numbers starting from 0 upto n inclusive.
/// >>> string_sequence(0)
/// String::from("0")
/// >>> string_sequence(5)
/// String::from("0 1 2 3 4 5")
fn string_sequence(n: isize) -> String {

    let mut result = String::new();
    for i in 0..n {
        result += &format!("{} ", i);
    }
    result
}

fn main() {
    let candidate = string_sequence;
    assert_eq!(candidate(0), String::from("0"));
    assert_eq!(candidate(3), String::from("0 1 2 3"));
    assert_eq!(candidate(10), String::from("0 1 2 3 4 5 6 7 8 9 10"));
}

-----------------------------
/// Return a string containing space-delimited numbers starting from 0 upto n inclusive.
/// >>> string_sequence(0)
/// String::from("0")
/// >>> string_sequence(5)
/// String::from("0 1 2 3 4 5")
fn string_sequence(n: isize) -> String {

    let mut s = String::new();
    for i in 0..(n + 1) {
        if i != 0 {
            s += " ";
        }
        s += &i.to_string();
    }
    return s;
}

fn main() {
    let candidate = string_sequence;
    assert_eq!(candidate(0), String::from("0"));
    assert_eq!(candidate(3), String::from("0 1 2 3"));
    assert_eq!(candidate(10), String::from("0 1 2 3 4 5 6 7 8 9 10"));
}

===============================
/// Given a string, find out how many distinct characters (regardless of case) does it consist of
/// >>> count_distinct_characters(String::from("xyzXYZ"))
/// 3
/// >>> count_distinct_characters(String::from("Jerry"))
/// 4
fn count_distinct_characters(string: String) -> isize {

===============================
-----------------------------
/// Given a string, find out how many distinct characters (regardless of case) does it consist of
/// >>> count_distinct_characters(String::from("xyzXYZ"))
/// 3
/// >>> count_distinct_characters(String::from("Jerry"))
/// 4
fn count_distinct_characters(string: String) -> isize {

    let mut dict: HashMap<char, bool> = HashMap::new();

    for c in string.chars() {
        if dict.contains_key(&c) {
            dict.remove(&c);
        } else {
            dict.insert(c, true);
        }
    }

    dict.len() as isize
}

fn main() {
    let candidate = count_distinct_characters;
    assert_eq!(candidate(String::from("")), 0);
    assert_eq!(candidate(String::from("abcde")), 5);
    assert_eq!(candidate(String::from("abcdecadeCADE")), 5);
    assert_eq!(candidate(String::from("aaaaAAAAaaaa")), 1);
    assert_eq!(candidate(String::from("Jerry jERRY JeRRRY")), 5);
}

-----------------------------
/// Given a string, find out how many distinct characters (regardless of case) does it consist of
/// >>> count_distinct_characters(String::from("xyzXYZ"))
/// 3
/// >>> count_distinct_characters(String::from("Jerry"))
/// 4
fn count_distinct_characters(string: String) -> isize {

    let mut char_set: HashSet<char> = HashSet::new();

    for ch in string.chars() {
        char_set.insert(ch.to_ascii_lowercase());
    }

    char_set.len() as isize
}

fn main() {
    let candidate = count_distinct_characters;
    assert_eq!(candidate(String::from("")), 0);
    assert_eq!(candidate(String::from("abcde")), 5);
    assert_eq!(candidate(String::from("abcdecadeCADE")), 5);
    assert_eq!(candidate(String::from("aaaaAAAAaaaa")), 1);
    assert_eq!(candidate(String::from("Jerry jERRY JeRRRY")), 5);
}

-----------------------------
/// Given a string, find out how many distinct characters (regardless of case) does it consist of
/// >>> count_distinct_characters(String::from("xyzXYZ"))
/// 3
/// >>> count_distinct_characters(String::from("Jerry"))
/// 4
fn count_distinct_characters(string: String) -> isize {

    let string_bytes = string.to_ascii_lowercase().bytes().collect::<Vec<u8>>();
    let string_bytes_size = string_bytes.len();
    let mut character_count = 0;

    for i in 0..string_bytes_size {
        if i == 0 {
            character_count += 1;
        } else {
            if string_bytes[i - 1] != string_bytes[i] {
                character_count += 1;
            }
        }
    }

    character_count as isize
}

fn main() {
    let candidate = count_distinct_characters;
    assert_eq!(candidate(String::from("")), 0);
    assert_eq!(candidate(String::from("abcde")), 5);
    assert_eq!(candidate(String::from("abcdecadeCADE")), 5);
    assert_eq!(candidate(String::from("aaaaAAAAaaaa")), 1);
    assert_eq!(candidate(String::from("Jerry jERRY JeRRRY")), 5);
}

-----------------------------
/// Given a string, find out how many distinct characters (regardless of case) does it consist of
/// >>> count_distinct_characters(String::from("xyzXYZ"))
/// 3
/// >>> count_distinct_characters(String::from("Jerry"))
/// 4
fn count_distinct_characters(string: String) -> isize {

    let mut character_hash: HashMap<char, bool> = HashMap::new();
    let mut distinct_character_count: isize = 0;

    // Iterate over characters of the string
    for character in string.chars() {
        let is_character_present: bool = character_hash.get(&character).unwrap_or(&false);

        // If the character is not present in the hash, add it to the hash
        // and increment the distinct_character_count
        if !is_character_present {
            character_hash.insert(character, true);
            distinct_character_count += 1;
        }
    }

    distinct_character_count
}

fn main() {
    let candidate = count_distinct_characters;
    assert_eq!(candidate(String::from("")), 0);
    assert_eq!(candidate(String::from("abcde")), 5);
    assert_eq!(candidate(String::from("abcdecadeCADE")), 5);
    assert_eq!(candidate(String::from("aaaaAAAAaaaa")), 1);
    assert_eq!(candidate(String::from("Jerry jERRY JeRRRY")), 5);
}

-----------------------------
/// Given a string, find out how many distinct characters (regardless of case) does it consist of
/// >>> count_distinct_characters(String::from("xyzXYZ"))
/// 3
/// >>> count_distinct_characters(String::from("Jerry"))
/// 4
fn count_distinct_characters(string: String) -> isize {

    let mut map = HashMap::new();
    for c in string.to_lowercase().chars() {
        *map.entry(c).or_insert(0) += 1;
    }

    map.values().len() as isize
}

fn main() {
    let candidate = count_distinct_characters;
    assert_eq!(candidate(String::from("")), 0);
    assert_eq!(candidate(String::from("abcde")), 5);
    assert_eq!(candidate(String::from("abcdecadeCADE")), 5);
    assert_eq!(candidate(String::from("aaaaAAAAaaaa")), 1);
    assert_eq!(candidate(String::from("Jerry jERRY JeRRRY")), 5);
}

===============================
/// Input to this function is a string representing musical notes in a special ASCII format.
/// Your task is to parse this string and return vector of integers corresponding to how many beats does each
/// not last.
/// Here is a legend:
/// 'o' - whole note, lasts four beats
/// 'o|' - half note, lasts two beats
/// '.|' - quater note, lasts one beat
/// >>> parse_music(String::from("o o| .| o| o| .| .| .| .| o o"))
/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
fn parse_music(music_string: String) -> Vec<isize> {

===============================
-----------------------------
/// Input to this function is a string representing musical notes in a special ASCII format.
/// Your task is to parse this string and return vector of integers corresponding to how many beats does each
/// not last.
/// Here is a legend:
/// 'o' - whole note, lasts four beats
/// 'o|' - half note, lasts two beats
/// '.|' - quater note, lasts one beat
/// >>> parse_music(String::from("o o| .| o| o| .| .| .| .| o o"))
/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
fn parse_music(music_string: String) -> Vec<isize> {

    let mut beat_counts = Vec::new();
    for x in music_string.chars() {
        if x == 'o' {
            beat_counts.push(4);
        }
        if x == 'o' && music_string.chars().nth(music_string.len() - 1).unwrap() == '|' {
            beat_counts.push(2);
        }
        if x == '.' && music_string.chars().nth(music_string.len() - 1).unwrap() == '|' {
            beat_counts.push(1);
        }
    }
    return beat_counts;
}

fn main() {
    let candidate = parse_music;
    assert_eq!(candidate(String::from("")), Vec::<isize>::new());
    assert_eq!(candidate(String::from("o o o o")), vec![4, 4, 4, 4]);
    assert_eq!(candidate(String::from(".| .| .| .|")), vec![1, 1, 1, 1]);
    assert_eq!(candidate(String::from("o| o| .| .| o o o o")), vec![2, 2, 1, 1, 4, 4, 4, 4]);
    assert_eq!(candidate(String::from("o| .| o| .| o o| o o|")), vec![2, 1, 2, 1, 4, 2, 4, 2]);
}

-----------------------------
/// Input to this function is a string representing musical notes in a special ASCII format.
/// Your task is to parse this string and return vector of integers corresponding to how many beats does each
/// not last.
/// Here is a legend:
/// 'o' - whole note, lasts four beats
/// 'o|' - half note, lasts two beats
/// '.|' - quater note, lasts one beat
/// >>> parse_music(String::from("o o| .| o| o| .| .| .| .| o o"))
/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
fn parse_music(music_string: String) -> Vec<isize> {

    let mut result: Vec<isize> = Vec::new();
    let mut current_char: char = ' ';
    let mut note_length: isize = 0;
    let mut note_length_chars_count: isize = 0;
    for c in music_string.chars() {
        if c == 'o' {
            note_length = 4;
        } else if c == '|' {
            note_length_chars_count += 1;
            note_length = 2;
        } else if c == '.' {
            note_length_chars_count += 1;
            note_length = 1;
        }
        if note_length_chars_count > 0 {
            if c != current_char {
                result.push(note_length);
                current_char = c;
            }
            note_length_chars_count -= 1;
        }
    }
    result
}

fn main() {
    let candidate = parse_music;
    assert_eq!(candidate(String::from("")), Vec::<isize>::new());
    assert_eq!(candidate(String::from("o o o o")), vec![4, 4, 4, 4]);
    assert_eq!(candidate(String::from(".| .| .| .|")), vec![1, 1, 1, 1]);
    assert_eq!(candidate(String::from("o| o| .| .| o o o o")), vec![2, 2, 1, 1, 4, 4, 4, 4]);
    assert_eq!(candidate(String::from("o| .| o| .| o o| o o|")), vec![2, 1, 2, 1, 4, 2, 4, 2]);
}

-----------------------------
/// Input to this function is a string representing musical notes in a special ASCII format.
/// Your task is to parse this string and return vector of integers corresponding to how many beats does each
/// not last.
/// Here is a legend:
/// 'o' - whole note, lasts four beats
/// 'o|' - half note, lasts two beats
/// '.|' - quater note, lasts one beat
/// >>> parse_music(String::from("o o| .| o| o| .| .| .| .| o o"))
/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
fn parse_music(music_string: String) -> Vec<isize> {

    let mut notes: Vec<isize> = Vec::new();

    for character in music_string.chars() {
        match character {
            'o' => notes.push(4),
            '|' => notes.push(2),
            '.' => notes.push(1),
            _ => (),
        }
    }

    notes
}

fn main() {
    let candidate = parse_music;
    assert_eq!(candidate(String::from("")), Vec::<isize>::new());
    assert_eq!(candidate(String::from("o o o o")), vec![4, 4, 4, 4]);
    assert_eq!(candidate(String::from(".| .| .| .|")), vec![1, 1, 1, 1]);
    assert_eq!(candidate(String::from("o| o| .| .| o o o o")), vec![2, 2, 1, 1, 4, 4, 4, 4]);
    assert_eq!(candidate(String::from("o| .| o| .| o o| o o|")), vec![2, 1, 2, 1, 4, 2, 4, 2]);
}

-----------------------------
/// Input to this function is a string representing musical notes in a special ASCII format.
/// Your task is to parse this string and return vector of integers corresponding to how many beats does each
/// not last.
/// Here is a legend:
/// 'o' - whole note, lasts four beats
/// 'o|' - half note, lasts two beats
/// '.|' - quater note, lasts one beat
/// >>> parse_music(String::from("o o| .| o| o| .| .| .| .| o o"))
/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
fn parse_music(music_string: String) -> Vec<isize> {

    let mut beat_length: Vec<isize> = Vec::new();

    for item in music_string.chars() {
        if item == 'o' {
            beat_length.push(4);
        } else if item == '.' {
            beat_length.push(1);
        } else if item == '|' {
            beat_length.push(2);
        }
    }

    beat_length
}

fn main() {
    let candidate = parse_music;
    assert_eq!(candidate(String::from("")), Vec::<isize>::new());
    assert_eq!(candidate(String::from("o o o o")), vec![4, 4, 4, 4]);
    assert_eq!(candidate(String::from(".| .| .| .|")), vec![1, 1, 1, 1]);
    assert_eq!(candidate(String::from("o| o| .| .| o o o o")), vec![2, 2, 1, 1, 4, 4, 4, 4]);
    assert_eq!(candidate(String::from("o| .| o| .| o o| o o|")), vec![2, 1, 2, 1, 4, 2, 4, 2]);
}

-----------------------------
/// Input to this function is a string representing musical notes in a special ASCII format.
/// Your task is to parse this string and return vector of integers corresponding to how many beats does each
/// not last.
/// Here is a legend:
/// 'o' - whole note, lasts four beats
/// 'o|' - half note, lasts two beats
/// '.|' - quater note, lasts one beat
/// >>> parse_music(String::from("o o| .| o| o| .| .| .| .| o o"))
/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
fn parse_music(music_string: String) -> Vec<isize> {

    let mut result = Vec::new();
    let mut current_music = String::new();
    for c in music_string.chars() {
        if c == 'o' || c == '.' {
            current_music.push(c);
        } else if current_music.len() > 0 {
            result.push(parse_note(current_music));
            current_music.clear();
        }
        if c == '|' {
            current_music.clear();
        }
    }
    if current_music.len() > 0 {
        result.push(parse_note(current_music));
    }
    return result;
}

fn main() {
    let candidate = parse_music;
    assert_eq!(candidate(String::from("")), Vec::<isize>::new());
    assert_eq!(candidate(String::from("o o o o")), vec![4, 4, 4, 4]);
    assert_eq!(candidate(String::from(".| .| .| .|")), vec![1, 1, 1, 1]);
    assert_eq!(candidate(String::from("o| o| .| .| o o o o")), vec![2, 2, 1, 1, 4, 4, 4, 4]);
    assert_eq!(candidate(String::from("o| .| o| .| o o| o o|")), vec![2, 1, 2, 1, 4, 2, 4, 2]);
}

===============================
/// Find how many times a given substring can be found in the original string. Count overlaping cases.
/// >>> how_many_times(String::from(""), String::from("a"))
/// 0
/// >>> how_many_times(String::from("aaa"), String::from("a"))
/// 3
/// >>> how_many_times(String::from("aaaa"), String::from("aa"))
/// 3
fn how_many_times(string: String, substring: String) -> isize {

===============================
-----------------------------
/// Find how many times a given substring can be found in the original string. Count overlaping cases.
/// >>> how_many_times(String::from(""), String::from("a"))
/// 0
/// >>> how_many_times(String::from("aaa"), String::from("a"))
/// 3
/// >>> how_many_times(String::from("aaaa"), String::from("aa"))
/// 3
fn how_many_times(string: String, substring: String) -> isize {

    let mut count: isize = 0;
    let mut pos: usize = 0;

    while pos < string.len() {
        if string.get(pos..pos + substring.len()).unwrap() == substring {
            count += 1;
            pos += substring.len();
        } else {
            pos += 1;
        }
    }

    count
}

fn main() {
    let candidate = how_many_times;
    assert_eq!(candidate(String::from(""), String::from("x")), 0);
    assert_eq!(candidate(String::from("xyxyxyx"), String::from("x")), 4);
    assert_eq!(candidate(String::from("cacacacac"), String::from("cac")), 4);
    assert_eq!(candidate(String::from("john doe"), String::from("john")), 1);
}

-----------------------------
/// Find how many times a given substring can be found in the original string. Count overlaping cases.
/// >>> how_many_times(String::from(""), String::from("a"))
/// 0
/// >>> how_many_times(String::from("aaa"), String::from("a"))
/// 3
/// >>> how_many_times(String::from("aaaa"), String::from("aa"))
/// 3
fn how_many_times(string: String, substring: String) -> isize {

    let mut index = 0;
    let mut counter = 0;

    loop {
        index = string.find(&substring).unwrap_or_else(|| string.len());

        if index == string.len() {
            break;
        }

        counter += 1;
        string.drain(0..index + substring.len());
    }

    counter
}

fn main() {
    let candidate = how_many_times;
    assert_eq!(candidate(String::from(""), String::from("x")), 0);
    assert_eq!(candidate(String::from("xyxyxyx"), String::from("x")), 4);
    assert_eq!(candidate(String::from("cacacacac"), String::from("cac")), 4);
    assert_eq!(candidate(String::from("john doe"), String::from("john")), 1);
}

-----------------------------
/// Find how many times a given substring can be found in the original string. Count overlaping cases.
/// >>> how_many_times(String::from(""), String::from("a"))
/// 0
/// >>> how_many_times(String::from("aaa"), String::from("a"))
/// 3
/// >>> how_many_times(String::from("aaaa"), String::from("aa"))
/// 3
fn how_many_times(string: String, substring: String) -> isize {

    let mut i = 0;
    let mut j = 0;
    let mut k = 0;
    let mut count = 0;
    let mut a = vec![];
    let mut b = vec![];

    for _ in 0..(string.len() - substring.len()) + 1 {
        i = j;
        while j < string.len() && j < substring.len() + i {
            a.push(string[j]);
            b.push(substring[k]);
            j += 1;
            k += 1;
        }
        if a == b {
            count += 1;
            a = vec![];
            b = vec![];
            j = i + 1;
            k = 0;
        }
    }
    count
}

fn main() {
    let candidate = how_many_times;
    assert_eq!(candidate(String::from(""), String::from("x")), 0);
    assert_eq!(candidate(String::from("xyxyxyx"), String::from("x")), 4);
    assert_eq!(candidate(String::from("cacacacac"), String::from("cac")), 4);
    assert_eq!(candidate(String::from("john doe"), String::from("john")), 1);
}

-----------------------------
/// Find how many times a given substring can be found in the original string. Count overlaping cases.
/// >>> how_many_times(String::from(""), String::from("a"))
/// 0
/// >>> how_many_times(String::from("aaa"), String::from("a"))
/// 3
/// >>> how_many_times(String::from("aaaa"), String::from("aa"))
/// 3
fn how_many_times(string: String, substring: String) -> isize {

    let mut num: isize = 0;

    for (i, s) in string.chars().enumerate() {
        let substring_length = substring.chars().count();
        if i + substring_length <= string.len() {
            if &string[i..i + substring_length] == substring {
                num += 1;
            }
        }
    }

    num
}

fn main() {
    let candidate = how_many_times;
    assert_eq!(candidate(String::from(""), String::from("x")), 0);
    assert_eq!(candidate(String::from("xyxyxyx"), String::from("x")), 4);
    assert_eq!(candidate(String::from("cacacacac"), String::from("cac")), 4);
    assert_eq!(candidate(String::from("john doe"), String::from("john")), 1);
}

-----------------------------
/// Find how many times a given substring can be found in the original string. Count overlaping cases.
/// >>> how_many_times(String::from(""), String::from("a"))
/// 0
/// >>> how_many_times(String::from("aaa"), String::from("a"))
/// 3
/// >>> how_many_times(String::from("aaaa"), String::from("aa"))
/// 3
fn how_many_times(string: String, substring: String) -> isize {

    let mut result = 0;
    let mut position_of_substring = string.find(&substring).unwrap_or(string.len() as isize);
    while position_of_substring < string.len() as isize {
        result += 1;
        position_of_substring = string[position_of_substring as usize..].find(&substring).unwrap_or(string.len() as isize);
    }
    result
}

fn main() {
    let candidate = how_many_times;
    assert_eq!(candidate(String::from(""), String::from("x")), 0);
    assert_eq!(candidate(String::from("xyxyxyx"), String::from("x")), 4);
    assert_eq!(candidate(String::from("cacacacac"), String::from("cac")), 4);
    assert_eq!(candidate(String::from("john doe"), String::from("john")), 1);
}

===============================
/// Input is a space-delimited string of numberals from 'zero' to 'nine'.
/// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
/// Return the string with numbers sorted from smallest to largest
/// >>> sort_numbers(String::from("three one five"))
/// String::from("one three five")
fn sort_numbers(numbers: String) -> String {

===============================
-----------------------------
/// Input is a space-delimited string of numberals from 'zero' to 'nine'.
/// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
/// Return the string with numbers sorted from smallest to largest
/// >>> sort_numbers(String::from("three one five"))
/// String::from("one three five")
fn sort_numbers(numbers: String) -> String {

    let sorted = numbers.split_whitespace().sorted().collect::<Vec<&str>>().join(" ");
    sorted.to_string()
}

fn main() {
    let candidate = sort_numbers;
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("three")), String::from("three"));
    assert_eq!(candidate(String::from("three five nine")), String::from("three five nine"));
    assert_eq!(candidate(String::from("five zero four seven nine eight")), String::from("zero four five seven eight nine"));
    assert_eq!(candidate(String::from("six five four three two one zero")), String::from("zero one two three four five six"));
}

-----------------------------
/// Input is a space-delimited string of numberals from 'zero' to 'nine'.
/// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
/// Return the string with numbers sorted from smallest to largest
/// >>> sort_numbers(String::from("three one five"))
/// String::from("one three five")
fn sort_numbers(numbers: String) -> String {

    let mut number_list = numbers.split_whitespace().collect::<Vec<_>>();
    number_list.sort_by(|a, b| a.cmp(b));
    number_list.join(" ")
}

fn main() {
    let candidate = sort_numbers;
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("three")), String::from("three"));
    assert_eq!(candidate(String::from("three five nine")), String::from("three five nine"));
    assert_eq!(candidate(String::from("five zero four seven nine eight")), String::from("zero four five seven eight nine"));
    assert_eq!(candidate(String::from("six five four three two one zero")), String::from("zero one two three four five six"));
}

-----------------------------
/// Input is a space-delimited string of numberals from 'zero' to 'nine'.
/// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
/// Return the string with numbers sorted from smallest to largest
/// >>> sort_numbers(String::from("three one five"))
/// String::from("one three five")
fn sort_numbers(numbers: String) -> String {

    let mut num_list = numbers.split_whitespace().collect::<Vec<&str>>();
    let mut num_list_copy = num_list.clone();

    num_list.sort_by(|a, b| b.cmp(a));

    for (i, _) in num_list.iter().enumerate() {
        num_list_copy[i] = &num_list[i];
    }

    num_list_copy.join(" ")
}

fn main() {
    let candidate = sort_numbers;
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("three")), String::from("three"));
    assert_eq!(candidate(String::from("three five nine")), String::from("three five nine"));
    assert_eq!(candidate(String::from("five zero four seven nine eight")), String::from("zero four five seven eight nine"));
    assert_eq!(candidate(String::from("six five four three two one zero")), String::from("zero one two three four five six"));
}

-----------------------------
/// Input is a space-delimited string of numberals from 'zero' to 'nine'.
/// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
/// Return the string with numbers sorted from smallest to largest
/// >>> sort_numbers(String::from("three one five"))
/// String::from("one three five")
fn sort_numbers(numbers: String) -> String {

    // TODO: Complete this method
    todo!()
}

fn main() {
    let candidate = sort_numbers;
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("three")), String::from("three"));
    assert_eq!(candidate(String::from("three five nine")), String::from("three five nine"));
    assert_eq!(candidate(String::from("five zero four seven nine eight")), String::from("zero four five seven eight nine"));
    assert_eq!(candidate(String::from("six five four three two one zero")), String::from("zero one two three four five six"));
}

-----------------------------
/// Input is a space-delimited string of numberals from 'zero' to 'nine'.
/// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
/// Return the string with numbers sorted from smallest to largest
/// >>> sort_numbers(String::from("three one five"))
/// String::from("one three five")
fn sort_numbers(numbers: String) -> String {

    let mut nums = numbers
        .split(' ')
        .map(|num| {
            if num.eq("zero") {
                return 0;
            } else if num.eq("one") {
                return 1;
            } else if num.eq("two") {
                return 2;
            } else if num.eq("three") {
                return 3;
            } else if num.eq("four") {
                return 4;
            } else if num.eq("five") {
                return 5;
            } else if num.eq("six") {
                return 6;
            } else if num.eq("seven") {
                return 7;
            } else if num.eq("eight") {
                return 8;
            } else if num.eq("nine") {
                return 9;
            }
            return 0;
        })
        .collect::<Vec<i32>>();

    nums.sort_unstable();
    let mut output = String::new();
    for i in 0..nums.len() {
        output = output + nums[i].to_string().as_str() + " ";
    }
    output.trim_end().to_string()
}

fn main() {
    let candidate = sort_numbers;
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("three")), String::from("three"));
    assert_eq!(candidate(String::from("three five nine")), String::from("three five nine"));
    assert_eq!(candidate(String::from("five zero four seven nine eight")), String::from("zero four five seven eight nine"));
    assert_eq!(candidate(String::from("six five four three two one zero")), String::from("zero one two three four five six"));
}

===============================
/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each
/// other and return them in order (smaller number, larger number).
/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
/// (2.0, 2.2)
/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
/// (2.0, 2.0)
fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {

===============================
-----------------------------
/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each
/// other and return them in order (smaller number, larger number).
/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
/// (2.0, 2.2)
/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
/// (2.0, 2.0)
fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {

    if numbers.len() <= 2 {
        panic!("A vector with length 2 or less cannot be given as an argument.");
    }
    let mut numbers: Vec<f64> = numbers;
    numbers.sort();

    let closest = |l: usize, r: usize| {
        let x: f64 = numbers[l];
        let y: f64 = numbers[r];
        (x - y).abs()
    };

    let mut smallest_dist = closest(0, 1);
    let mut left_number = 0;
    let mut right_number = 1;

    for i in 2..numbers.len() {
        let dist = closest(i - 1, i);
        if dist < smallest_dist {
            smallest_dist = dist;
            left_number = i - 1;
            right_number = i;
        }
    }

    let left = numbers[left_number];
    let right = numbers[right_number];
    (left, right)
}

fn main() {
    let candidate = find_closest_elements;
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));
}

-----------------------------
/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each
/// other and return them in order (smaller number, larger number).
/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
/// (2.0, 2.2)
/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
/// (2.0, 2.0)
fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {

    assert!(numbers.len() >= 2, "The input vector must be at least of length two");

    let mut min = numbers[0];
    let mut max = numbers[0];

    for num in &numbers {
        if num > max {
            max = *num;
        }
        if num < min {
            min = *num;
        }
    }
    (min, max)
}

fn main() {
    let candidate = find_closest_elements;
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));
}

-----------------------------
/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each
/// other and return them in order (smaller number, larger number).
/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
/// (2.0, 2.2)
/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
/// (2.0, 2.0)
fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {

    let mut min_diff = 0.0;
    let mut left = 0;
    let mut right = 0;
    for i in 0..numbers.len() - 1 {
        let mut diff = numbers[i + 1] - numbers[i];
        if diff < 0.0 {
            diff = -diff;
        }
        if diff < min_diff {
            min_diff = diff;
            left = i;
            right = i + 1;
        }
    }
    let mut r = Vec::new();
    r.push(numbers[left]);
    r.push(numbers[right]);
    r.sort();
    (r[0], r[1])
}

fn main() {
    let candidate = find_closest_elements;
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));
}

-----------------------------
/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each
/// other and return them in order (smaller number, larger number).
/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
/// (2.0, 2.2)
/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
/// (2.0, 2.0)
fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {

    if numbers.len() < 2 {
        panic!("Vector too small. It must contain at least 2 elements.")
    }
    let mut first_min = &numbers[0];
    let mut second_min = &numbers[0];
    for i in 1..numbers.len() {
        if numbers[i] - numbers[i - 1] < *first_min - numbers[i] {
            first_min = &numbers[i];
            second_min = &numbers[i - 1];
        } else if numbers[i] - numbers[i - 1] > *first_min - numbers[i] {
            first_min = &numbers[i - 1];
            second_min = &numbers[i];
        }
    }
    (first_min, second_min)
}

fn main() {
    let candidate = find_closest_elements;
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));
}

-----------------------------
/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each
/// other and return them in order (smaller number, larger number).
/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
/// (2.0, 2.2)
/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
/// (2.0, 2.0)
fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {

    if numbers.len() <= 1 {
        panic!(
            "The list of numbers cannot be shorter than 2. You provided a list of length {}",
            numbers.len()
        );
    }

    let mut min_diff = std::f64::INFINITY;
    let mut closest_pair = (numbers[0], numbers[1]);

    for i in 1..numbers.len() {
        for j in 0..i {
            let diff = f64::abs(numbers[i] - numbers[j]);
            if diff < min_diff {
                min_diff = diff;
                closest_pair = (numbers[i], numbers[j]);
            }
        }
    }

    closest_pair
}

fn main() {
    let candidate = find_closest_elements;
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));
}

===============================
/// Given vector of numbers (of at least two elements), apply a linear transform to that vector,
/// such that the smallest number will become 0 and the largest will become 1
/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0])
/// vec![0.0, 0.25, 0.5, 0.75, 1.0]
fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {

===============================
-----------------------------
/// Given vector of numbers (of at least two elements), apply a linear transform to that vector,
/// such that the smallest number will become 0 and the largest will become 1
/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0])
/// vec![0.0, 0.25, 0.5, 0.75, 1.0]
fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {

    let min = *numbers.iter().min().unwrap();
    let max = *numbers.iter().max().unwrap();
    let diff = max - min;
    numbers
        .into_iter()
        .map(|v| (v - min) / diff)
        .collect::<Vec<f64>>()
}

fn main() {
    let candidate = rescale_to_unit;
    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);
    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);
    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);
    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);
}

-----------------------------
/// Given vector of numbers (of at least two elements), apply a linear transform to that vector,
/// such that the smallest number will become 0 and the largest will become 1
/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0])
/// vec![0.0, 0.25, 0.5, 0.75, 1.0]
fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {

    // TODO: implement it using iterators

    let min_val = numbers.iter().min().unwrap();
    let max_val = numbers.iter().max().unwrap();
    let mut res = numbers.clone();
    for i in 0..numbers.len() {
        res[i] = (res[i] - min_val) / (max_val - min_val);
    }
    res
}

fn main() {
    let candidate = rescale_to_unit;
    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);
    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);
    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);
    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);
}

-----------------------------
/// Given vector of numbers (of at least two elements), apply a linear transform to that vector,
/// such that the smallest number will become 0 and the largest will become 1
/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0])
/// vec![0.0, 0.25, 0.5, 0.75, 1.0]
fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {

    let min_num = numbers.iter().min().unwrap();
    let max_num = numbers.iter().max().unwrap();
    let range = max_num - min_num;
    if range == 0.0 {
        return numbers.iter().map(|num| *num).collect();
    }

    numbers.iter().map(|num| (num - min_num) / range).collect()
}

fn main() {
    let candidate = rescale_to_unit;
    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);
    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);
    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);
    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);
}

-----------------------------
/// Given vector of numbers (of at least two elements), apply a linear transform to that vector,
/// such that the smallest number will become 0 and the largest will become 1
/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0])
/// vec![0.0, 0.25, 0.5, 0.75, 1.0]
fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {

    let min = numbers.iter().min().unwrap();
    let max = numbers.iter().max().unwrap();
    let range = max - min;
    numbers.iter().map(|x| (*x - min) / range).collect()
}

fn main() {
    let candidate = rescale_to_unit;
    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);
    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);
    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);
    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);
}

-----------------------------
/// Given vector of numbers (of at least two elements), apply a linear transform to that vector,
/// such that the smallest number will become 0 and the largest will become 1
/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0])
/// vec![0.0, 0.25, 0.5, 0.75, 1.0]
fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {

    let mut min = numbers[0];
    let mut max = numbers[0];

    for number in numbers {
        if number > max {
            max = number;
        }
        if number < min {
            min = number;
        }
    }

    let mut rescaled_numbers: Vec<f64> = Vec::new();
    for number in numbers {
        rescaled_numbers.push((number - min) / (max - min));
    }

    rescaled_numbers
}

fn main() {
    let candidate = rescale_to_unit;
    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);
    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);
    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);
    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);
}

===============================
/// Return length of given string
/// >>> strlen(String::from(""))
/// 0
/// >>> strlen(String::from("abc"))
/// 3
fn strlen(string: String) -> isize {

===============================
-----------------------------
/// Return length of given string
/// >>> strlen(String::from(""))
/// 0
/// >>> strlen(String::from("abc"))
/// 3
fn strlen(string: String) -> isize {

    let length = string.chars().count() as isize;

    length
}

fn main() {
    let candidate = strlen;
    assert_eq!(candidate(String::from("")), 0);
    assert_eq!(candidate(String::from("x")), 1);
    assert_eq!(candidate(String::from("asdasnakj")), 9);
}

-----------------------------
/// Return length of given string
/// >>> strlen(String::from(""))
/// 0
/// >>> strlen(String::from("abc"))
/// 3
fn strlen(string: String) -> isize {

    string.len() as isize
}

fn main() {
    let candidate = strlen;
    assert_eq!(candidate(String::from("")), 0);
    assert_eq!(candidate(String::from("x")), 1);
    assert_eq!(candidate(String::from("asdasnakj")), 9);
}

-----------------------------
/// Return length of given string
/// >>> strlen(String::from(""))
/// 0
/// >>> strlen(String::from("abc"))
/// 3
fn strlen(string: String) -> isize {

    if string.is_empty() {
        0
    } else {
        string.chars().count() as isize
    }
}

fn main() {
    let candidate = strlen;
    assert_eq!(candidate(String::from("")), 0);
    assert_eq!(candidate(String::from("x")), 1);
    assert_eq!(candidate(String::from("asdasnakj")), 9);
}

-----------------------------
/// Return length of given string
/// >>> strlen(String::from(""))
/// 0
/// >>> strlen(String::from("abc"))
/// 3
fn strlen(string: String) -> isize {

    string.len() as isize
}

fn main() {
    let candidate = strlen;
    assert_eq!(candidate(String::from("")), 0);
    assert_eq!(candidate(String::from("x")), 1);
    assert_eq!(candidate(String::from("asdasnakj")), 9);
}

-----------------------------
/// Return length of given string
/// >>> strlen(String::from(""))
/// 0
/// >>> strlen(String::from("abc"))
/// 3
fn strlen(string: String) -> isize {

    string.len() as isize
}

fn main() {
    let candidate = strlen;
    assert_eq!(candidate(String::from("")), 0);
    assert_eq!(candidate(String::from("x")), 1);
    assert_eq!(candidate(String::from("asdasnakj")), 9);
}

===============================
/// For a given number n, find the largest number that divides n evenly, smaller than n
/// >>> largest_divisor(15)
/// 5
fn largest_divisor(n: isize) -> isize {

===============================
-----------------------------
/// For a given number n, find the largest number that divides n evenly, smaller than n
/// >>> largest_divisor(15)
/// 5
fn largest_divisor(n: isize) -> isize {

    let mut i = n / 2;
    while n % i != 0 {
        i -= 1;
    }
    i
}

fn main() {
    let candidate = largest_divisor;
    assert_eq!(candidate(3), 1);
    assert_eq!(candidate(7), 1);
    assert_eq!(candidate(10), 5);
    assert_eq!(candidate(100), 50);
    assert_eq!(candidate(49), 7);
}

-----------------------------
/// For a given number n, find the largest number that divides n evenly, smaller than n
/// >>> largest_divisor(15)
/// 5
fn largest_divisor(n: isize) -> isize {

    let mut divisor = 1;
    let mut counter = 1;
    while n % counter != 0 {
        divisor = counter;
        counter += 1;
    }
    divisor
}

fn main() {
    let candidate = largest_divisor;
    assert_eq!(candidate(3), 1);
    assert_eq!(candidate(7), 1);
    assert_eq!(candidate(10), 5);
    assert_eq!(candidate(100), 50);
    assert_eq!(candidate(49), 7);
}

-----------------------------
/// For a given number n, find the largest number that divides n evenly, smaller than n
/// >>> largest_divisor(15)
/// 5
fn largest_divisor(n: isize) -> isize {

    let mut i = n;
    while i > 1 {
        if n % i == 0 {
            return i;
        }
        i -= 1;
    }

    return 1;
}

fn main() {
    let candidate = largest_divisor;
    assert_eq!(candidate(3), 1);
    assert_eq!(candidate(7), 1);
    assert_eq!(candidate(10), 5);
    assert_eq!(candidate(100), 50);
    assert_eq!(candidate(49), 7);
}

-----------------------------
/// For a given number n, find the largest number that divides n evenly, smaller than n
/// >>> largest_divisor(15)
/// 5
fn largest_divisor(n: isize) -> isize {

    let mut i = n;
    let mut max = 1;
    while i > 1 {
        if i % max == 0 {
            i = i / max;
        } else {
            max += 1;
        }
    }
    max
}

fn main() {
    let candidate = largest_divisor;
    assert_eq!(candidate(3), 1);
    assert_eq!(candidate(7), 1);
    assert_eq!(candidate(10), 5);
    assert_eq!(candidate(100), 50);
    assert_eq!(candidate(49), 7);
}

-----------------------------
/// For a given number n, find the largest number that divides n evenly, smaller than n
/// >>> largest_divisor(15)
/// 5
fn largest_divisor(n: isize) -> isize {

    let mut divisor: isize = 0;
    let mut i: isize = n / 2;
    while i > 1 {
        if n % i == 0 {
            divisor = i;
        }
        i -= 1;
    }
    divisor
}

fn main() {
    let candidate = largest_divisor;
    assert_eq!(candidate(3), 1);
    assert_eq!(candidate(7), 1);
    assert_eq!(candidate(10), 5);
    assert_eq!(candidate(100), 50);
    assert_eq!(candidate(49), 7);
}

===============================
/// Return vector of prime factors of given integer in the order from smallest to largest.
/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.
/// Input number should be equal to the product of all factors
/// >>> factorize(8)
/// vec![2, 2, 2]
/// >>> factorize(25)
/// vec![5, 5]
/// >>> factorize(70)
/// vec![2, 5, 7]
fn factorize(n: isize) -> Vec<isize> {

===============================
-----------------------------
/// Return vector of prime factors of given integer in the order from smallest to largest.
/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.
/// Input number should be equal to the product of all factors
/// >>> factorize(8)
/// vec![2, 2, 2]
/// >>> factorize(25)
/// vec![5, 5]
/// >>> factorize(70)
/// vec![2, 5, 7]
fn factorize(n: isize) -> Vec<isize> {

    let mut result = vec![];

    for i in 2..n {
        if n % i == 0 {
            result.push(i);
            n /= i;
            i -= 1;
        }
    }
    result
}

fn main() {
    let candidate = factorize;
    assert_eq!(candidate(2), vec![2]);
    assert_eq!(candidate(4), vec![2, 2]);
    assert_eq!(candidate(8), vec![2, 2, 2]);
    assert_eq!(candidate(57), vec![3, 19]);
    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);
    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);
    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);
    assert_eq!(candidate(18), vec![2, 3, 3]);
}

-----------------------------
/// Return vector of prime factors of given integer in the order from smallest to largest.
/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.
/// Input number should be equal to the product of all factors
/// >>> factorize(8)
/// vec![2, 2, 2]
/// >>> factorize(25)
/// vec![5, 5]
/// >>> factorize(70)
/// vec![2, 5, 7]
fn factorize(n: isize) -> Vec<isize> {

    let mut n = n;
    let mut factors = Vec::new();
    while n % 2 == 0 {
        factors.push(2);
        n /= 2;
    }
    let mut i = 3;
    while i * i <= n {
        while n % i == 0 {
            factors.push(i);
            n /= i;
        }
        i += 2;
    }
    if n > 1 {
        factors.push(n);
    }
    factors
}

fn main() {
    let candidate = factorize;
    assert_eq!(candidate(2), vec![2]);
    assert_eq!(candidate(4), vec![2, 2]);
    assert_eq!(candidate(8), vec![2, 2, 2]);
    assert_eq!(candidate(57), vec![3, 19]);
    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);
    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);
    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);
    assert_eq!(candidate(18), vec![2, 3, 3]);
}

-----------------------------
/// Return vector of prime factors of given integer in the order from smallest to largest.
/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.
/// Input number should be equal to the product of all factors
/// >>> factorize(8)
/// vec![2, 2, 2]
/// >>> factorize(25)
/// vec![5, 5]
/// >>> factorize(70)
/// vec![2, 5, 7]
fn factorize(n: isize) -> Vec<isize> {

    let mut n = n;
    let mut factors = vec![];
    for factor in 2..=n {
        while n % factor == 0 {
            n /= factor;
            factors.push(factor);
        }
    }
    if n != 1 {
        factors.push(n);
    }
    factors
}

fn main() {
    let candidate = factorize;
    assert_eq!(candidate(2), vec![2]);
    assert_eq!(candidate(4), vec![2, 2]);
    assert_eq!(candidate(8), vec![2, 2, 2]);
    assert_eq!(candidate(57), vec![3, 19]);
    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);
    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);
    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);
    assert_eq!(candidate(18), vec![2, 3, 3]);
}

-----------------------------
/// Return vector of prime factors of given integer in the order from smallest to largest.
/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.
/// Input number should be equal to the product of all factors
/// >>> factorize(8)
/// vec![2, 2, 2]
/// >>> factorize(25)
/// vec![5, 5]
/// >>> factorize(70)
/// vec![2, 5, 7]
fn factorize(n: isize) -> Vec<isize> {

    let mut factors = Vec::new();
    let mut n = n;
    loop {
        let mut x = 2;
        loop {
            if n % x == 0 {
                factors.push(x);
                n = n / x;
                break;
            }
            x += 1;
        }
        if n == 1 {
            break;
        }
    }
    factors
}

fn main() {
    let candidate = factorize;
    assert_eq!(candidate(2), vec![2]);
    assert_eq!(candidate(4), vec![2, 2]);
    assert_eq!(candidate(8), vec![2, 2, 2]);
    assert_eq!(candidate(57), vec![3, 19]);
    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);
    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);
    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);
    assert_eq!(candidate(18), vec![2, 3, 3]);
}

-----------------------------
/// Return vector of prime factors of given integer in the order from smallest to largest.
/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.
/// Input number should be equal to the product of all factors
/// >>> factorize(8)
/// vec![2, 2, 2]
/// >>> factorize(25)
/// vec![5, 5]
/// >>> factorize(70)
/// vec![2, 5, 7]
fn factorize(n: isize) -> Vec<isize> {

    let mut i: isize = 2;
    let mut factors: Vec<isize> = Vec::new();
    let mut n: isize = n;

    while n > 1 {
        while n % i == 0 {
            factors.push(i);
            n = n / i;
        }

        i += 1;
    }

    factors
}

fn main() {
    let candidate = factorize;
    assert_eq!(candidate(2), vec![2]);
    assert_eq!(candidate(4), vec![2, 2]);
    assert_eq!(candidate(8), vec![2, 2, 2]);
    assert_eq!(candidate(57), vec![3, 19]);
    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);
    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);
    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);
    assert_eq!(candidate(18), vec![2, 3, 3]);
}

===============================
/// From a vector of integers, remove all elements that occur more than once.
/// Keep order of elements left the same as in the input.
/// >>> remove_duplicates(vec![1, 2, 3, 2, 4])
/// vec![1, 3, 4]
fn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {

===============================
-----------------------------
/// From a vector of integers, remove all elements that occur more than once.
/// Keep order of elements left the same as in the input.
/// >>> remove_duplicates(vec![1, 2, 3, 2, 4])
/// vec![1, 3, 4]
fn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {

    let mut result = Vec::new();
    let mut seen = HashSet::new();
    for number in numbers.iter() {
        if !seen.contains(number) {
            seen.insert(number);
            result.push(*number);
        }
    }

    result
}

fn main() {
    let candidate = remove_duplicates;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);
    assert_eq!(candidate(vec![1, 2, 3, 2, 4, 3, 5]), vec![1, 4, 5]);
}

-----------------------------
/// From a vector of integers, remove all elements that occur more than once.
/// Keep order of elements left the same as in the input.
/// >>> remove_duplicates(vec![1, 2, 3, 2, 4])
/// vec![1, 3, 4]
fn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {

    let mut set = HashSet::new();
    for number in numbers {
        if !set.contains(&number) {
            set.insert(number);
        }
    }
    set.into_iter().collect()
}

fn main() {
    let candidate = remove_duplicates;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);
    assert_eq!(candidate(vec![1, 2, 3, 2, 4, 3, 5]), vec![1, 4, 5]);
}

-----------------------------
/// From a vector of integers, remove all elements that occur more than once.
/// Keep order of elements left the same as in the input.
/// >>> remove_duplicates(vec![1, 2, 3, 2, 4])
/// vec![1, 3, 4]
fn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {

    let mut map = std::collections::HashMap::new();

    numbers.iter().map(|&x| {
        *map.entry(x).or_insert(0) += 1;
        if map.get(&x).unwrap() == &1 {
            x
        } else {
            -1
        }
    }).filter(|&x| x != -1).collect()
}

fn main() {
    let candidate = remove_duplicates;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);
    assert_eq!(candidate(vec![1, 2, 3, 2, 4, 3, 5]), vec![1, 4, 5]);
}

-----------------------------
/// From a vector of integers, remove all elements that occur more than once.
/// Keep order of elements left the same as in the input.
/// >>> remove_duplicates(vec![1, 2, 3, 2, 4])
/// vec![1, 3, 4]
fn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {

    let mut seen: HashSet<isize> = HashSet::new();
    let mut result: Vec<isize> = Vec::new();

    for num in numbers {
        if seen.contains(&num) {
            continue;
        }
        seen.insert(num);
        result.push(num);
    }

    result
}

fn main() {
    let candidate = remove_duplicates;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);
    assert_eq!(candidate(vec![1, 2, 3, 2, 4, 3, 5]), vec![1, 4, 5]);
}

-----------------------------
/// From a vector of integers, remove all elements that occur more than once.
/// Keep order of elements left the same as in the input.
/// >>> remove_duplicates(vec![1, 2, 3, 2, 4])
/// vec![1, 3, 4]
fn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {

    let mut set = std::collections::HashSet::new();

    for number in numbers {
        if set.contains(&number) {
            continue;
        }
        set.insert(number);
    }

    set.into_iter().collect()
}

fn main() {
    let candidate = remove_duplicates;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);
    assert_eq!(candidate(vec![1, 2, 3, 2, 4, 3, 5]), vec![1, 4, 5]);
}

===============================
/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(String::from("Hello"))
/// String::from("hELLO")
fn flip_case(string: String) -> String {

===============================
-----------------------------
/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(String::from("Hello"))
/// String::from("hELLO")
fn flip_case(string: String) -> String {

    let mut chars = string.chars();
    let mut new_string = String::new();
    loop {
        match chars.next() {
            Some(c) => {
                if c.is_lowercase() {
                    new_string.push(c.to_uppercase().next().unwrap());
                } else {
                    new_string.push(c.to_lowercase().next().unwrap());
                }
            },
            None => break
        }
    }
    new_string
}

fn main() {
    let candidate = flip_case;
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("Hello!")), String::from("hELLO!"));
    assert_eq!(candidate(String::from("These violent delights have violent ends")), String::from("tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"));
}

-----------------------------
/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(String::from("Hello"))
/// String::from("hELLO")
fn flip_case(string: String) -> String {

    let mut new = String::new();
    for char in string.chars() {
        match char {
            'a'..='z' => new.push(char.to_ascii_uppercase()),
            'A'..='Z' => new.push(char.to_ascii_lowercase()),
            _ => new.push(char)
        }
    }
    new
}

fn main() {
    let candidate = flip_case;
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("Hello!")), String::from("hELLO!"));
    assert_eq!(candidate(String::from("These violent delights have violent ends")), String::from("tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"));
}

-----------------------------
/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(String::from("Hello"))
/// String::from("hELLO")
fn flip_case(string: String) -> String {

    string.chars().map(|c| {
        if c.is_ascii_uppercase() {
            c.to_ascii_lowercase()
        } else {
            c.to_ascii_uppercase()
        }
    }).collect::<String>()
}

fn main() {
    let candidate = flip_case;
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("Hello!")), String::from("hELLO!"));
    assert_eq!(candidate(String::from("These violent delights have violent ends")), String::from("tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"));
}

-----------------------------
/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(String::from("Hello"))
/// String::from("hELLO")
fn flip_case(string: String) -> String {

    let mut output = String::new();
    for c in string.chars() {
        match c {
            'a'...'z' => output.push(c.to_uppercase().next().unwrap()),
            'A'...'Z' => output.push(c.to_lowercase().next().unwrap()),
            _ => output.push(c)
        }
    }
    output
}

fn main() {
    let candidate = flip_case;
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("Hello!")), String::from("hELLO!"));
    assert_eq!(candidate(String::from("These violent delights have violent ends")), String::from("tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"));
}

-----------------------------
/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(String::from("Hello"))
/// String::from("hELLO")
fn flip_case(string: String) -> String {

    let mut result = String::new();
    for c in string.chars() {
        if c.is_uppercase() {
            result.push_str(&c.to_lowercase().collect::<String>());
        } else if c.is_lowercase() {
            result.push_str(&c.to_uppercase().collect::<String>());
        } else {
            result.push(c);
        }
    }
    result
}

fn main() {
    let candidate = flip_case;
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("Hello!")), String::from("hELLO!"));
    assert_eq!(candidate(String::from("These violent delights have violent ends")), String::from("tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"));
}

===============================
/// Concatenate vector of strings into a single string
/// >>> concatenate(vec![])
/// String::from("")
/// >>> concatenate(vec![String::from("a"), String::from("b"), String::from("c")])
/// String::from("abc")
fn concatenate(strings: Vec<String>) -> String {

===============================
-----------------------------
/// Concatenate vector of strings into a single string
/// >>> concatenate(vec![])
/// String::from("")
/// >>> concatenate(vec![String::from("a"), String::from("b"), String::from("c")])
/// String::from("abc")
fn concatenate(strings: Vec<String>) -> String {

    let mut concat = String::new();
    for string in strings {
        concat.push_str(&string);
    }
    concat
}

fn main() {
    let candidate = concatenate;
    assert_eq!(candidate(Vec::<String>::new()), String::from(""));
    assert_eq!(candidate(vec![String::from("x"), String::from("y"), String::from("z")]), String::from("xyz"));
    assert_eq!(candidate(vec![String::from("x"), String::from("y"), String::from("z"), String::from("w"), String::from("k")]), String::from("xyzwk"));
}

-----------------------------
/// Concatenate vector of strings into a single string
/// >>> concatenate(vec![])
/// String::from("")
/// >>> concatenate(vec![String::from("a"), String::from("b"), String::from("c")])
/// String::from("abc")
fn concatenate(strings: Vec<String>) -> String {

    let mut result = String::new();
    for string in strings {
        result.push_str(&string);
    }
    result
}

fn main() {
    let candidate = concatenate;
    assert_eq!(candidate(Vec::<String>::new()), String::from(""));
    assert_eq!(candidate(vec![String::from("x"), String::from("y"), String::from("z")]), String::from("xyz"));
    assert_eq!(candidate(vec![String::from("x"), String::from("y"), String::from("z"), String::from("w"), String::from("k")]), String::from("xyzwk"));
}

-----------------------------
/// Concatenate vector of strings into a single string
/// >>> concatenate(vec![])
/// String::from("")
/// >>> concatenate(vec![String::from("a"), String::from("b"), String::from("c")])
/// String::from("abc")
fn concatenate(strings: Vec<String>) -> String {

    let mut concatenated_string = String::from("");

    for string in strings {
        concatenated_string.push_str(&string);
    }

    return concatenated_string;
}

fn main() {
    let candidate = concatenate;
    assert_eq!(candidate(Vec::<String>::new()), String::from(""));
    assert_eq!(candidate(vec![String::from("x"), String::from("y"), String::from("z")]), String::from("xyz"));
    assert_eq!(candidate(vec![String::from("x"), String::from("y"), String::from("z"), String::from("w"), String::from("k")]), String::from("xyzwk"));
}

-----------------------------
/// Concatenate vector of strings into a single string
/// >>> concatenate(vec![])
/// String::from("")
/// >>> concatenate(vec![String::from("a"), String::from("b"), String::from("c")])
/// String::from("abc")
fn concatenate(strings: Vec<String>) -> String {

    strings.join("")
}

fn main() {
    let candidate = concatenate;
    assert_eq!(candidate(Vec::<String>::new()), String::from(""));
    assert_eq!(candidate(vec![String::from("x"), String::from("y"), String::from("z")]), String::from("xyz"));
    assert_eq!(candidate(vec![String::from("x"), String::from("y"), String::from("z"), String::from("w"), String::from("k")]), String::from("xyzwk"));
}

-----------------------------
/// Concatenate vector of strings into a single string
/// >>> concatenate(vec![])
/// String::from("")
/// >>> concatenate(vec![String::from("a"), String::from("b"), String::from("c")])
/// String::from("abc")
fn concatenate(strings: Vec<String>) -> String {

    strings.join("")
}

fn main() {
    let candidate = concatenate;
    assert_eq!(candidate(Vec::<String>::new()), String::from(""));
    assert_eq!(candidate(vec![String::from("x"), String::from("y"), String::from("z")]), String::from("xyz"));
    assert_eq!(candidate(vec![String::from("x"), String::from("y"), String::from("z"), String::from("w"), String::from("k")]), String::from("xyzwk"));
}

===============================
/// Filter an input vector of strings only for ones that start with a given prefix.
/// >>> filter_by_prefix(vec![], String::from("a"))
/// Vec::<String>::new()
/// >>> filter_by_prefix(vec![String::from("abc"), String::from("bcd"), String::from("cde"), String::from("array")], String::from("a"))
/// vec![String::from("abc"), String::from("array")]
fn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {

===============================
-----------------------------
/// Filter an input vector of strings only for ones that start with a given prefix.
/// >>> filter_by_prefix(vec![], String::from("a"))
/// Vec::<String>::new()
/// >>> filter_by_prefix(vec![String::from("abc"), String::from("bcd"), String::from("cde"), String::from("array")], String::from("a"))
/// vec![String::from("abc"), String::from("array")]
fn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {

    let mut filtered_vec: Vec<String> = Vec::new();

    for elem in strings.iter() {
        if elem.starts_with(&prefix) {
            filtered_vec.push(elem.clone());
        }
    }

    filtered_vec
}

fn main() {
    let candidate = filter_by_prefix;
    assert_eq!(candidate(Vec::<String>::new(), String::from("john")), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("xxx"), String::from("asd"), String::from("xxy"), String::from("john doe"), String::from("xxxAAA"), String::from("xxx")], String::from("xxx")), vec![String::from("xxx"), String::from("xxxAAA"), String::from("xxx")]);
}

-----------------------------
/// Filter an input vector of strings only for ones that start with a given prefix.
/// >>> filter_by_prefix(vec![], String::from("a"))
/// Vec::<String>::new()
/// >>> filter_by_prefix(vec![String::from("abc"), String::from("bcd"), String::from("cde"), String::from("array")], String::from("a"))
/// vec![String::from("abc"), String::from("array")]
fn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {

    let mut new_strings = vec![];
    for s in strings {
        if s.starts_with(&prefix) {
            new_strings.push(s)
        }
    }
    new_strings
}

fn main() {
    let candidate = filter_by_prefix;
    assert_eq!(candidate(Vec::<String>::new(), String::from("john")), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("xxx"), String::from("asd"), String::from("xxy"), String::from("john doe"), String::from("xxxAAA"), String::from("xxx")], String::from("xxx")), vec![String::from("xxx"), String::from("xxxAAA"), String::from("xxx")]);
}

-----------------------------
/// Filter an input vector of strings only for ones that start with a given prefix.
/// >>> filter_by_prefix(vec![], String::from("a"))
/// Vec::<String>::new()
/// >>> filter_by_prefix(vec![String::from("abc"), String::from("bcd"), String::from("cde"), String::from("array")], String::from("a"))
/// vec![String::from("abc"), String::from("array")]
fn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {

    strings.into_iter().filter(|string| string.starts_with(&prefix)).collect()
}

fn main() {
    let candidate = filter_by_prefix;
    assert_eq!(candidate(Vec::<String>::new(), String::from("john")), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("xxx"), String::from("asd"), String::from("xxy"), String::from("john doe"), String::from("xxxAAA"), String::from("xxx")], String::from("xxx")), vec![String::from("xxx"), String::from("xxxAAA"), String::from("xxx")]);
}

-----------------------------
/// Filter an input vector of strings only for ones that start with a given prefix.
/// >>> filter_by_prefix(vec![], String::from("a"))
/// Vec::<String>::new()
/// >>> filter_by_prefix(vec![String::from("abc"), String::from("bcd"), String::from("cde"), String::from("array")], String::from("a"))
/// vec![String::from("abc"), String::from("array")]
fn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {

    strings
        .into_iter()
        .filter(|x| x.starts_with(&prefix))
        .collect::<Vec<String>>()
}

fn main() {
    let candidate = filter_by_prefix;
    assert_eq!(candidate(Vec::<String>::new(), String::from("john")), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("xxx"), String::from("asd"), String::from("xxy"), String::from("john doe"), String::from("xxxAAA"), String::from("xxx")], String::from("xxx")), vec![String::from("xxx"), String::from("xxxAAA"), String::from("xxx")]);
}

-----------------------------
/// Filter an input vector of strings only for ones that start with a given prefix.
/// >>> filter_by_prefix(vec![], String::from("a"))
/// Vec::<String>::new()
/// >>> filter_by_prefix(vec![String::from("abc"), String::from("bcd"), String::from("cde"), String::from("array")], String::from("a"))
/// vec![String::from("abc"), String::from("array")]
fn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {

    let mut output: Vec<String> = Vec::new();
    for string in strings {
        if string.starts_with(&prefix) {
            output.push(string);
        }
    }
    output
}

fn main() {
    let candidate = filter_by_prefix;
    assert_eq!(candidate(Vec::<String>::new(), String::from("john")), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("xxx"), String::from("asd"), String::from("xxy"), String::from("john doe"), String::from("xxxAAA"), String::from("xxx")], String::from("xxx")), vec![String::from("xxx"), String::from("xxxAAA"), String::from("xxx")]);
}

===============================
/// Return only positive numbers in the vector.
/// >>> get_positive(vec![-1, 2, -4, 5, 6])
/// vec![2, 5, 6]
/// >>> get_positive(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// vec![5, 3, 2, 3, 9, 123, 1]
fn get_positive(l: Vec<isize>) -> Vec<isize> {

===============================
-----------------------------
/// Return only positive numbers in the vector.
/// >>> get_positive(vec![-1, 2, -4, 5, 6])
/// vec![2, 5, 6]
/// >>> get_positive(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// vec![5, 3, 2, 3, 9, 123, 1]
fn get_positive(l: Vec<isize>) -> Vec<isize> {

    let mut positive = Vec::new();

    for i in l {
        if i > 0 {
            positive.push(i);
        }
    }

    positive
}

fn main() {
    let candidate = get_positive;
    assert_eq!(candidate(vec![-1, -2, 4, 5, 6]), vec![4, 5, 6]);
    assert_eq!(candidate(vec![5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]), vec![5, 3, 2, 3, 3, 9, 123, 1]);
    assert_eq!(candidate(vec![-1, -2]), Vec::<isize>::new());
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
}

-----------------------------
/// Return only positive numbers in the vector.
/// >>> get_positive(vec![-1, 2, -4, 5, 6])
/// vec![2, 5, 6]
/// >>> get_positive(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// vec![5, 3, 2, 3, 9, 123, 1]
fn get_positive(l: Vec<isize>) -> Vec<isize> {

    l.into_iter()
        .filter(|&x| x > 0)
        .collect::<Vec<isize>>()
}

fn main() {
    let candidate = get_positive;
    assert_eq!(candidate(vec![-1, -2, 4, 5, 6]), vec![4, 5, 6]);
    assert_eq!(candidate(vec![5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]), vec![5, 3, 2, 3, 3, 9, 123, 1]);
    assert_eq!(candidate(vec![-1, -2]), Vec::<isize>::new());
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
}

-----------------------------
/// Return only positive numbers in the vector.
/// >>> get_positive(vec![-1, 2, -4, 5, 6])
/// vec![2, 5, 6]
/// >>> get_positive(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// vec![5, 3, 2, 3, 9, 123, 1]
fn get_positive(l: Vec<isize>) -> Vec<isize> {

    let mut ans: Vec<isize> = Vec::new();
    for i in l {
        if i > 0 {
            ans.push(i);
        }
    }
    ans
}

fn main() {
    let candidate = get_positive;
    assert_eq!(candidate(vec![-1, -2, 4, 5, 6]), vec![4, 5, 6]);
    assert_eq!(candidate(vec![5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]), vec![5, 3, 2, 3, 3, 9, 123, 1]);
    assert_eq!(candidate(vec![-1, -2]), Vec::<isize>::new());
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
}

-----------------------------
/// Return only positive numbers in the vector.
/// >>> get_positive(vec![-1, 2, -4, 5, 6])
/// vec![2, 5, 6]
/// >>> get_positive(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// vec![5, 3, 2, 3, 9, 123, 1]
fn get_positive(l: Vec<isize>) -> Vec<isize> {

    l.iter()
        .filter(|&x| *x > 0)
        .cloned()
        .collect::<Vec<isize>>()
}

fn main() {
    let candidate = get_positive;
    assert_eq!(candidate(vec![-1, -2, 4, 5, 6]), vec![4, 5, 6]);
    assert_eq!(candidate(vec![5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]), vec![5, 3, 2, 3, 3, 9, 123, 1]);
    assert_eq!(candidate(vec![-1, -2]), Vec::<isize>::new());
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
}

-----------------------------
/// Return only positive numbers in the vector.
/// >>> get_positive(vec![-1, 2, -4, 5, 6])
/// vec![2, 5, 6]
/// >>> get_positive(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// vec![5, 3, 2, 3, 9, 123, 1]
fn get_positive(l: Vec<isize>) -> Vec<isize> {

    let mut new_list = Vec::<isize>::new();
    for i in l {
        if i > 0 {
            new_list.push(i);
        }
    }
    new_list
}

fn main() {
    let candidate = get_positive;
    assert_eq!(candidate(vec![-1, -2, 4, 5, 6]), vec![4, 5, 6]);
    assert_eq!(candidate(vec![5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]), vec![5, 3, 2, 3, 3, 9, 123, 1]);
    assert_eq!(candidate(vec![-1, -2]), Vec::<isize>::new());
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
}

===============================
/// Return true if a given number is prime, and false otherwise.
/// >>> is_prime(6)
/// false
/// >>> is_prime(101)
/// true
/// >>> is_prime(11)
/// true
/// >>> is_prime(13441)
/// true
/// >>> is_prime(61)
/// true
/// >>> is_prime(4)
/// false
/// >>> is_prime(1)
/// false
fn is_prime(n: isize) -> bool {

===============================
-----------------------------
/// Return true if a given number is prime, and false otherwise.
/// >>> is_prime(6)
/// false
/// >>> is_prime(101)
/// true
/// >>> is_prime(11)
/// true
/// >>> is_prime(13441)
/// true
/// >>> is_prime(61)
/// true
/// >>> is_prime(4)
/// false
/// >>> is_prime(1)
/// false
fn is_prime(n: isize) -> bool {

    if n < 2 {
        return false;
    }
    for i in 2..n {
        if n % i == 0 {
            return false;
        }
    }
    return true;
}

fn main() {
    let candidate = is_prime;
    assert_eq!(candidate(6), false);
    assert_eq!(candidate(101), true);
    assert_eq!(candidate(11), true);
    assert_eq!(candidate(13441), true);
    assert_eq!(candidate(61), true);
    assert_eq!(candidate(4), false);
    assert_eq!(candidate(1), false);
    assert_eq!(candidate(5), true);
    assert_eq!(candidate(11), true);
    assert_eq!(candidate(17), true);
    assert_eq!(candidate(85), false);
    assert_eq!(candidate(77), false);
    assert_eq!(candidate(255379), false);
}

-----------------------------
/// Return true if a given number is prime, and false otherwise.
/// >>> is_prime(6)
/// false
/// >>> is_prime(101)
/// true
/// >>> is_prime(11)
/// true
/// >>> is_prime(13441)
/// true
/// >>> is_prime(61)
/// true
/// >>> is_prime(4)
/// false
/// >>> is_prime(1)
/// false
fn is_prime(n: isize) -> bool {

    if n == 2 {
        return true;
    }

    if n % 2 == 0 {
        return false;
    }

    let root = n as f64;
    let sqrt = root.sqrt();
    let max = sqrt as isize;

    for i in 3..=max {
        if n % i == 0 {
            return false;
        }
    }

    return true;
}

fn main() {
    let candidate = is_prime;
    assert_eq!(candidate(6), false);
    assert_eq!(candidate(101), true);
    assert_eq!(candidate(11), true);
    assert_eq!(candidate(13441), true);
    assert_eq!(candidate(61), true);
    assert_eq!(candidate(4), false);
    assert_eq!(candidate(1), false);
    assert_eq!(candidate(5), true);
    assert_eq!(candidate(11), true);
    assert_eq!(candidate(17), true);
    assert_eq!(candidate(85), false);
    assert_eq!(candidate(77), false);
    assert_eq!(candidate(255379), false);
}

-----------------------------
/// Return true if a given number is prime, and false otherwise.
/// >>> is_prime(6)
/// false
/// >>> is_prime(101)
/// true
/// >>> is_prime(11)
/// true
/// >>> is_prime(13441)
/// true
/// >>> is_prime(61)
/// true
/// >>> is_prime(4)
/// false
/// >>> is_prime(1)
/// false
fn is_prime(n: isize) -> bool {

    if n == 2 || n == 3 {
        return true;
    }
    if n < 2 || n % 2 == 0 {
        return false;
    }

    let mut i = 3;
    while (i as f64).sqrt() <= n as f64 {
        if n % i == 0 {
            return false;
        }
        i += 2;
    }

    true
}

fn main() {
    let candidate = is_prime;
    assert_eq!(candidate(6), false);
    assert_eq!(candidate(101), true);
    assert_eq!(candidate(11), true);
    assert_eq!(candidate(13441), true);
    assert_eq!(candidate(61), true);
    assert_eq!(candidate(4), false);
    assert_eq!(candidate(1), false);
    assert_eq!(candidate(5), true);
    assert_eq!(candidate(11), true);
    assert_eq!(candidate(17), true);
    assert_eq!(candidate(85), false);
    assert_eq!(candidate(77), false);
    assert_eq!(candidate(255379), false);
}

-----------------------------
/// Return true if a given number is prime, and false otherwise.
/// >>> is_prime(6)
/// false
/// >>> is_prime(101)
/// true
/// >>> is_prime(11)
/// true
/// >>> is_prime(13441)
/// true
/// >>> is_prime(61)
/// true
/// >>> is_prime(4)
/// false
/// >>> is_prime(1)
/// false
fn is_prime(n: isize) -> bool {

    if n < 2 {
        return false;
    }

    let mut divisor = 2;
    while n % divisor != 0 {
        divisor += 1;
    }

    divisor == n
}

fn main() {
    let candidate = is_prime;
    assert_eq!(candidate(6), false);
    assert_eq!(candidate(101), true);
    assert_eq!(candidate(11), true);
    assert_eq!(candidate(13441), true);
    assert_eq!(candidate(61), true);
    assert_eq!(candidate(4), false);
    assert_eq!(candidate(1), false);
    assert_eq!(candidate(5), true);
    assert_eq!(candidate(11), true);
    assert_eq!(candidate(17), true);
    assert_eq!(candidate(85), false);
    assert_eq!(candidate(77), false);
    assert_eq!(candidate(255379), false);
}

-----------------------------
/// Return true if a given number is prime, and false otherwise.
/// >>> is_prime(6)
/// false
/// >>> is_prime(101)
/// true
/// >>> is_prime(11)
/// true
/// >>> is_prime(13441)
/// true
/// >>> is_prime(61)
/// true
/// >>> is_prime(4)
/// false
/// >>> is_prime(1)
/// false
fn is_prime(n: isize) -> bool {

    for i in 2..n {
        if n % i == 0 {
            return false;
        }
    }
    true
}

fn main() {
    let candidate = is_prime;
    assert_eq!(candidate(6), false);
    assert_eq!(candidate(101), true);
    assert_eq!(candidate(11), true);
    assert_eq!(candidate(13441), true);
    assert_eq!(candidate(61), true);
    assert_eq!(candidate(4), false);
    assert_eq!(candidate(1), false);
    assert_eq!(candidate(5), true);
    assert_eq!(candidate(11), true);
    assert_eq!(candidate(17), true);
    assert_eq!(candidate(85), false);
    assert_eq!(candidate(77), false);
    assert_eq!(candidate(255379), false);
}

===============================
/// This function takes a vector l and returns a vector l' such that
/// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal
/// to the values of the corresponding indicies of l, but sorted.
/// >>> sort_third(vec![1, 2, 3])
/// vec![1, 2, 3]
/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])
/// vec![2, 6, 3, 4, 8, 9, 5]
fn sort_third(l: Vec<isize>) -> Vec<isize> {

===============================
-----------------------------
/// This function takes a vector l and returns a vector l' such that
/// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal
/// to the values of the corresponding indicies of l, but sorted.
/// >>> sort_third(vec![1, 2, 3])
/// vec![1, 2, 3]
/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])
/// vec![2, 6, 3, 4, 8, 9, 5]
fn sort_third(l: Vec<isize>) -> Vec<isize> {

    let mut new_vec = vec![0; l.len()];

    for i in 0..l.len() {
        if i % 3 == 0 {
            new_vec[i] = l[i];
        }
    }

    new_vec.sort();

    let mut j = 0;
    for i in 0..l.len() {
        if i % 3 == 0 {
            l[i] = new_vec[j];
            j += 1;
        }
    }

    return l;
}

fn main() {
    let candidate = sort_third;
    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);
    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);
    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);
    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);
}

-----------------------------
/// This function takes a vector l and returns a vector l' such that
/// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal
/// to the values of the corresponding indicies of l, but sorted.
/// >>> sort_third(vec![1, 2, 3])
/// vec![1, 2, 3]
/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])
/// vec![2, 6, 3, 4, 8, 9, 5]
fn sort_third(l: Vec<isize>) -> Vec<isize> {

    let mut l_clone = l.clone();

    let mut i = 0;
    while i < l_clone.len() {
        if i % 3 == 0 {
            let mut j = i + 1;
            while j < l_clone.len() {
                if j % 3 == 0 {
                    l_clone[i] = l_clone[i].max(l_clone[j]);
                    l_clone[j] = l_clone[i].min(l_clone[j]);
                    l_clone[i] = l_clone[i].min(l_clone[j]);
                }
                j += 1;
            }
        }
        i += 1;
    }

    return l_clone;
}

fn main() {
    let candidate = sort_third;
    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);
    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);
    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);
    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);
}

-----------------------------
/// This function takes a vector l and returns a vector l' such that
/// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal
/// to the values of the corresponding indicies of l, but sorted.
/// >>> sort_third(vec![1, 2, 3])
/// vec![1, 2, 3]
/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])
/// vec![2, 6, 3, 4, 8, 9, 5]
fn sort_third(l: Vec<isize>) -> Vec<isize> {

    let mut r = vec![0; l.len()];
    for (index, i) in l.iter().enumerate() {
        r[(index * 3) % l.len()] = *i;
    }
    r.sort();
    r
}

fn main() {
    let candidate = sort_third;
    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);
    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);
    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);
    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);
}

-----------------------------
/// This function takes a vector l and returns a vector l' such that
/// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal
/// to the values of the corresponding indicies of l, but sorted.
/// >>> sort_third(vec![1, 2, 3])
/// vec![1, 2, 3]
/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])
/// vec![2, 6, 3, 4, 8, 9, 5]
fn sort_third(l: Vec<isize>) -> Vec<isize> {

    let mut l: Vec<isize> = l;
    let mut i = 0;
    while i < l.len() - 3 {
        let mut j = i + 1;
        while j < l.len() - 2 {
            if l[i] % 3 == l[j] % 3 || l[i] % 3 == l[j + 1] % 3 {
                if l[i] > l[j] {
                    l.swap(i, j);
                }
                if l[i] > l[j + 1] {
                    l.swap(i, j + 1);
                }
                j += 2;
            } else {
                j += 1;
            }
        }
        if l[i] > l[l.len() - 1] {
            l.swap(i, l.len() - 1);
        }
        i += 1;
    }
    l
}

fn main() {
    let candidate = sort_third;
    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);
    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);
    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);
    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);
}

-----------------------------
/// This function takes a vector l and returns a vector l' such that
/// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal
/// to the values of the corresponding indicies of l, but sorted.
/// >>> sort_third(vec![1, 2, 3])
/// vec![1, 2, 3]
/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])
/// vec![2, 6, 3, 4, 8, 9, 5]
fn sort_third(l: Vec<isize>) -> Vec<isize> {

    let mut l_prime = l;
    for i in (0..l.len()).step_by(3) {
        l_prime[i] = l[i];
    }
    l_prime.sort_by_key(|&k| k);
    let mut index = 2;
    let mut l_prime_prime = vec![];
    while index < l_prime.len() {
        l_prime_prime.push(l_prime[index]);
        index += 3;
    }
    l_prime_prime
}

fn main() {
    let candidate = sort_third;
    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);
    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);
    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);
    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);
}

===============================
/// Return sorted unique elements in a vector
/// >>> unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])
/// vec![0, 2, 3, 5, 9, 123]
fn unique(l: Vec<isize>) -> Vec<isize> {

===============================
-----------------------------
/// Return sorted unique elements in a vector
/// >>> unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])
/// vec![0, 2, 3, 5, 9, 123]
fn unique(l: Vec<isize>) -> Vec<isize> {

    l.iter()
        .unique()
        .cloned()
        .collect::<Vec<isize>>()
        .iter()
        .sorted()
        .cloned()
        .collect()
}

fn main() {
    let candidate = unique;
    assert_eq!(candidate(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]), vec![0, 2, 3, 5, 9, 123]);
}

-----------------------------
/// Return sorted unique elements in a vector
/// >>> unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])
/// vec![0, 2, 3, 5, 9, 123]
fn unique(l: Vec<isize>) -> Vec<isize> {

    let mut res: Vec<isize> = Vec::new();
    for i in 0..l.len() {
        if i == 0 {
            res.push(l[i]);
            continue;
        }
        if l[i] != res.last().unwrap() {
            res.push(l[i]);
        }
    }
    res
}

fn main() {
    let candidate = unique;
    assert_eq!(candidate(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]), vec![0, 2, 3, 5, 9, 123]);
}

-----------------------------
/// Return sorted unique elements in a vector
/// >>> unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])
/// vec![0, 2, 3, 5, 9, 123]
fn unique(l: Vec<isize>) -> Vec<isize> {

    l.sort();
    l.dedup();
    l
}

fn main() {
    let candidate = unique;
    assert_eq!(candidate(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]), vec![0, 2, 3, 5, 9, 123]);
}

-----------------------------
/// Return sorted unique elements in a vector
/// >>> unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])
/// vec![0, 2, 3, 5, 9, 123]
fn unique(l: Vec<isize>) -> Vec<isize> {

    let mut set = HashSet::<isize>::new();
    for v in l {
        set.insert(v);
    }
    return set.into_iter().collect();
}

fn main() {
    let candidate = unique;
    assert_eq!(candidate(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]), vec![0, 2, 3, 5, 9, 123]);
}

-----------------------------
/// Return sorted unique elements in a vector
/// >>> unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])
/// vec![0, 2, 3, 5, 9, 123]
fn unique(l: Vec<isize>) -> Vec<isize> {

    l.into_iter()
        .unique()
        .sorted()
        .collect::<Vec<_>>()
}

fn main() {
    let candidate = unique;
    assert_eq!(candidate(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]), vec![0, 2, 3, 5, 9, 123]);
}

===============================
/// Return maximum element in the vector.
/// >>> max_element(vec![1, 2, 3])
/// 3
/// >>> max_element(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// 123
fn max_element(l: Vec<isize>) -> isize {

===============================
-----------------------------
/// Return maximum element in the vector.
/// >>> max_element(vec![1, 2, 3])
/// 3
/// >>> max_element(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// 123
fn max_element(l: Vec<isize>) -> isize {

    let mut result = l[0];
    for i in 0..l.len() {
        if l[i] > result {
            result = l[i];
        }
    }
    result
}

fn main() {
    let candidate = max_element;
    assert_eq!(candidate(vec![1, 2, 3]), 3);
    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]), 124);
}

-----------------------------
/// Return maximum element in the vector.
/// >>> max_element(vec![1, 2, 3])
/// 3
/// >>> max_element(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// 123
fn max_element(l: Vec<isize>) -> isize {

    let mut max = l[0];
    for i in 1..l.len() {
        if l[i] > max {
            max = l[i];
        }
    }
    max
}

fn main() {
    let candidate = max_element;
    assert_eq!(candidate(vec![1, 2, 3]), 3);
    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]), 124);
}

-----------------------------
/// Return maximum element in the vector.
/// >>> max_element(vec![1, 2, 3])
/// 3
/// >>> max_element(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// 123
fn max_element(l: Vec<isize>) -> isize {

    // Write your code here
    let mut m = l[0];
    for i in l {
        if m < i {
            m = i;
        }
    }
    m
}

fn main() {
    let candidate = max_element;
    assert_eq!(candidate(vec![1, 2, 3]), 3);
    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]), 124);
}

-----------------------------
/// Return maximum element in the vector.
/// >>> max_element(vec![1, 2, 3])
/// 3
/// >>> max_element(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// 123
fn max_element(l: Vec<isize>) -> isize {

    l.iter().max().unwrap().clone()
}

fn main() {
    let candidate = max_element;
    assert_eq!(candidate(vec![1, 2, 3]), 3);
    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]), 124);
}

-----------------------------
/// Return maximum element in the vector.
/// >>> max_element(vec![1, 2, 3])
/// 3
/// >>> max_element(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// 123
fn max_element(l: Vec<isize>) -> isize {

    let mut max = l[0];
    for &x in l.iter() {
        if x > max {
            max = x;
        }
    }
    max
}

fn main() {
    let candidate = max_element;
    assert_eq!(candidate(vec![1, 2, 3]), 3);
    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]), 124);
}

===============================
/// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
/// >>> fizz_buzz(50)
/// 0
/// >>> fizz_buzz(78)
/// 2
/// >>> fizz_buzz(79)
/// 3
fn fizz_buzz(n: isize) -> isize {

===============================
-----------------------------
/// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
/// >>> fizz_buzz(50)
/// 0
/// >>> fizz_buzz(78)
/// 2
/// >>> fizz_buzz(79)
/// 3
fn fizz_buzz(n: isize) -> isize {

    n.to_string()
        .chars()
        .filter(|c| c == &'7')
        .count()
}

fn main() {
    let candidate = fizz_buzz;
    assert_eq!(candidate(50), 0);
    assert_eq!(candidate(78), 2);
    assert_eq!(candidate(79), 3);
    assert_eq!(candidate(100), 3);
    assert_eq!(candidate(200), 6);
    assert_eq!(candidate(4000), 192);
    assert_eq!(candidate(10000), 639);
    assert_eq!(candidate(100000), 8026);
}

-----------------------------
/// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
/// >>> fizz_buzz(50)
/// 0
/// >>> fizz_buzz(78)
/// 2
/// >>> fizz_buzz(79)
/// 3
fn fizz_buzz(n: isize) -> isize {

    if n < 0 {
        return 0;
    }
    let mut digits_count = 0;
    let mut num = n;
    while num > 0 {
        digits_count += 1;
        num /= 10;
    }
    let mut ret = 0;
    let mut curr = n;
    while curr > 0 {
        if curr % 11 == 0 || curr % 13 == 0 {
            let mut curr_digits_count = 0;
            let mut num = curr;
            while num > 0 {
                curr_digits_count += 1;
                num /= 10;
            }
            if curr_digits_count == digits_count && curr % 7 == 0 {
                ret += 1;
            }
        }
        curr -= 1;
    }
    ret
}

fn main() {
    let candidate = fizz_buzz;
    assert_eq!(candidate(50), 0);
    assert_eq!(candidate(78), 2);
    assert_eq!(candidate(79), 3);
    assert_eq!(candidate(100), 3);
    assert_eq!(candidate(200), 6);
    assert_eq!(candidate(4000), 192);
    assert_eq!(candidate(10000), 639);
    assert_eq!(candidate(100000), 8026);
}

-----------------------------
/// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
/// >>> fizz_buzz(50)
/// 0
/// >>> fizz_buzz(78)
/// 2
/// >>> fizz_buzz(79)
/// 3
fn fizz_buzz(n: isize) -> isize {

    let mut count = 0;

    for i in 0..n {
        if i % 11 == 0 || i % 13 == 0 {
            if i.to_string().contains('7') {
                count += 1;
            }
        }
    }

    count
}

fn main() {
    let candidate = fizz_buzz;
    assert_eq!(candidate(50), 0);
    assert_eq!(candidate(78), 2);
    assert_eq!(candidate(79), 3);
    assert_eq!(candidate(100), 3);
    assert_eq!(candidate(200), 6);
    assert_eq!(candidate(4000), 192);
    assert_eq!(candidate(10000), 639);
    assert_eq!(candidate(100000), 8026);
}

-----------------------------
/// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
/// >>> fizz_buzz(50)
/// 0
/// >>> fizz_buzz(78)
/// 2
/// >>> fizz_buzz(79)
/// 3
fn fizz_buzz(n: isize) -> isize {

    let mut count = 0;

    for i in 0..n {
        if i % 11 == 0 || i % 13 == 0 {
            let number: isize = i.into();
            if number.to_string().contains("7") {
                count += 1;
            }
        }
    }

    count
}

fn main() {
    let candidate = fizz_buzz;
    assert_eq!(candidate(50), 0);
    assert_eq!(candidate(78), 2);
    assert_eq!(candidate(79), 3);
    assert_eq!(candidate(100), 3);
    assert_eq!(candidate(200), 6);
    assert_eq!(candidate(4000), 192);
    assert_eq!(candidate(10000), 639);
    assert_eq!(candidate(100000), 8026);
}

-----------------------------
/// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
/// >>> fizz_buzz(50)
/// 0
/// >>> fizz_buzz(78)
/// 2
/// >>> fizz_buzz(79)
/// 3
fn fizz_buzz(n: isize) -> isize {

    // if n is not a multiple of 11 or 13
    if n % 11 != 0 && n % 13 != 0 {
        return 0;
    }

    let mut count = 0;
    let mut n = n;

    while n > 0 {
        let nth = n % 10;
        if nth == 7 {
            count += 1;
        }
        n = (n - nth) / 10;
    }

    count
}

fn main() {
    let candidate = fizz_buzz;
    assert_eq!(candidate(50), 0);
    assert_eq!(candidate(78), 2);
    assert_eq!(candidate(79), 3);
    assert_eq!(candidate(100), 3);
    assert_eq!(candidate(200), 6);
    assert_eq!(candidate(4000), 192);
    assert_eq!(candidate(10000), 639);
    assert_eq!(candidate(100000), 8026);
}

===============================
/// This function takes a vector l and returns a vector l' such that
/// l' is identical to l in the odd indicies, while its values at the even indicies are equal
/// to the values of the even indicies of l, but sorted.
/// >>> sort_even(vec![1, 2, 3])
/// vec![1, 2, 3]
/// >>> sort_even(vec![5, 6, 3, 4])
/// vec![3, 6, 5, 4]
fn sort_even(l: Vec<isize>) -> Vec<isize> {

===============================
-----------------------------
/// This function takes a vector l and returns a vector l' such that
/// l' is identical to l in the odd indicies, while its values at the even indicies are equal
/// to the values of the even indicies of l, but sorted.
/// >>> sort_even(vec![1, 2, 3])
/// vec![1, 2, 3]
/// >>> sort_even(vec![5, 6, 3, 4])
/// vec![3, 6, 5, 4]
fn sort_even(l: Vec<isize>) -> Vec<isize> {

    let mut even = Vec::new();
    let mut odd = Vec::new();
    for i in 0..l.len() {
        if i % 2 == 0 {
            even.push(l[i]);
        } else {
            odd.push(l[i]);
        }
    }
    even.sort();
    even.append(&mut odd);
    even
}

fn main() {
    let candidate = sort_even;
    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);
    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);
    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);
}

-----------------------------
/// This function takes a vector l and returns a vector l' such that
/// l' is identical to l in the odd indicies, while its values at the even indicies are equal
/// to the values of the even indicies of l, but sorted.
/// >>> sort_even(vec![1, 2, 3])
/// vec![1, 2, 3]
/// >>> sort_even(vec![5, 6, 3, 4])
/// vec![3, 6, 5, 4]
fn sort_even(l: Vec<isize>) -> Vec<isize> {

    let mut new_l = l.clone();
    new_l.sort_unstable_by(|a, b| a.cmp(b));
    new_l
}

fn main() {
    let candidate = sort_even;
    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);
    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);
    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);
}

-----------------------------
/// This function takes a vector l and returns a vector l' such that
/// l' is identical to l in the odd indicies, while its values at the even indicies are equal
/// to the values of the even indicies of l, but sorted.
/// >>> sort_even(vec![1, 2, 3])
/// vec![1, 2, 3]
/// >>> sort_even(vec![5, 6, 3, 4])
/// vec![3, 6, 5, 4]
fn sort_even(l: Vec<isize>) -> Vec<isize> {

    let mut l = l;
    l.sort_by(|a, b| a.cmp(b));
    l
}

fn main() {
    let candidate = sort_even;
    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);
    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);
    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);
}

-----------------------------
/// This function takes a vector l and returns a vector l' such that
/// l' is identical to l in the odd indicies, while its values at the even indicies are equal
/// to the values of the even indicies of l, but sorted.
/// >>> sort_even(vec![1, 2, 3])
/// vec![1, 2, 3]
/// >>> sort_even(vec![5, 6, 3, 4])
/// vec![3, 6, 5, 4]
fn sort_even(l: Vec<isize>) -> Vec<isize> {

    let mut sorted = l.clone();
    sorted.sort();
    for i in 0..l.len() {
        if (i % 2) == 0 {
            sorted[i] = l[i];
        }
    }
    sorted
}

fn main() {
    let candidate = sort_even;
    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);
    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);
    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);
}

-----------------------------
/// This function takes a vector l and returns a vector l' such that
/// l' is identical to l in the odd indicies, while its values at the even indicies are equal
/// to the values of the even indicies of l, but sorted.
/// >>> sort_even(vec![1, 2, 3])
/// vec![1, 2, 3]
/// >>> sort_even(vec![5, 6, 3, 4])
/// vec![3, 6, 5, 4]
fn sort_even(l: Vec<isize>) -> Vec<isize> {

    let mut new_vec = l.clone();
    let mut sorted_vec = l.clone();
    for x in 0..(new_vec.len() - 1) {
        if x % 2 == 0 && new_vec[x + 1] < new_vec[x] {
            sorted_vec[x] = new_vec[x + 1];
            sorted_vec[x + 1] = new_vec[x];
        }
    }
    sorted_vec
}

fn main() {
    let candidate = sort_even;
    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);
    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);
    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);
}

===============================
/// prime_fib returns n-th number that is a Fibonacci number and it's also prime.
/// >>> prime_fib(1)
/// 2
/// >>> prime_fib(2)
/// 3
/// >>> prime_fib(3)
/// 5
/// >>> prime_fib(4)
/// 13
/// >>> prime_fib(5)
/// 89
fn prime_fib(n: isize) -> isize {

===============================
-----------------------------
/// prime_fib returns n-th number that is a Fibonacci number and it's also prime.
/// >>> prime_fib(1)
/// 2
/// >>> prime_fib(2)
/// 3
/// >>> prime_fib(3)
/// 5
/// >>> prime_fib(4)
/// 13
/// >>> prime_fib(5)
/// 89
fn prime_fib(n: isize) -> isize {

    let mut v: Vec<isize> = vec![1, 2];
    for _ in 2..n {
        let next = v.last().unwrap() + v.last().unwrap() - v[v.len() - 2];
        if utils::is_prime(next) {
            v.push(next);
        } else {
            continue;
        }
    }
    v.last().unwrap().clone()
}

fn main() {
    let candidate = prime_fib;
    assert_eq!(candidate(1), 2);
    assert_eq!(candidate(2), 3);
    assert_eq!(candidate(3), 5);
    assert_eq!(candidate(4), 13);
    assert_eq!(candidate(5), 89);
    assert_eq!(candidate(6), 233);
    assert_eq!(candidate(7), 1597);
    assert_eq!(candidate(8), 28657);
    assert_eq!(candidate(9), 514229);
    assert_eq!(candidate(10), 433494437);
}

-----------------------------
/// prime_fib returns n-th number that is a Fibonacci number and it's also prime.
/// >>> prime_fib(1)
/// 2
/// >>> prime_fib(2)
/// 3
/// >>> prime_fib(3)
/// 5
/// >>> prime_fib(4)
/// 13
/// >>> prime_fib(5)
/// 89
fn prime_fib(n: isize) -> isize {

    let mut p = 0;
    let mut q = 1;
    let mut fib = 1;
    let mut i = 1;
    while i < n {
        fib = p + q;
        p = q;
        q = fib;
        if prime(fib) {
            i += 1;
        }
    }
    fib
}

fn main() {
    let candidate = prime_fib;
    assert_eq!(candidate(1), 2);
    assert_eq!(candidate(2), 3);
    assert_eq!(candidate(3), 5);
    assert_eq!(candidate(4), 13);
    assert_eq!(candidate(5), 89);
    assert_eq!(candidate(6), 233);
    assert_eq!(candidate(7), 1597);
    assert_eq!(candidate(8), 28657);
    assert_eq!(candidate(9), 514229);
    assert_eq!(candidate(10), 433494437);
}

-----------------------------
/// prime_fib returns n-th number that is a Fibonacci number and it's also prime.
/// >>> prime_fib(1)
/// 2
/// >>> prime_fib(2)
/// 3
/// >>> prime_fib(3)
/// 5
/// >>> prime_fib(4)
/// 13
/// >>> prime_fib(5)
/// 89
fn prime_fib(n: isize) -> isize {

    let mut prime_fibs: Vec<isize> = vec![2, 3];
    let mut x: isize = 3;
    let mut y: isize = 2;

    while prime_fibs.len() < n as usize {
        x = x + y;
        y = x - y;
        y = y - (y % 2);

        if is_prime(x) {
            prime_fibs.push(x);
        }
    }

    prime_fibs[n as usize - 1]
}

fn main() {
    let candidate = prime_fib;
    assert_eq!(candidate(1), 2);
    assert_eq!(candidate(2), 3);
    assert_eq!(candidate(3), 5);
    assert_eq!(candidate(4), 13);
    assert_eq!(candidate(5), 89);
    assert_eq!(candidate(6), 233);
    assert_eq!(candidate(7), 1597);
    assert_eq!(candidate(8), 28657);
    assert_eq!(candidate(9), 514229);
    assert_eq!(candidate(10), 433494437);
}

-----------------------------
/// prime_fib returns n-th number that is a Fibonacci number and it's also prime.
/// >>> prime_fib(1)
/// 2
/// >>> prime_fib(2)
/// 3
/// >>> prime_fib(3)
/// 5
/// >>> prime_fib(4)
/// 13
/// >>> prime_fib(5)
/// 89
fn prime_fib(n: isize) -> isize {

    match n {
        1 => 2,
        2 => 3,
        3 => 5,
        _ => {
            let mut fib_n = 1;
            let mut fib_n_1 = 2;
            let mut fib_n_2 = 3;
            for _ in 4..n {
                fib_n_2 = fib_n_1 + fib_n;
                fib_n_1 = fib_n;
                fib_n = fib_n_2;
            }
            if is_prime(fib_n) {
                fib_n
            } else {
                fib_n_2
            }
        }
    }
}

fn main() {
    let candidate = prime_fib;
    assert_eq!(candidate(1), 2);
    assert_eq!(candidate(2), 3);
    assert_eq!(candidate(3), 5);
    assert_eq!(candidate(4), 13);
    assert_eq!(candidate(5), 89);
    assert_eq!(candidate(6), 233);
    assert_eq!(candidate(7), 1597);
    assert_eq!(candidate(8), 28657);
    assert_eq!(candidate(9), 514229);
    assert_eq!(candidate(10), 433494437);
}

-----------------------------
/// prime_fib returns n-th number that is a Fibonacci number and it's also prime.
/// >>> prime_fib(1)
/// 2
/// >>> prime_fib(2)
/// 3
/// >>> prime_fib(3)
/// 5
/// >>> prime_fib(4)
/// 13
/// >>> prime_fib(5)
/// 89
fn prime_fib(n: isize) -> isize {

    if n < 2 {
        return 0;
    }
    let mut prev = 1;
    let mut curr = 2;
    for _ in 2..n {
        let new = prev + curr;
        if is_prime(new) {
            prev = curr;
            curr = new;
        } else {
            prev = curr;
            curr += 2;
        }
    }
    curr
}

fn main() {
    let candidate = prime_fib;
    assert_eq!(candidate(1), 2);
    assert_eq!(candidate(2), 3);
    assert_eq!(candidate(3), 5);
    assert_eq!(candidate(4), 13);
    assert_eq!(candidate(5), 89);
    assert_eq!(candidate(6), 233);
    assert_eq!(candidate(7), 1597);
    assert_eq!(candidate(8), 28657);
    assert_eq!(candidate(9), 514229);
    assert_eq!(candidate(10), 433494437);
}

===============================
/// triples_sum_to_zero takes a vector of integers as an input.
/// it returns true if there are three distinct elements in the vector that
/// sum to zero, and false otherwise.
/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])
/// false
/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])
/// true
/// >>> triples_sum_to_zero(vec![1, 2, 3, 7])
/// false
/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])
/// true
/// >>> triples_sum_to_zero(vec![1])
/// false
fn triples_sum_to_zero(l: Vec<isize>) -> bool {

===============================
-----------------------------
/// triples_sum_to_zero takes a vector of integers as an input.
/// it returns true if there are three distinct elements in the vector that
/// sum to zero, and false otherwise.
/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])
/// false
/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])
/// true
/// >>> triples_sum_to_zero(vec![1, 2, 3, 7])
/// false
/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])
/// true
/// >>> triples_sum_to_zero(vec![1])
/// false
fn triples_sum_to_zero(l: Vec<isize>) -> bool {

    for i in 0..l.len() {
        for j in i + 1..l.len() {
            for k in j + 1..l.len() {
                if l[i] + l[j] + l[k] == 0 {
                    return true;
                }
            }
        }
    }
    false
}

fn main() {
    let candidate = triples_sum_to_zero;
    assert_eq!(candidate(vec![1, 3, 5, 0]), false);
    assert_eq!(candidate(vec![1, 3, 5, -1]), false);
    assert_eq!(candidate(vec![1, 3, -2, 1]), true);
    assert_eq!(candidate(vec![1, 2, 3, 7]), false);
    assert_eq!(candidate(vec![1, 2, 5, 7]), false);
    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);
    assert_eq!(candidate(vec![1]), false);
    assert_eq!(candidate(vec![1, 3, 5, -100]), false);
    assert_eq!(candidate(vec![100, 3, 5, -100]), false);
}

-----------------------------
/// triples_sum_to_zero takes a vector of integers as an input.
/// it returns true if there are three distinct elements in the vector that
/// sum to zero, and false otherwise.
/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])
/// false
/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])
/// true
/// >>> triples_sum_to_zero(vec![1, 2, 3, 7])
/// false
/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])
/// true
/// >>> triples_sum_to_zero(vec![1])
/// false
fn triples_sum_to_zero(l: Vec<isize>) -> bool {

    //  a vector of three booleans is returned to keep track of whether or not a number has been used.
    // this makes it so that we don't use the same number more than once, and also to keep track of whether or not we found a solution.
    let mut used: Vec<bool> = vec![false; l.len()];
    for i in 0..l.len() {
        //  a pair of nested for loops ensure that we are comparing each element with all the elements before and after it.
        for j in 0..l.len() {
            for k in 0..l.len() {
                //  if the indices are different, we continue to the next element.
                if i == j || i == k || j == k {
                    continue;
                }
                //  we sum the elements at indices i, j, and k to see if they sum to zero.
                if l[i] + l[j] + l[k] == 0 {
                    //  we're not allowed to use the same number more than once, so we don't want to use that index again.
                    used[i] = true;
                    used[j] = true;
                    used[k] = true;
                    //  because we found a solution, we return true.
                    return true;
                }
            }
        }
    }
    //  we did not find a solution, so we return false.
    false
}

fn main() {
    let candidate = triples_sum_to_zero;
    assert_eq!(candidate(vec![1, 3, 5, 0]), false);
    assert_eq!(candidate(vec![1, 3, 5, -1]), false);
    assert_eq!(candidate(vec![1, 3, -2, 1]), true);
    assert_eq!(candidate(vec![1, 2, 3, 7]), false);
    assert_eq!(candidate(vec![1, 2, 5, 7]), false);
    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);
    assert_eq!(candidate(vec![1]), false);
    assert_eq!(candidate(vec![1, 3, 5, -100]), false);
    assert_eq!(candidate(vec![100, 3, 5, -100]), false);
}

-----------------------------
/// triples_sum_to_zero takes a vector of integers as an input.
/// it returns true if there are three distinct elements in the vector that
/// sum to zero, and false otherwise.
/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])
/// false
/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])
/// true
/// >>> triples_sum_to_zero(vec![1, 2, 3, 7])
/// false
/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])
/// true
/// >>> triples_sum_to_zero(vec![1])
/// false
fn triples_sum_to_zero(l: Vec<isize>) -> bool {

    l.iter().copied()
        .combinations(3)
        .find(|c| c.iter().sum::<isize>() == 0)
        .is_some()
}

fn main() {
    let candidate = triples_sum_to_zero;
    assert_eq!(candidate(vec![1, 3, 5, 0]), false);
    assert_eq!(candidate(vec![1, 3, 5, -1]), false);
    assert_eq!(candidate(vec![1, 3, -2, 1]), true);
    assert_eq!(candidate(vec![1, 2, 3, 7]), false);
    assert_eq!(candidate(vec![1, 2, 5, 7]), false);
    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);
    assert_eq!(candidate(vec![1]), false);
    assert_eq!(candidate(vec![1, 3, 5, -100]), false);
    assert_eq!(candidate(vec![100, 3, 5, -100]), false);
}

-----------------------------
/// triples_sum_to_zero takes a vector of integers as an input.
/// it returns true if there are three distinct elements in the vector that
/// sum to zero, and false otherwise.
/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])
/// false
/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])
/// true
/// >>> triples_sum_to_zero(vec![1, 2, 3, 7])
/// false
/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])
/// true
/// >>> triples_sum_to_zero(vec![1])
/// false
fn triples_sum_to_zero(l: Vec<isize>) -> bool {

    if l.len() < 3 {
        return false;
    }

    let mut map = HashMap::new();
    for i in 0..l.len() {
        for j in 0..l.len() {
            for k in 0..l.len() {
                if i != j && i != k && j != k && map.get(&(l[i] + l[j] + l[k])).is_none() {
                    map.insert(l[i] + l[j] + l[k], true);
                }
            }
        }
    }
    map.contains_key(&0)
}

fn main() {
    let candidate = triples_sum_to_zero;
    assert_eq!(candidate(vec![1, 3, 5, 0]), false);
    assert_eq!(candidate(vec![1, 3, 5, -1]), false);
    assert_eq!(candidate(vec![1, 3, -2, 1]), true);
    assert_eq!(candidate(vec![1, 2, 3, 7]), false);
    assert_eq!(candidate(vec![1, 2, 5, 7]), false);
    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);
    assert_eq!(candidate(vec![1]), false);
    assert_eq!(candidate(vec![1, 3, 5, -100]), false);
    assert_eq!(candidate(vec![100, 3, 5, -100]), false);
}

-----------------------------
/// triples_sum_to_zero takes a vector of integers as an input.
/// it returns true if there are three distinct elements in the vector that
/// sum to zero, and false otherwise.
/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])
/// false
/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])
/// true
/// >>> triples_sum_to_zero(vec![1, 2, 3, 7])
/// false
/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])
/// true
/// >>> triples_sum_to_zero(vec![1])
/// false
fn triples_sum_to_zero(l: Vec<isize>) -> bool {

    let n = l.len();
    for i in 0..n-1 {
        for j in i+1..n {
            for k in j+1..n {
                if l[i] + l[j] + l[k] == 0 {
                    return true;
                }
            }
        }
    }

    return false;
}

fn main() {
    let candidate = triples_sum_to_zero;
    assert_eq!(candidate(vec![1, 3, 5, 0]), false);
    assert_eq!(candidate(vec![1, 3, 5, -1]), false);
    assert_eq!(candidate(vec![1, 3, -2, 1]), true);
    assert_eq!(candidate(vec![1, 2, 3, 7]), false);
    assert_eq!(candidate(vec![1, 2, 5, 7]), false);
    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);
    assert_eq!(candidate(vec![1]), false);
    assert_eq!(candidate(vec![1, 3, 5, -100]), false);
    assert_eq!(candidate(vec![100, 3, 5, -100]), false);
}

===============================
/// Imagine a road that's a perfectly straight infinitely long line.
/// n cars are driving left to right;  simultaneously, a different set of n cars
/// are driving right to left.   The two sets of cars start out being very far from
/// each other.  All cars move in the same speed.  Two cars are said to collide
/// when a car that's moving left to right hits a car that's moving right to left.
/// However, the cars are infinitely sturdy and strong; as a result, they continue moving
/// in their trajectory as if they did not collide.
/// This function outputs the number of such collisions.
fn car_race_collision(n: isize) -> isize {

===============================
-----------------------------
/// Imagine a road that's a perfectly straight infinitely long line.
/// n cars are driving left to right;  simultaneously, a different set of n cars
/// are driving right to left.   The two sets of cars start out being very far from
/// each other.  All cars move in the same speed.  Two cars are said to collide
/// when a car that's moving left to right hits a car that's moving right to left.
/// However, the cars are infinitely sturdy and strong; as a result, they continue moving
/// in their trajectory as if they did not collide.
/// This function outputs the number of such collisions.
fn car_race_collision(n: isize) -> isize {

    let mut collisions = 0;
    let mut right_to_left = Vec::new();
    right_to_left.resize(n as usize, 0);
    let mut left_to_right = Vec::new();
    left_to_right.resize(n as usize, 0);

    for i in 0..n {
        if (i as f64 + 1.0) % (n as f64 + 1.0) < (n as f64 + 1.0) / 2.0 {
            right_to_left[i as usize] = 1;
        } else {
            left_to_right[i as usize] = 1;
        }
    }

    for i in 0..n {
        for j in 0..n {
            if right_to_left[j] == 1 && left_to_right[i] == 1 {
                if i < j {
                    collisions += 1;
                }
            }
        }
    }
    return collisions;
}

fn main() {
    let candidate = car_race_collision;
    assert_eq!(candidate(2), 4);
    assert_eq!(candidate(3), 9);
    assert_eq!(candidate(4), 16);
    assert_eq!(candidate(8), 64);
    assert_eq!(candidate(10), 100);
}

-----------------------------
/// Imagine a road that's a perfectly straight infinitely long line.
/// n cars are driving left to right;  simultaneously, a different set of n cars
/// are driving right to left.   The two sets of cars start out being very far from
/// each other.  All cars move in the same speed.  Two cars are said to collide
/// when a car that's moving left to right hits a car that's moving right to left.
/// However, the cars are infinitely sturdy and strong; as a result, they continue moving
/// in their trajectory as if they did not collide.
/// This function outputs the number of such collisions.
fn car_race_collision(n: isize) -> isize {

    let mut collisions: isize = 0;
    let n_max: isize = 1_000_000_000;

    let mut car_start_position_left: isize = 1_000_000_000;
    let mut car_start_position_right: isize = -1_000_000_000;
    let mut car_speed: isize = 1_000_000_000;

    for _ in 0..n {
        if car_start_position_left < car_start_position_right {
            collisions += car_start_position_left;
            car_start_position_left += car_speed;
        } else {
            collisions += car_start_position_right;
            car_start_position_right -= car_speed;
        }
        car_speed -= 1;
    }

    return collisions % n_max;
}

fn main() {
    let candidate = car_race_collision;
    assert_eq!(candidate(2), 4);
    assert_eq!(candidate(3), 9);
    assert_eq!(candidate(4), 16);
    assert_eq!(candidate(8), 64);
    assert_eq!(candidate(10), 100);
}

-----------------------------
/// Imagine a road that's a perfectly straight infinitely long line.
/// n cars are driving left to right;  simultaneously, a different set of n cars
/// are driving right to left.   The two sets of cars start out being very far from
/// each other.  All cars move in the same speed.  Two cars are said to collide
/// when a car that's moving left to right hits a car that's moving right to left.
/// However, the cars are infinitely sturdy and strong; as a result, they continue moving
/// in their trajectory as if they did not collide.
/// This function outputs the number of such collisions.
fn car_race_collision(n: isize) -> isize {

    let mut num_collisions = 0;
    let mut cars = Vec::with_capacity(n as usize);
    for i in 0..n {
        cars.push(i * 100);
    }
    let mut cars_r = cars.clone();
    cars_r.reverse();
    for i in 0..n {
        for j in 0..n {
            if cars[i] >= cars_r[j] {
                num_collisions += 1;
            }
        }
    }
    return num_collisions;
}

fn main() {
    let candidate = car_race_collision;
    assert_eq!(candidate(2), 4);
    assert_eq!(candidate(3), 9);
    assert_eq!(candidate(4), 16);
    assert_eq!(candidate(8), 64);
    assert_eq!(candidate(10), 100);
}

-----------------------------
/// Imagine a road that's a perfectly straight infinitely long line.
/// n cars are driving left to right;  simultaneously, a different set of n cars
/// are driving right to left.   The two sets of cars start out being very far from
/// each other.  All cars move in the same speed.  Two cars are said to collide
/// when a car that's moving left to right hits a car that's moving right to left.
/// However, the cars are infinitely sturdy and strong; as a result, they continue moving
/// in their trajectory as if they did not collide.
/// This function outputs the number of such collisions.
fn car_race_collision(n: isize) -> isize {

    let mut left_car = n;
    let mut right_car = n;
    let mut collisions = 0;
    let mut i = 1;

    while left_car > 0 && right_car > 0 {
        left_car -= 1;
        right_car += 1;

        if i % 2 == 0 {
            left_car += 1;
            right_car -= 1;
            collisions += 1;
        }
        i += 1;
    }

    return collisions;
}

fn main() {
    let candidate = car_race_collision;
    assert_eq!(candidate(2), 4);
    assert_eq!(candidate(3), 9);
    assert_eq!(candidate(4), 16);
    assert_eq!(candidate(8), 64);
    assert_eq!(candidate(10), 100);
}

-----------------------------
/// Imagine a road that's a perfectly straight infinitely long line.
/// n cars are driving left to right;  simultaneously, a different set of n cars
/// are driving right to left.   The two sets of cars start out being very far from
/// each other.  All cars move in the same speed.  Two cars are said to collide
/// when a car that's moving left to right hits a car that's moving right to left.
/// However, the cars are infinitely sturdy and strong; as a result, they continue moving
/// in their trajectory as if they did not collide.
/// This function outputs the number of such collisions.
fn car_race_collision(n: isize) -> isize {

    // If n <= 1, then no collision will occur, thus 0.
    if n <= 1 {
        return 0;
    }

    // If n == 2, then there will be one collision.
    if n == 2 {
        return 1;
    }

    // Otherwise, we assume that n > 2.

    // Since the cars are infinitely sturdy and strong, we have that
    // the number of collisions will be the same as if there were a smaller road of
    // length n - 1.
    return car_race_collision(n - 1) * 2;
}

fn main() {
    let candidate = car_race_collision;
    assert_eq!(candidate(2), 4);
    assert_eq!(candidate(3), 9);
    assert_eq!(candidate(4), 16);
    assert_eq!(candidate(8), 64);
    assert_eq!(candidate(10), 100);
}

===============================
/// Return vector with elements incremented by 1.
/// >>> incr_list(vec![1, 2, 3])
/// vec![2, 3, 4]
/// >>> incr_list(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])
/// vec![6, 4, 6, 3, 4, 4, 10, 1, 124]
fn incr_list(l: Vec<isize>) -> Vec<isize> {

===============================
-----------------------------
/// Return vector with elements incremented by 1.
/// >>> incr_list(vec![1, 2, 3])
/// vec![2, 3, 4]
/// >>> incr_list(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])
/// vec![6, 4, 6, 3, 4, 4, 10, 1, 124]
fn incr_list(l: Vec<isize>) -> Vec<isize> {

    let mut v = vec![];
    for i in l {
        v.push(i + 1);
    }
    v
}

fn main() {
    let candidate = incr_list;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![3, 2, 1]), vec![4, 3, 2]);
    assert_eq!(candidate(vec![5, 2, 5, 2, 3, 3, 9, 0, 123]), vec![6, 3, 6, 3, 4, 4, 10, 1, 124]);
}

-----------------------------
/// Return vector with elements incremented by 1.
/// >>> incr_list(vec![1, 2, 3])
/// vec![2, 3, 4]
/// >>> incr_list(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])
/// vec![6, 4, 6, 3, 4, 4, 10, 1, 124]
fn incr_list(l: Vec<isize>) -> Vec<isize> {

    l.iter().map(|&x| x + 1).collect()
}

fn main() {
    let candidate = incr_list;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![3, 2, 1]), vec![4, 3, 2]);
    assert_eq!(candidate(vec![5, 2, 5, 2, 3, 3, 9, 0, 123]), vec![6, 3, 6, 3, 4, 4, 10, 1, 124]);
}

-----------------------------
/// Return vector with elements incremented by 1.
/// >>> incr_list(vec![1, 2, 3])
/// vec![2, 3, 4]
/// >>> incr_list(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])
/// vec![6, 4, 6, 3, 4, 4, 10, 1, 124]
fn incr_list(l: Vec<isize>) -> Vec<isize> {

    let mut l: Vec<isize> = l.into_iter().map(|x| x + 1).collect();
    l.reverse();
    l
}

fn main() {
    let candidate = incr_list;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![3, 2, 1]), vec![4, 3, 2]);
    assert_eq!(candidate(vec![5, 2, 5, 2, 3, 3, 9, 0, 123]), vec![6, 3, 6, 3, 4, 4, 10, 1, 124]);
}

-----------------------------
/// Return vector with elements incremented by 1.
/// >>> incr_list(vec![1, 2, 3])
/// vec![2, 3, 4]
/// >>> incr_list(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])
/// vec![6, 4, 6, 3, 4, 4, 10, 1, 124]
fn incr_list(l: Vec<isize>) -> Vec<isize> {

    let mut res = Vec::new();
    let mut carry = false;
    for e in l {
        let mut res_e = e;
        if carry {
            res_e += 1;
        }
        if res_e == 10 {
            res_e = 0;
            carry = true;
        } else {
            carry = false;
        }
        res.push(res_e);
    }
    if carry {
        res.push(1);
    }
    res
}

fn main() {
    let candidate = incr_list;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![3, 2, 1]), vec![4, 3, 2]);
    assert_eq!(candidate(vec![5, 2, 5, 2, 3, 3, 9, 0, 123]), vec![6, 3, 6, 3, 4, 4, 10, 1, 124]);
}

-----------------------------
/// Return vector with elements incremented by 1.
/// >>> incr_list(vec![1, 2, 3])
/// vec![2, 3, 4]
/// >>> incr_list(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])
/// vec![6, 4, 6, 3, 4, 4, 10, 1, 124]
fn incr_list(l: Vec<isize>) -> Vec<isize> {

    l.into_iter()
        .enumerate()
        .map(|(i, a)| if i == 0 { a + 1 } else { a })
        .collect()
}

fn main() {
    let candidate = incr_list;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![3, 2, 1]), vec![4, 3, 2]);
    assert_eq!(candidate(vec![5, 2, 5, 2, 3, 3, 9, 0, 123]), vec![6, 3, 6, 3, 4, 4, 10, 1, 124]);
}

===============================
/// pairs_sum_to_zero takes a vector of integers as an input.
/// it returns true if there are two distinct elements in the vector that
/// sum to zero, and false otherwise.
/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])
/// false
/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])
/// false
/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])
/// false
/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])
/// true
/// >>> pairs_sum_to_zero(vec![1])
/// false
fn pairs_sum_to_zero(l: Vec<isize>) -> bool {

===============================
-----------------------------
/// pairs_sum_to_zero takes a vector of integers as an input.
/// it returns true if there are two distinct elements in the vector that
/// sum to zero, and false otherwise.
/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])
/// false
/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])
/// false
/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])
/// false
/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])
/// true
/// >>> pairs_sum_to_zero(vec![1])
/// false
fn pairs_sum_to_zero(l: Vec<isize>) -> bool {

    use std::collections::HashMap;
    let mut map: HashMap<isize, bool> = HashMap::new();
    for n in l {
        let m = -n;
        match map.get(&m) {
            Some(&false) => return true,
            Some(&true) => {}
            None => {
                match map.get(&n) {
                    Some(&false) => return true,
                    Some(&true) => {}
                    None => {
                        map.insert(m, true);
                        map.insert(n, false);
                    }
                }
            }
        }
    }
    false
}

fn main() {
    let candidate = pairs_sum_to_zero;
    assert_eq!(candidate(vec![1, 3, 5, 0]), false);
    assert_eq!(candidate(vec![1, 3, -2, 1]), false);
    assert_eq!(candidate(vec![1, 2, 3, 7]), false);
    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);
    assert_eq!(candidate(vec![1]), false);
    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);
    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);
    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);
    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);
}

-----------------------------
/// pairs_sum_to_zero takes a vector of integers as an input.
/// it returns true if there are two distinct elements in the vector that
/// sum to zero, and false otherwise.
/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])
/// false
/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])
/// false
/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])
/// false
/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])
/// true
/// >>> pairs_sum_to_zero(vec![1])
/// false
fn pairs_sum_to_zero(l: Vec<isize>) -> bool {

    // if the vector is too small to contain a pair, return false
    if l.len() < 2 {
        return false;
    }

    // sort the vector
    let mut s = l;
    s.sort();

    // if the first element is positive, there cannot be a pair
    if s[0] >= 0 {
        return false;
    }

    // if the last element is negative, there cannot be a pair
    if s[s.len() - 1] <= 0 {
        return false;
    }

    // the pair must exist, so we need to search through the vector
    // to find it
    let mut start = 0;
    let mut end = s.len() - 1;

    while start < end {
        if s[start] + s[end] == 0 {
            return true;
        } else if s[start] + s[end] > 0 {
            end -= 1;
        } else {
            start += 1;
        }
    }

    false
}

fn main() {
    let candidate = pairs_sum_to_zero;
    assert_eq!(candidate(vec![1, 3, 5, 0]), false);
    assert_eq!(candidate(vec![1, 3, -2, 1]), false);
    assert_eq!(candidate(vec![1, 2, 3, 7]), false);
    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);
    assert_eq!(candidate(vec![1]), false);
    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);
    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);
    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);
    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);
}

-----------------------------
/// pairs_sum_to_zero takes a vector of integers as an input.
/// it returns true if there are two distinct elements in the vector that
/// sum to zero, and false otherwise.
/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])
/// false
/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])
/// false
/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])
/// false
/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])
/// true
/// >>> pairs_sum_to_zero(vec![1])
/// false
fn pairs_sum_to_zero(l: Vec<isize>) -> bool {

    let mut map = HashMap::new();
    for e in l {
        if map.contains_key(&e) {
            return true;
        }
        map.insert(e, true);
    }
    false
}

fn main() {
    let candidate = pairs_sum_to_zero;
    assert_eq!(candidate(vec![1, 3, 5, 0]), false);
    assert_eq!(candidate(vec![1, 3, -2, 1]), false);
    assert_eq!(candidate(vec![1, 2, 3, 7]), false);
    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);
    assert_eq!(candidate(vec![1]), false);
    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);
    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);
    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);
    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);
}

-----------------------------
/// pairs_sum_to_zero takes a vector of integers as an input.
/// it returns true if there are two distinct elements in the vector that
/// sum to zero, and false otherwise.
/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])
/// false
/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])
/// false
/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])
/// false
/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])
/// true
/// >>> pairs_sum_to_zero(vec![1])
/// false
fn pairs_sum_to_zero(l: Vec<isize>) -> bool {

    let mut hash = HashMap::new();
    for i in l {
        if hash.contains_key(&i) {
            return true;
        }
        if hash.contains_key(&-i) {
            return true;
        }
        hash.insert(i, 1);
    }
    false
}

fn main() {
    let candidate = pairs_sum_to_zero;
    assert_eq!(candidate(vec![1, 3, 5, 0]), false);
    assert_eq!(candidate(vec![1, 3, -2, 1]), false);
    assert_eq!(candidate(vec![1, 2, 3, 7]), false);
    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);
    assert_eq!(candidate(vec![1]), false);
    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);
    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);
    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);
    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);
}

-----------------------------
/// pairs_sum_to_zero takes a vector of integers as an input.
/// it returns true if there are two distinct elements in the vector that
/// sum to zero, and false otherwise.
/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])
/// false
/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])
/// false
/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])
/// false
/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])
/// true
/// >>> pairs_sum_to_zero(vec![1])
/// false
fn pairs_sum_to_zero(l: Vec<isize>) -> bool {

    let mut seen = std::collections::HashMap::new();

    for i in l {
        if let Some(j) = seen.get(&-i) {
            return true;
        }
        seen.insert(i, 1);
    }
    false
}

fn main() {
    let candidate = pairs_sum_to_zero;
    assert_eq!(candidate(vec![1, 3, 5, 0]), false);
    assert_eq!(candidate(vec![1, 3, -2, 1]), false);
    assert_eq!(candidate(vec![1, 2, 3, 7]), false);
    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);
    assert_eq!(candidate(vec![1]), false);
    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);
    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);
    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);
    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);
}

===============================
/// Change numerical base of input number x to base.
/// return string representation after the conversion.
/// base numbers are less than 10.
/// >>> change_base(8, 3)
/// String::from("22")
/// >>> change_base(8, 2)
/// String::from("1000")
/// >>> change_base(7, 2)
/// String::from("111")
fn change_base(x: isize, base: isize) -> String {

===============================
-----------------------------
/// Change numerical base of input number x to base.
/// return string representation after the conversion.
/// base numbers are less than 10.
/// >>> change_base(8, 3)
/// String::from("22")
/// >>> change_base(8, 2)
/// String::from("1000")
/// >>> change_base(7, 2)
/// String::from("111")
fn change_base(x: isize, base: isize) -> String {

    let mut x = x;
    let mut ans = String::from("");
    let mut base = base;

    if x < 0 {
        x = -x;
        ans = String::from("-");
    }
    while x != 0 {
        ans = format!("{}{}", &(x % base).to_string(), ans);
        x /= base;
    }
    ans
}

fn main() {
    let candidate = change_base;
    assert_eq!(candidate(8, 3), String::from("22"));
    assert_eq!(candidate(9, 3), String::from("100"));
    assert_eq!(candidate(234, 2), String::from("11101010"));
    assert_eq!(candidate(16, 2), String::from("10000"));
    assert_eq!(candidate(8, 2), String::from("1000"));
    assert_eq!(candidate(7, 2), String::from("111"));
    assert_eq!(candidate(2, 3), String::from("2"));
    assert_eq!(candidate(3, 4), String::from("3"));
    assert_eq!(candidate(4, 5), String::from("4"));
    assert_eq!(candidate(5, 6), String::from("5"));
    assert_eq!(candidate(6, 7), String::from("6"));
    assert_eq!(candidate(7, 8), String::from("7"));
}

-----------------------------
/// Change numerical base of input number x to base.
/// return string representation after the conversion.
/// base numbers are less than 10.
/// >>> change_base(8, 3)
/// String::from("22")
/// >>> change_base(8, 2)
/// String::from("1000")
/// >>> change_base(7, 2)
/// String::from("111")
fn change_base(x: isize, base: isize) -> String {

    // ...
}

fn main() {
    let candidate = change_base;
    assert_eq!(candidate(8, 3), String::from("22"));
    assert_eq!(candidate(9, 3), String::from("100"));
    assert_eq!(candidate(234, 2), String::from("11101010"));
    assert_eq!(candidate(16, 2), String::from("10000"));
    assert_eq!(candidate(8, 2), String::from("1000"));
    assert_eq!(candidate(7, 2), String::from("111"));
    assert_eq!(candidate(2, 3), String::from("2"));
    assert_eq!(candidate(3, 4), String::from("3"));
    assert_eq!(candidate(4, 5), String::from("4"));
    assert_eq!(candidate(5, 6), String::from("5"));
    assert_eq!(candidate(6, 7), String::from("6"));
    assert_eq!(candidate(7, 8), String::from("7"));
}

-----------------------------
/// Change numerical base of input number x to base.
/// return string representation after the conversion.
/// base numbers are less than 10.
/// >>> change_base(8, 3)
/// String::from("22")
/// >>> change_base(8, 2)
/// String::from("1000")
/// >>> change_base(7, 2)
/// String::from("111")
fn change_base(x: isize, base: isize) -> String {

    let mut res = String::new();
    let mut y = x;
    while y > 0 {
        res.push(get_digit(y % base));
        y /= base;
    }
    res.chars().rev().collect::<String>()
}

fn main() {
    let candidate = change_base;
    assert_eq!(candidate(8, 3), String::from("22"));
    assert_eq!(candidate(9, 3), String::from("100"));
    assert_eq!(candidate(234, 2), String::from("11101010"));
    assert_eq!(candidate(16, 2), String::from("10000"));
    assert_eq!(candidate(8, 2), String::from("1000"));
    assert_eq!(candidate(7, 2), String::from("111"));
    assert_eq!(candidate(2, 3), String::from("2"));
    assert_eq!(candidate(3, 4), String::from("3"));
    assert_eq!(candidate(4, 5), String::from("4"));
    assert_eq!(candidate(5, 6), String::from("5"));
    assert_eq!(candidate(6, 7), String::from("6"));
    assert_eq!(candidate(7, 8), String::from("7"));
}

-----------------------------
/// Change numerical base of input number x to base.
/// return string representation after the conversion.
/// base numbers are less than 10.
/// >>> change_base(8, 3)
/// String::from("22")
/// >>> change_base(8, 2)
/// String::from("1000")
/// >>> change_base(7, 2)
/// String::from("111")
fn change_base(x: isize, base: isize) -> String {

    // return string representation of the decimal number x in base base
    // >>> change_base(8, 3)
    // String::from("22")
    // >>> change_base(8, 2)
    // String::from("1000")
    // >>> change_base(7, 2)
    // String::from("111")

    let mut x = x;
    let mut out_string = String::new();

    // TODO

    return out_string;
}

fn main() {
    let candidate = change_base;
    assert_eq!(candidate(8, 3), String::from("22"));
    assert_eq!(candidate(9, 3), String::from("100"));
    assert_eq!(candidate(234, 2), String::from("11101010"));
    assert_eq!(candidate(16, 2), String::from("10000"));
    assert_eq!(candidate(8, 2), String::from("1000"));
    assert_eq!(candidate(7, 2), String::from("111"));
    assert_eq!(candidate(2, 3), String::from("2"));
    assert_eq!(candidate(3, 4), String::from("3"));
    assert_eq!(candidate(4, 5), String::from("4"));
    assert_eq!(candidate(5, 6), String::from("5"));
    assert_eq!(candidate(6, 7), String::from("6"));
    assert_eq!(candidate(7, 8), String::from("7"));
}

-----------------------------
/// Change numerical base of input number x to base.
/// return string representation after the conversion.
/// base numbers are less than 10.
/// >>> change_base(8, 3)
/// String::from("22")
/// >>> change_base(8, 2)
/// String::from("1000")
/// >>> change_base(7, 2)
/// String::from("111")
fn change_base(x: isize, base: isize) -> String {

    let mut num = x;
    let mut res = String::new();
    while num > 0 {
        let digit = num % base;
        res.push(digit + 48);
        num /= base;
    }
    res.chars().rev().collect()
}

fn main() {
    let candidate = change_base;
    assert_eq!(candidate(8, 3), String::from("22"));
    assert_eq!(candidate(9, 3), String::from("100"));
    assert_eq!(candidate(234, 2), String::from("11101010"));
    assert_eq!(candidate(16, 2), String::from("10000"));
    assert_eq!(candidate(8, 2), String::from("1000"));
    assert_eq!(candidate(7, 2), String::from("111"));
    assert_eq!(candidate(2, 3), String::from("2"));
    assert_eq!(candidate(3, 4), String::from("3"));
    assert_eq!(candidate(4, 5), String::from("4"));
    assert_eq!(candidate(5, 6), String::from("5"));
    assert_eq!(candidate(6, 7), String::from("6"));
    assert_eq!(candidate(7, 8), String::from("7"));
}

===============================
/// Given length of a side and high return area for a triangle.
/// >>> triangle_area(5, 3)
/// 7.5
fn triangle_area(a: isize, h: isize) -> f64 {

===============================
-----------------------------
/// Given length of a side and high return area for a triangle.
/// >>> triangle_area(5, 3)
/// 7.5
fn triangle_area(a: isize, h: isize) -> f64 {

    (a as f64 * h as f64) / 2.0
}

fn main() {
    let candidate = triangle_area;
    assert_eq!(candidate(5, 3), 7.5);
    assert_eq!(candidate(2, 2), 2.0);
    assert_eq!(candidate(10, 8), 40.0);
}

-----------------------------
/// Given length of a side and high return area for a triangle.
/// >>> triangle_area(5, 3)
/// 7.5
fn triangle_area(a: isize, h: isize) -> f64 {

    (a * h) as f64 / 2.0
}

fn main() {
    let candidate = triangle_area;
    assert_eq!(candidate(5, 3), 7.5);
    assert_eq!(candidate(2, 2), 2.0);
    assert_eq!(candidate(10, 8), 40.0);
}

-----------------------------
/// Given length of a side and high return area for a triangle.
/// >>> triangle_area(5, 3)
/// 7.5
fn triangle_area(a: isize, h: isize) -> f64 {

    a as f64 * h as f64 * 0.5
}

fn main() {
    let candidate = triangle_area;
    assert_eq!(candidate(5, 3), 7.5);
    assert_eq!(candidate(2, 2), 2.0);
    assert_eq!(candidate(10, 8), 40.0);
}

-----------------------------
/// Given length of a side and high return area for a triangle.
/// >>> triangle_area(5, 3)
/// 7.5
fn triangle_area(a: isize, h: isize) -> f64 {

    (a as f64) * (h as f64) / 2.0
}

fn main() {
    let candidate = triangle_area;
    assert_eq!(candidate(5, 3), 7.5);
    assert_eq!(candidate(2, 2), 2.0);
    assert_eq!(candidate(10, 8), 40.0);
}

-----------------------------
/// Given length of a side and high return area for a triangle.
/// >>> triangle_area(5, 3)
/// 7.5
fn triangle_area(a: isize, h: isize) -> f64 {

    let area: f64 = 0.5 * a as f64 * h as f64;
    area
}

fn main() {
    let candidate = triangle_area;
    assert_eq!(candidate(5, 3), 7.5);
    assert_eq!(candidate(2, 2), 2.0);
    assert_eq!(candidate(10, 8), 40.0);
}

===============================
/// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
/// fib4(0) -> 0
/// fib4(1) -> 0
/// fib4(2) -> 2
/// fib4(3) -> 0
/// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
/// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.
/// >>> fib4(5)
/// 4
/// >>> fib4(6)
/// 8
/// >>> fib4(7)
/// 14
fn fib4(n: isize) -> isize {

===============================
-----------------------------
/// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
/// fib4(0) -> 0
/// fib4(1) -> 0
/// fib4(2) -> 2
/// fib4(3) -> 0
/// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
/// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.
/// >>> fib4(5)
/// 4
/// >>> fib4(6)
/// 8
/// >>> fib4(7)
/// 14
fn fib4(n: isize) -> isize {

    if n < 4 {
        0
    } else {
        let mut array = [0; 4];
        array[0] = 0;
        array[1] = 0;
        array[2] = 2;
        array[3] = 0;
        let mut result = 0;
        for i in 4..n + 1 {
            result = array[0] + array[1] + array[2] + array[3];
            array[0] = array[1];
            array[1] = array[2];
            array[2] = array[3];
            array[3] = result;
        }
        result
    }
}

fn main() {
    let candidate = fib4;
    assert_eq!(candidate(5), 4);
    assert_eq!(candidate(8), 28);
    assert_eq!(candidate(10), 104);
    assert_eq!(candidate(12), 386);
}

-----------------------------
/// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
/// fib4(0) -> 0
/// fib4(1) -> 0
/// fib4(2) -> 2
/// fib4(3) -> 0
/// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
/// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.
/// >>> fib4(5)
/// 4
/// >>> fib4(6)
/// 8
/// >>> fib4(7)
/// 14
fn fib4(n: isize) -> isize {

    if n == 0 {
        return 0;
    }
    if n == 1 {
        return 0;
    }
    let mut i = 2;
    let mut previous = 0;
    let mut fib = 2;
    while i < n {
        let temp = fib;
        fib += previous + temp;
        previous = temp;
        i += 1;
    }
    fib
}

fn main() {
    let candidate = fib4;
    assert_eq!(candidate(5), 4);
    assert_eq!(candidate(8), 28);
    assert_eq!(candidate(10), 104);
    assert_eq!(candidate(12), 386);
}

-----------------------------
/// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
/// fib4(0) -> 0
/// fib4(1) -> 0
/// fib4(2) -> 2
/// fib4(3) -> 0
/// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
/// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.
/// >>> fib4(5)
/// 4
/// >>> fib4(6)
/// 8
/// >>> fib4(7)
/// 14
fn fib4(n: isize) -> isize {

    if n < 4 {
        return n;
    }
    let mut f1: isize = 0;
    let mut f2: isize = 0;
    let mut f3: isize = 0;
    let mut f4: isize = 0;
    for _ in 0..(n - 3) {
        f4 = f3 + f2 + f1;
        f1 = f2;
        f2 = f3;
        f3 = f4;
    }
    f4
}

fn main() {
    let candidate = fib4;
    assert_eq!(candidate(5), 4);
    assert_eq!(candidate(8), 28);
    assert_eq!(candidate(10), 104);
    assert_eq!(candidate(12), 386);
}

-----------------------------
/// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
/// fib4(0) -> 0
/// fib4(1) -> 0
/// fib4(2) -> 2
/// fib4(3) -> 0
/// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
/// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.
/// >>> fib4(5)
/// 4
/// >>> fib4(6)
/// 8
/// >>> fib4(7)
/// 14
fn fib4(n: isize) -> isize {

    let mut f = vec![0; n as usize];
    f[0] = 0;
    f[1] = 0;
    for i in 2..n {
        f[i as usize] = f[(i - 1) as usize] + f[(i - 2) as usize] + f[(i - 3) as usize] + f[(i - 4) as usize];
    }
    f[n as usize - 1]
}

fn main() {
    let candidate = fib4;
    assert_eq!(candidate(5), 4);
    assert_eq!(candidate(8), 28);
    assert_eq!(candidate(10), 104);
    assert_eq!(candidate(12), 386);
}

-----------------------------
/// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
/// fib4(0) -> 0
/// fib4(1) -> 0
/// fib4(2) -> 2
/// fib4(3) -> 0
/// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
/// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.
/// >>> fib4(5)
/// 4
/// >>> fib4(6)
/// 8
/// >>> fib4(7)
/// 14
fn fib4(n: isize) -> isize {

    if n < 3 {
        return n;
    }

    let mut m = n;
    let mut x = 0;
    let mut y = 0;
    let mut z = 1;
    let mut w = 1;

    while m > 2 {
        x = y;
        y = z;
        z = w;
        w = x + y + z + w;
        m -= 1;
    }

    w
}

fn main() {
    let candidate = fib4;
    assert_eq!(candidate(5), 4);
    assert_eq!(candidate(8), 28);
    assert_eq!(candidate(10), 104);
    assert_eq!(candidate(12), 386);
}

===============================
/// Return median of elements in the vector l.
/// >>> median(vec![3, 1, 2, 4, 5])
/// 3.0
/// >>> median(vec![-10, 4, 6, 1000, 10, 20])
/// 15.0
fn median(l: Vec<isize>) -> f64 {

===============================
-----------------------------
/// Return median of elements in the vector l.
/// >>> median(vec![3, 1, 2, 4, 5])
/// 3.0
/// >>> median(vec![-10, 4, 6, 1000, 10, 20])
/// 15.0
fn median(l: Vec<isize>) -> f64 {

    // Get the median of list of integers.
    let mut l = l;
    let len = l.len();
    let mut sorted = l.clone();
    sorted.sort();
    // if the list has even number of items
    let median: f64 = if len % 2 == 0 {
        (sorted[len / 2 - 1] + sorted[len / 2]) as f64 / 2.0
    } else {
        // if list has odd number of items
        sorted[len / 2] as f64
    };

    median
}

fn main() {
    let candidate = median;
    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), 3.0);
    assert_eq!(candidate(vec![-10, 4, 6, 1000, 10, 20]), 8.0);
    assert_eq!(candidate(vec![5]), 5.0);
    assert_eq!(candidate(vec![6, 5]), 5.5);
    assert_eq!(candidate(vec![8, 1, 3, 9, 9, 2, 7]), 7.0);
}

-----------------------------
/// Return median of elements in the vector l.
/// >>> median(vec![3, 1, 2, 4, 5])
/// 3.0
/// >>> median(vec![-10, 4, 6, 1000, 10, 20])
/// 15.0
fn median(l: Vec<isize>) -> f64 {

    l.sort();

    let size = l.len();

    if size % 2 == 0 {
        ((l[size / 2 - 1] + l[size / 2]) as f64) / 2.0
    } else {
        l[size / 2] as f64
    }
}

fn main() {
    let candidate = median;
    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), 3.0);
    assert_eq!(candidate(vec![-10, 4, 6, 1000, 10, 20]), 8.0);
    assert_eq!(candidate(vec![5]), 5.0);
    assert_eq!(candidate(vec![6, 5]), 5.5);
    assert_eq!(candidate(vec![8, 1, 3, 9, 9, 2, 7]), 7.0);
}

-----------------------------
/// Return median of elements in the vector l.
/// >>> median(vec![3, 1, 2, 4, 5])
/// 3.0
/// >>> median(vec![-10, 4, 6, 1000, 10, 20])
/// 15.0
fn median(l: Vec<isize>) -> f64 {

    let mut l = l;
    l.sort();
    let m: usize = l.len() / 2;
    match l.len() % 2 {
        0 => (l[m - 1] as f64 + l[m] as f64) / 2.0,
        _ => l[m] as f64,
    }
}

fn main() {
    let candidate = median;
    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), 3.0);
    assert_eq!(candidate(vec![-10, 4, 6, 1000, 10, 20]), 8.0);
    assert_eq!(candidate(vec![5]), 5.0);
    assert_eq!(candidate(vec![6, 5]), 5.5);
    assert_eq!(candidate(vec![8, 1, 3, 9, 9, 2, 7]), 7.0);
}

-----------------------------
/// Return median of elements in the vector l.
/// >>> median(vec![3, 1, 2, 4, 5])
/// 3.0
/// >>> median(vec![-10, 4, 6, 1000, 10, 20])
/// 15.0
fn median(l: Vec<isize>) -> f64 {

    // Find mid point.
    let mid = l.len() / 2;

    // If odd number of elements, return the mid point element.
    if l.len() % 2 == 1 {
        l[mid].to_f64().unwrap()
    } else {
        // If even number of elements, find the average of mid point
        // elements.
        let a = l[mid - 1].to_f64().unwrap();
        let b = l[mid].to_f64().unwrap();
        (a + b) / 2.0
    }
}

fn main() {
    let candidate = median;
    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), 3.0);
    assert_eq!(candidate(vec![-10, 4, 6, 1000, 10, 20]), 8.0);
    assert_eq!(candidate(vec![5]), 5.0);
    assert_eq!(candidate(vec![6, 5]), 5.5);
    assert_eq!(candidate(vec![8, 1, 3, 9, 9, 2, 7]), 7.0);
}

-----------------------------
/// Return median of elements in the vector l.
/// >>> median(vec![3, 1, 2, 4, 5])
/// 3.0
/// >>> median(vec![-10, 4, 6, 1000, 10, 20])
/// 15.0
fn median(l: Vec<isize>) -> f64 {

    let mut l = l;
    l.sort_by(|a, b| a.cmp(b));
    let mid = l.len() / 2;
    if l.len() % 2 == 0 {
        (l[mid] as f64 + l[mid - 1] as f64) / 2.0
    } else {
        l[mid] as f64
    }
}

fn main() {
    let candidate = median;
    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), 3.0);
    assert_eq!(candidate(vec![-10, 4, 6, 1000, 10, 20]), 8.0);
    assert_eq!(candidate(vec![5]), 5.0);
    assert_eq!(candidate(vec![6, 5]), 5.5);
    assert_eq!(candidate(vec![8, 1, 3, 9, 9, 2, 7]), 7.0);
}

===============================
/// Checks if given string is a palindrome
/// >>> is_palindrome(String::from(""))
/// true
/// >>> is_palindrome(String::from("aba"))
/// true
/// >>> is_palindrome(String::from("aaaaa"))
/// true
/// >>> is_palindrome(String::from("zbcd"))
/// false
fn is_palindrome(text: String) -> bool {

===============================
-----------------------------
/// Checks if given string is a palindrome
/// >>> is_palindrome(String::from(""))
/// true
/// >>> is_palindrome(String::from("aba"))
/// true
/// >>> is_palindrome(String::from("aaaaa"))
/// true
/// >>> is_palindrome(String::from("zbcd"))
/// false
fn is_palindrome(text: String) -> bool {

    let mut chars = text.chars();
    let mut is_palindrome = true;
    while chars.clone().next() == chars.clone().nth(text.len() - 1) {
        chars.next();
        chars.nth(text.len() - 1);
        text.len() -= 2;
    }
    is_palindrome
}

fn main() {
    let candidate = is_palindrome;
    assert_eq!(candidate(String::from("")), true);
    assert_eq!(candidate(String::from("aba")), true);
    assert_eq!(candidate(String::from("aaaaa")), true);
    assert_eq!(candidate(String::from("zbcd")), false);
    assert_eq!(candidate(String::from("xywyx")), true);
    assert_eq!(candidate(String::from("xywyz")), false);
    assert_eq!(candidate(String::from("xywzx")), false);
}

-----------------------------
/// Checks if given string is a palindrome
/// >>> is_palindrome(String::from(""))
/// true
/// >>> is_palindrome(String::from("aba"))
/// true
/// >>> is_palindrome(String::from("aaaaa"))
/// true
/// >>> is_palindrome(String::from("zbcd"))
/// false
fn is_palindrome(text: String) -> bool {

    let mut i = 0;
    let mut j = text.len() - 1;
    while i < j {
        if text.chars().nth(i).unwrap() != text.chars().nth(j).unwrap() {
            return false;
        }
        i += 1;
        j -= 1;
    }
    true
}

fn main() {
    let candidate = is_palindrome;
    assert_eq!(candidate(String::from("")), true);
    assert_eq!(candidate(String::from("aba")), true);
    assert_eq!(candidate(String::from("aaaaa")), true);
    assert_eq!(candidate(String::from("zbcd")), false);
    assert_eq!(candidate(String::from("xywyx")), true);
    assert_eq!(candidate(String::from("xywyz")), false);
    assert_eq!(candidate(String::from("xywzx")), false);
}

-----------------------------
/// Checks if given string is a palindrome
/// >>> is_palindrome(String::from(""))
/// true
/// >>> is_palindrome(String::from("aba"))
/// true
/// >>> is_palindrome(String::from("aaaaa"))
/// true
/// >>> is_palindrome(String::from("zbcd"))
/// false
fn is_palindrome(text: String) -> bool {

    if text == text.chars().rev().collect::<String>() {
        return true;
    }
    false
}

fn main() {
    let candidate = is_palindrome;
    assert_eq!(candidate(String::from("")), true);
    assert_eq!(candidate(String::from("aba")), true);
    assert_eq!(candidate(String::from("aaaaa")), true);
    assert_eq!(candidate(String::from("zbcd")), false);
    assert_eq!(candidate(String::from("xywyx")), true);
    assert_eq!(candidate(String::from("xywyz")), false);
    assert_eq!(candidate(String::from("xywzx")), false);
}

-----------------------------
/// Checks if given string is a palindrome
/// >>> is_palindrome(String::from(""))
/// true
/// >>> is_palindrome(String::from("aba"))
/// true
/// >>> is_palindrome(String::from("aaaaa"))
/// true
/// >>> is_palindrome(String::from("zbcd"))
/// false
fn is_palindrome(text: String) -> bool {

    let text = text.trim();

    let mut is_palindrome = true;

    for i in 0..text.len() / 2 {
        if text.chars().nth(i).unwrap() != text.chars().nth(text.len() - i - 1).unwrap() {
            is_palindrome = false;
            break;
        }
    }

    is_palindrome
}

fn main() {
    let candidate = is_palindrome;
    assert_eq!(candidate(String::from("")), true);
    assert_eq!(candidate(String::from("aba")), true);
    assert_eq!(candidate(String::from("aaaaa")), true);
    assert_eq!(candidate(String::from("zbcd")), false);
    assert_eq!(candidate(String::from("xywyx")), true);
    assert_eq!(candidate(String::from("xywyz")), false);
    assert_eq!(candidate(String::from("xywzx")), false);
}

-----------------------------
/// Checks if given string is a palindrome
/// >>> is_palindrome(String::from(""))
/// true
/// >>> is_palindrome(String::from("aba"))
/// true
/// >>> is_palindrome(String::from("aaaaa"))
/// true
/// >>> is_palindrome(String::from("zbcd"))
/// false
fn is_palindrome(text: String) -> bool {

    let text = text.to_lowercase();
    let text = text.chars().filter(|c| c.is_alphabetic()).collect::<String>();
    if text.len() < 2 {
        true
    } else {
        let (first, second) = text.split_at(text.len() / 2);
        first.chars().zip(second.chars().rev()).all(|(a, b)| a == b)
    }
}

fn main() {
    let candidate = is_palindrome;
    assert_eq!(candidate(String::from("")), true);
    assert_eq!(candidate(String::from("aba")), true);
    assert_eq!(candidate(String::from("aaaaa")), true);
    assert_eq!(candidate(String::from("zbcd")), false);
    assert_eq!(candidate(String::from("xywyx")), true);
    assert_eq!(candidate(String::from("xywyz")), false);
    assert_eq!(candidate(String::from("xywzx")), false);
}

===============================
/// Return 2^n modulo p (be aware of numerics).
/// >>> modp(3, 5)
/// 3
/// >>> modp(1101, 101)
/// 2
/// >>> modp(0, 101)
/// 1
/// >>> modp(3, 11)
/// 8
/// >>> modp(100, 101)
/// 1
fn modp(n: isize, p: isize) -> isize {

===============================
-----------------------------
/// Return 2^n modulo p (be aware of numerics).
/// >>> modp(3, 5)
/// 3
/// >>> modp(1101, 101)
/// 2
/// >>> modp(0, 101)
/// 1
/// >>> modp(3, 11)
/// 8
/// >>> modp(100, 101)
/// 1
fn modp(n: isize, p: isize) -> isize {

    // TODO: overflow
    let n = n % p;
    if n < 0 { n + p } else { n }
}

fn main() {
    let candidate = modp;
    assert_eq!(candidate(3, 5), 3);
    assert_eq!(candidate(1101, 101), 2);
    assert_eq!(candidate(0, 101), 1);
    assert_eq!(candidate(3, 11), 8);
    assert_eq!(candidate(100, 101), 1);
    assert_eq!(candidate(30, 5), 4);
    assert_eq!(candidate(31, 5), 3);
}

-----------------------------
/// Return 2^n modulo p (be aware of numerics).
/// >>> modp(3, 5)
/// 3
/// >>> modp(1101, 101)
/// 2
/// >>> modp(0, 101)
/// 1
/// >>> modp(3, 11)
/// 8
/// >>> modp(100, 101)
/// 1
fn modp(n: isize, p: isize) -> isize {

    let p1 = p - 1;
    (((n & p1) * 2) & p1) | (n & !p1)
}

fn main() {
    let candidate = modp;
    assert_eq!(candidate(3, 5), 3);
    assert_eq!(candidate(1101, 101), 2);
    assert_eq!(candidate(0, 101), 1);
    assert_eq!(candidate(3, 11), 8);
    assert_eq!(candidate(100, 101), 1);
    assert_eq!(candidate(30, 5), 4);
    assert_eq!(candidate(31, 5), 3);
}

-----------------------------
/// Return 2^n modulo p (be aware of numerics).
/// >>> modp(3, 5)
/// 3
/// >>> modp(1101, 101)
/// 2
/// >>> modp(0, 101)
/// 1
/// >>> modp(3, 11)
/// 8
/// >>> modp(100, 101)
/// 1
fn modp(n: isize, p: isize) -> isize {

    if n < 0 {
        return modp(n + p, p);
    }
    (n % p + p) % p
}

fn main() {
    let candidate = modp;
    assert_eq!(candidate(3, 5), 3);
    assert_eq!(candidate(1101, 101), 2);
    assert_eq!(candidate(0, 101), 1);
    assert_eq!(candidate(3, 11), 8);
    assert_eq!(candidate(100, 101), 1);
    assert_eq!(candidate(30, 5), 4);
    assert_eq!(candidate(31, 5), 3);
}

-----------------------------
/// Return 2^n modulo p (be aware of numerics).
/// >>> modp(3, 5)
/// 3
/// >>> modp(1101, 101)
/// 2
/// >>> modp(0, 101)
/// 1
/// >>> modp(3, 11)
/// 8
/// >>> modp(100, 101)
/// 1
fn modp(n: isize, p: isize) -> isize {

    (n.modulo(p) + p) % p
}

fn main() {
    let candidate = modp;
    assert_eq!(candidate(3, 5), 3);
    assert_eq!(candidate(1101, 101), 2);
    assert_eq!(candidate(0, 101), 1);
    assert_eq!(candidate(3, 11), 8);
    assert_eq!(candidate(100, 101), 1);
    assert_eq!(candidate(30, 5), 4);
    assert_eq!(candidate(31, 5), 3);
}

-----------------------------
/// Return 2^n modulo p (be aware of numerics).
/// >>> modp(3, 5)
/// 3
/// >>> modp(1101, 101)
/// 2
/// >>> modp(0, 101)
/// 1
/// >>> modp(3, 11)
/// 8
/// >>> modp(100, 101)
/// 1
fn modp(n: isize, p: isize) -> isize {

    let mut res = n;
    let mut x = 1;
    while x < p {
        x = x * 2;
        res = (res * 2) % p;
    }
    res
}

fn main() {
    let candidate = modp;
    assert_eq!(candidate(3, 5), 3);
    assert_eq!(candidate(1101, 101), 2);
    assert_eq!(candidate(0, 101), 1);
    assert_eq!(candidate(3, 11), 8);
    assert_eq!(candidate(100, 101), 1);
    assert_eq!(candidate(30, 5), 4);
    assert_eq!(candidate(31, 5), 3);
}

===============================
/// remove_vowels is a function that takes string and returns string without vowels.
/// >>> remove_vowels(String::from(""))
/// String::from("")
/// >>> remove_vowels(String::from("abcdef"))
/// String::from("bcdf")
/// >>> remove_vowels(String::from("aaaaa"))
/// String::from("")
/// >>> remove_vowels(String::from("aaBAA"))
/// String::from("B")
/// >>> remove_vowels(String::from("zbcd"))
/// String::from("zbcd")
fn remove_vowels(text: String) -> String {

===============================
-----------------------------
/// remove_vowels is a function that takes string and returns string without vowels.
/// >>> remove_vowels(String::from(""))
/// String::from("")
/// >>> remove_vowels(String::from("abcdef"))
/// String::from("bcdf")
/// >>> remove_vowels(String::from("aaaaa"))
/// String::from("")
/// >>> remove_vowels(String::from("aaBAA"))
/// String::from("B")
/// >>> remove_vowels(String::from("zbcd"))
/// String::from("zbcd")
fn remove_vowels(text: String) -> String {

    let mut vowels: Vec<char> = Vec::new();
    let mut vowels_index: Vec<usize> = Vec::new();
    for (i,c) in text.chars().enumerate() {
        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {
            vowels_index.push(i);
            vowels.push(c);
        }
    }
    if vowels.is_empty() {
        text
    } else {
        let mut new_text: String = text.clone();
        for (i, _) in vowels_index.iter().enumerate() {
            new_text.remove(vowels_index[i]);
        }
        new_text
    }
}

fn main() {
    let candidate = remove_vowels;
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("abcdef
ghijklm")), String::from("bcdf
ghjklm"));
    assert_eq!(candidate(String::from("fedcba")), String::from("fdcb"));
    assert_eq!(candidate(String::from("eeeee")), String::from(""));
    assert_eq!(candidate(String::from("acBAA")), String::from("cB"));
    assert_eq!(candidate(String::from("EcBOO")), String::from("cB"));
    assert_eq!(candidate(String::from("ybcd")), String::from("ybcd"));
}

-----------------------------
/// remove_vowels is a function that takes string and returns string without vowels.
/// >>> remove_vowels(String::from(""))
/// String::from("")
/// >>> remove_vowels(String::from("abcdef"))
/// String::from("bcdf")
/// >>> remove_vowels(String::from("aaaaa"))
/// String::from("")
/// >>> remove_vowels(String::from("aaBAA"))
/// String::from("B")
/// >>> remove_vowels(String::from("zbcd"))
/// String::from("zbcd")
fn remove_vowels(text: String) -> String {

    let mut result: String = String::from("");
    let mut check: bool = false;
    let vowels = vec!['a', 'e', 'i', 'o', 'u'];
    for i in text.chars() {
        check = false;
        for j in vowels {
            if i == j {
                check = true;
            }
        }
        if !check {
            result.push(i);
        }
    }
    return result;
}

fn main() {
    let candidate = remove_vowels;
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("abcdef
ghijklm")), String::from("bcdf
ghjklm"));
    assert_eq!(candidate(String::from("fedcba")), String::from("fdcb"));
    assert_eq!(candidate(String::from("eeeee")), String::from(""));
    assert_eq!(candidate(String::from("acBAA")), String::from("cB"));
    assert_eq!(candidate(String::from("EcBOO")), String::from("cB"));
    assert_eq!(candidate(String::from("ybcd")), String::from("ybcd"));
}

-----------------------------
/// remove_vowels is a function that takes string and returns string without vowels.
/// >>> remove_vowels(String::from(""))
/// String::from("")
/// >>> remove_vowels(String::from("abcdef"))
/// String::from("bcdf")
/// >>> remove_vowels(String::from("aaaaa"))
/// String::from("")
/// >>> remove_vowels(String::from("aaBAA"))
/// String::from("B")
/// >>> remove_vowels(String::from("zbcd"))
/// String::from("zbcd")
fn remove_vowels(text: String) -> String {

    text.chars()
        .filter(|&c| !VOWELS.contains(&c))
        .collect::<String>()
}

fn main() {
    let candidate = remove_vowels;
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("abcdef
ghijklm")), String::from("bcdf
ghjklm"));
    assert_eq!(candidate(String::from("fedcba")), String::from("fdcb"));
    assert_eq!(candidate(String::from("eeeee")), String::from(""));
    assert_eq!(candidate(String::from("acBAA")), String::from("cB"));
    assert_eq!(candidate(String::from("EcBOO")), String::from("cB"));
    assert_eq!(candidate(String::from("ybcd")), String::from("ybcd"));
}

-----------------------------
/// remove_vowels is a function that takes string and returns string without vowels.
/// >>> remove_vowels(String::from(""))
/// String::from("")
/// >>> remove_vowels(String::from("abcdef"))
/// String::from("bcdf")
/// >>> remove_vowels(String::from("aaaaa"))
/// String::from("")
/// >>> remove_vowels(String::from("aaBAA"))
/// String::from("B")
/// >>> remove_vowels(String::from("zbcd"))
/// String::from("zbcd")
fn remove_vowels(text: String) -> String {

    let vowels = "aeiou";
    let mut new_string = String::new();
    let mut i: usize = 0;
    let mut is_vowel: bool = false;

    // Iterate over string
    while i < text.len() {
        let mut c: char = text.chars().nth(i).unwrap();

        // Check if char is vowel
        for vowel in vowels.chars() {
            if c == vowel {
                is_vowel = true;
                break;
            }
        }

        // If char is not vowel add it to new string
        if !is_vowel {
            new_string.push(c);
        }

        // Reset vowel bool
        is_vowel = false;

        // Increment i
        i += 1;
    }

    return new_string;
}

fn main() {
    let candidate = remove_vowels;
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("abcdef
ghijklm")), String::from("bcdf
ghjklm"));
    assert_eq!(candidate(String::from("fedcba")), String::from("fdcb"));
    assert_eq!(candidate(String::from("eeeee")), String::from(""));
    assert_eq!(candidate(String::from("acBAA")), String::from("cB"));
    assert_eq!(candidate(String::from("EcBOO")), String::from("cB"));
    assert_eq!(candidate(String::from("ybcd")), String::from("ybcd"));
}

-----------------------------
/// remove_vowels is a function that takes string and returns string without vowels.
/// >>> remove_vowels(String::from(""))
/// String::from("")
/// >>> remove_vowels(String::from("abcdef"))
/// String::from("bcdf")
/// >>> remove_vowels(String::from("aaaaa"))
/// String::from("")
/// >>> remove_vowels(String::from("aaBAA"))
/// String::from("B")
/// >>> remove_vowels(String::from("zbcd"))
/// String::from("zbcd")
fn remove_vowels(text: String) -> String {

    let vowels = ['a', 'e', 'i', 'o', 'u'];
    let mut new_text = String::new();
    let mut chars = text.chars();
    while let Some(c) = chars.next() {
        if vowels.contains(&c) {
            continue;
        }
        new_text.push(c);
    }
    new_text
}

fn main() {
    let candidate = remove_vowels;
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("abcdef
ghijklm")), String::from("bcdf
ghjklm"));
    assert_eq!(candidate(String::from("fedcba")), String::from("fdcb"));
    assert_eq!(candidate(String::from("eeeee")), String::from(""));
    assert_eq!(candidate(String::from("acBAA")), String::from("cB"));
    assert_eq!(candidate(String::from("EcBOO")), String::from("cB"));
    assert_eq!(candidate(String::from("ybcd")), String::from("ybcd"));
}

===============================
/// Return true if all numbers in the vector l are below threshold t.
/// >>> below_threshold(vec![1, 2, 4, 10], 100)
/// true
/// >>> below_threshold(vec![1, 20, 4, 10], 5)
/// false
fn below_threshold(l: Vec<isize>, t: isize) -> bool {

===============================
-----------------------------
/// Return true if all numbers in the vector l are below threshold t.
/// >>> below_threshold(vec![1, 2, 4, 10], 100)
/// true
/// >>> below_threshold(vec![1, 20, 4, 10], 5)
/// false
fn below_threshold(l: Vec<isize>, t: isize) -> bool {

    l.iter().all(|&x| x < t)
}

fn main() {
    let candidate = below_threshold;
    assert_eq!(candidate(vec![1, 2, 4, 10], 100), true);
    assert_eq!(candidate(vec![1, 20, 4, 10], 5), false);
    assert_eq!(candidate(vec![1, 20, 4, 10], 21), true);
    assert_eq!(candidate(vec![1, 20, 4, 10], 22), true);
    assert_eq!(candidate(vec![1, 8, 4, 10], 11), true);
    assert_eq!(candidate(vec![1, 8, 4, 10], 10), false);
}

-----------------------------
/// Return true if all numbers in the vector l are below threshold t.
/// >>> below_threshold(vec![1, 2, 4, 10], 100)
/// true
/// >>> below_threshold(vec![1, 20, 4, 10], 5)
/// false
fn below_threshold(l: Vec<isize>, t: isize) -> bool {

    l.iter().all(|&x| x < t)
}

fn main() {
    let candidate = below_threshold;
    assert_eq!(candidate(vec![1, 2, 4, 10], 100), true);
    assert_eq!(candidate(vec![1, 20, 4, 10], 5), false);
    assert_eq!(candidate(vec![1, 20, 4, 10], 21), true);
    assert_eq!(candidate(vec![1, 20, 4, 10], 22), true);
    assert_eq!(candidate(vec![1, 8, 4, 10], 11), true);
    assert_eq!(candidate(vec![1, 8, 4, 10], 10), false);
}

-----------------------------
/// Return true if all numbers in the vector l are below threshold t.
/// >>> below_threshold(vec![1, 2, 4, 10], 100)
/// true
/// >>> below_threshold(vec![1, 20, 4, 10], 5)
/// false
fn below_threshold(l: Vec<isize>, t: isize) -> bool {

    l.iter().map(|x| x <= &t).all(|x| x)
}

fn main() {
    let candidate = below_threshold;
    assert_eq!(candidate(vec![1, 2, 4, 10], 100), true);
    assert_eq!(candidate(vec![1, 20, 4, 10], 5), false);
    assert_eq!(candidate(vec![1, 20, 4, 10], 21), true);
    assert_eq!(candidate(vec![1, 20, 4, 10], 22), true);
    assert_eq!(candidate(vec![1, 8, 4, 10], 11), true);
    assert_eq!(candidate(vec![1, 8, 4, 10], 10), false);
}

-----------------------------
/// Return true if all numbers in the vector l are below threshold t.
/// >>> below_threshold(vec![1, 2, 4, 10], 100)
/// true
/// >>> below_threshold(vec![1, 20, 4, 10], 5)
/// false
fn below_threshold(l: Vec<isize>, t: isize) -> bool {

    let mut result = true;
    for e in l {
        if e > t {
            result = false;
            break;
        }
    }
    result
}

fn main() {
    let candidate = below_threshold;
    assert_eq!(candidate(vec![1, 2, 4, 10], 100), true);
    assert_eq!(candidate(vec![1, 20, 4, 10], 5), false);
    assert_eq!(candidate(vec![1, 20, 4, 10], 21), true);
    assert_eq!(candidate(vec![1, 20, 4, 10], 22), true);
    assert_eq!(candidate(vec![1, 8, 4, 10], 11), true);
    assert_eq!(candidate(vec![1, 8, 4, 10], 10), false);
}

-----------------------------
/// Return true if all numbers in the vector l are below threshold t.
/// >>> below_threshold(vec![1, 2, 4, 10], 100)
/// true
/// >>> below_threshold(vec![1, 20, 4, 10], 5)
/// false
fn below_threshold(l: Vec<isize>, t: isize) -> bool {

    // We start by sorting l so we can just go through it in order.
    // Using .sort_by() directly allows us to compare and return before the
    // whole vector is sorted, so we can return as soon as we get a big enough
    // number.
    //
    // .sort_by() accepts a closure that gives it two values to compare. In this
    // case, we want to sort by the absolute value, so we compare the absolute
    // values.
    //
    // The closure returns a comparison between the absolute value of a and b,
    // giving sort_by() an ordering that it can use.
    //
    // If you had more than one thing you wanted to compare, you would use
    // .cmp() and return a Result.
    l.sort_by(|a, b| a.abs().cmp(&b.abs()));

    for n in l {
        if n > t {
            return false;
        }
    }

    true
}

fn main() {
    let candidate = below_threshold;
    assert_eq!(candidate(vec![1, 2, 4, 10], 100), true);
    assert_eq!(candidate(vec![1, 20, 4, 10], 5), false);
    assert_eq!(candidate(vec![1, 20, 4, 10], 21), true);
    assert_eq!(candidate(vec![1, 20, 4, 10], 22), true);
    assert_eq!(candidate(vec![1, 8, 4, 10], 11), true);
    assert_eq!(candidate(vec![1, 8, 4, 10], 10), false);
}

===============================
/// Add two numbers x and y
/// >>> add(2, 3)
/// 5
/// >>> add(5, 7)
/// 12
fn add(x: isize, y: isize) -> isize {

===============================
-----------------------------
/// Add two numbers x and y
/// >>> add(2, 3)
/// 5
/// >>> add(5, 7)
/// 12
fn add(x: isize, y: isize) -> isize {

    x + y
}

fn main() {
    let candidate = add;
    assert_eq!(candidate(0, 1), 1);
    assert_eq!(candidate(1, 0), 1);
    assert_eq!(candidate(2, 3), 5);
    assert_eq!(candidate(5, 7), 12);
    assert_eq!(candidate(7, 5), 12);
}

-----------------------------
/// Add two numbers x and y
/// >>> add(2, 3)
/// 5
/// >>> add(5, 7)
/// 12
fn add(x: isize, y: isize) -> isize {

    x + y
}

fn main() {
    let candidate = add;
    assert_eq!(candidate(0, 1), 1);
    assert_eq!(candidate(1, 0), 1);
    assert_eq!(candidate(2, 3), 5);
    assert_eq!(candidate(5, 7), 12);
    assert_eq!(candidate(7, 5), 12);
}

-----------------------------
/// Add two numbers x and y
/// >>> add(2, 3)
/// 5
/// >>> add(5, 7)
/// 12
fn add(x: isize, y: isize) -> isize {

    x + y
}

fn main() {
    let candidate = add;
    assert_eq!(candidate(0, 1), 1);
    assert_eq!(candidate(1, 0), 1);
    assert_eq!(candidate(2, 3), 5);
    assert_eq!(candidate(5, 7), 12);
    assert_eq!(candidate(7, 5), 12);
}

-----------------------------
/// Add two numbers x and y
/// >>> add(2, 3)
/// 5
/// >>> add(5, 7)
/// 12
fn add(x: isize, y: isize) -> isize {

    x + y
}

fn main() {
    let candidate = add;
    assert_eq!(candidate(0, 1), 1);
    assert_eq!(candidate(1, 0), 1);
    assert_eq!(candidate(2, 3), 5);
    assert_eq!(candidate(5, 7), 12);
    assert_eq!(candidate(7, 5), 12);
}

-----------------------------
/// Add two numbers x and y
/// >>> add(2, 3)
/// 5
/// >>> add(5, 7)
/// 12
fn add(x: isize, y: isize) -> isize {

    x + y
}

fn main() {
    let candidate = add;
    assert_eq!(candidate(0, 1), 1);
    assert_eq!(candidate(1, 0), 1);
    assert_eq!(candidate(2, 3), 5);
    assert_eq!(candidate(5, 7), 12);
    assert_eq!(candidate(7, 5), 12);
}

===============================
/// Check if two words have the same characters.
/// >>> same_chars(String::from("eabcdzzzz"), String::from("dddzzzzzzzddeddabc"))
/// true
/// >>> same_chars(String::from("abcd"), String::from("dddddddabc"))
/// true
/// >>> same_chars(String::from("dddddddabc"), String::from("abcd"))
/// true
/// >>> same_chars(String::from("eabcd"), String::from("dddddddabc"))
/// false
/// >>> same_chars(String::from("abcd"), String::from("dddddddabce"))
/// false
/// >>> same_chars(String::from("eabcdzzzz"), String::from("dddzzzzzzzddddabc"))
/// false
fn same_chars(s0: String, s1: String) -> bool {

===============================
-----------------------------
/// Check if two words have the same characters.
/// >>> same_chars(String::from("eabcdzzzz"), String::from("dddzzzzzzzddeddabc"))
/// true
/// >>> same_chars(String::from("abcd"), String::from("dddddddabc"))
/// true
/// >>> same_chars(String::from("dddddddabc"), String::from("abcd"))
/// true
/// >>> same_chars(String::from("eabcd"), String::from("dddddddabc"))
/// false
/// >>> same_chars(String::from("abcd"), String::from("dddddddabce"))
/// false
/// >>> same_chars(String::from("eabcdzzzz"), String::from("dddzzzzzzzddddabc"))
/// false
fn same_chars(s0: String, s1: String) -> bool {

    if s0.len() != s1.len() {
        return false;
    }
    let mut map = HashMap::new();
    for c in s0.chars() {
        *map.entry(c).or_insert(0) += 1;
    }
    for c in s1.chars() {
        *map.entry(c).or_insert(0) -= 1;
    }
    map.values().any(|&n| n != 0)
}

fn main() {
    let candidate = same_chars;
    assert_eq!(candidate(String::from("eabcdzzzz"), String::from("dddzzzzzzzddeddabc")), true);
    assert_eq!(candidate(String::from("abcd"), String::from("dddddddabc")), true);
    assert_eq!(candidate(String::from("dddddddabc"), String::from("abcd")), true);
    assert_eq!(candidate(String::from("eabcd"), String::from("dddddddabc")), false);
    assert_eq!(candidate(String::from("abcd"), String::from("dddddddabcf")), false);
    assert_eq!(candidate(String::from("eabcdzzzz"), String::from("dddzzzzzzzddddabc")), false);
    assert_eq!(candidate(String::from("aabb"), String::from("aaccc")), false);
}

-----------------------------
/// Check if two words have the same characters.
/// >>> same_chars(String::from("eabcdzzzz"), String::from("dddzzzzzzzddeddabc"))
/// true
/// >>> same_chars(String::from("abcd"), String::from("dddddddabc"))
/// true
/// >>> same_chars(String::from("dddddddabc"), String::from("abcd"))
/// true
/// >>> same_chars(String::from("eabcd"), String::from("dddddddabc"))
/// false
/// >>> same_chars(String::from("abcd"), String::from("dddddddabce"))
/// false
/// >>> same_chars(String::from("eabcdzzzz"), String::from("dddzzzzzzzddddabc"))
/// false
fn same_chars(s0: String, s1: String) -> bool {

    let mut char_map = HashMap::new();
    for ch in s0.chars() {
        char_map.entry(ch).and_modify(|v| *v += 1).or_insert(1);
    }
    let mut char_map2 = HashMap::new();
    for ch in s1.chars() {
        char_map2.entry(ch).and_modify(|v| *v += 1).or_insert(1);
    }
    for (&k, &v) in char_map.iter() {
        let value = char_map2.entry(k).and_modify(|v| *v -= v).or_insert(0);
        if *value != 0 {
            return false;
        }
    }
    return true;
}

fn main() {
    let candidate = same_chars;
    assert_eq!(candidate(String::from("eabcdzzzz"), String::from("dddzzzzzzzddeddabc")), true);
    assert_eq!(candidate(String::from("abcd"), String::from("dddddddabc")), true);
    assert_eq!(candidate(String::from("dddddddabc"), String::from("abcd")), true);
    assert_eq!(candidate(String::from("eabcd"), String::from("dddddddabc")), false);
    assert_eq!(candidate(String::from("abcd"), String::from("dddddddabcf")), false);
    assert_eq!(candidate(String::from("eabcdzzzz"), String::from("dddzzzzzzzddddabc")), false);
    assert_eq!(candidate(String::from("aabb"), String::from("aaccc")), false);
}

-----------------------------
/// Check if two words have the same characters.
/// >>> same_chars(String::from("eabcdzzzz"), String::from("dddzzzzzzzddeddabc"))
/// true
/// >>> same_chars(String::from("abcd"), String::from("dddddddabc"))
/// true
/// >>> same_chars(String::from("dddddddabc"), String::from("abcd"))
/// true
/// >>> same_chars(String::from("eabcd"), String::from("dddddddabc"))
/// false
/// >>> same_chars(String::from("abcd"), String::from("dddddddabce"))
/// false
/// >>> same_chars(String::from("eabcdzzzz"), String::from("dddzzzzzzzddddabc"))
/// false
fn same_chars(s0: String, s1: String) -> bool {

    let mut seen_chars: HashSet<char> = HashSet::new();
    let s0_chars: Vec<char> = s0.chars().collect();
    let s1_chars: Vec<char> = s1.chars().collect();

    // Check if same length
    if s0_chars.len() != s1_chars.len() {
        return false;
    }

    // Check if same chars
    for c in s0_chars {
        if !seen_chars.contains(&c) {
            if !s1_chars.contains(&c) {
                return false;
            }
            seen_chars.insert(c);
        }
    }
    return true;
}

fn main() {
    let candidate = same_chars;
    assert_eq!(candidate(String::from("eabcdzzzz"), String::from("dddzzzzzzzddeddabc")), true);
    assert_eq!(candidate(String::from("abcd"), String::from("dddddddabc")), true);
    assert_eq!(candidate(String::from("dddddddabc"), String::from("abcd")), true);
    assert_eq!(candidate(String::from("eabcd"), String::from("dddddddabc")), false);
    assert_eq!(candidate(String::from("abcd"), String::from("dddddddabcf")), false);
    assert_eq!(candidate(String::from("eabcdzzzz"), String::from("dddzzzzzzzddddabc")), false);
    assert_eq!(candidate(String::from("aabb"), String::from("aaccc")), false);
}

-----------------------------
/// Check if two words have the same characters.
/// >>> same_chars(String::from("eabcdzzzz"), String::from("dddzzzzzzzddeddabc"))
/// true
/// >>> same_chars(String::from("abcd"), String::from("dddddddabc"))
/// true
/// >>> same_chars(String::from("dddddddabc"), String::from("abcd"))
/// true
/// >>> same_chars(String::from("eabcd"), String::from("dddddddabc"))
/// false
/// >>> same_chars(String::from("abcd"), String::from("dddddddabce"))
/// false
/// >>> same_chars(String::from("eabcdzzzz"), String::from("dddzzzzzzzddddabc"))
/// false
fn same_chars(s0: String, s1: String) -> bool {

    let mut found_counts: Vec<usize> = vec![0; 128];
    for c in s0.chars() {
        found_counts[c as usize] += 1;
    }
    for c in s1.chars() {
        found_counts[c as usize] -= 1;
    }
    found_counts.into_iter().filter(|x| *x != 0).count() == 0
}

fn main() {
    let candidate = same_chars;
    assert_eq!(candidate(String::from("eabcdzzzz"), String::from("dddzzzzzzzddeddabc")), true);
    assert_eq!(candidate(String::from("abcd"), String::from("dddddddabc")), true);
    assert_eq!(candidate(String::from("dddddddabc"), String::from("abcd")), true);
    assert_eq!(candidate(String::from("eabcd"), String::from("dddddddabc")), false);
    assert_eq!(candidate(String::from("abcd"), String::from("dddddddabcf")), false);
    assert_eq!(candidate(String::from("eabcdzzzz"), String::from("dddzzzzzzzddddabc")), false);
    assert_eq!(candidate(String::from("aabb"), String::from("aaccc")), false);
}

-----------------------------
/// Check if two words have the same characters.
/// >>> same_chars(String::from("eabcdzzzz"), String::from("dddzzzzzzzddeddabc"))
/// true
/// >>> same_chars(String::from("abcd"), String::from("dddddddabc"))
/// true
/// >>> same_chars(String::from("dddddddabc"), String::from("abcd"))
/// true
/// >>> same_chars(String::from("eabcd"), String::from("dddddddabc"))
/// false
/// >>> same_chars(String::from("abcd"), String::from("dddddddabce"))
/// false
/// >>> same_chars(String::from("eabcdzzzz"), String::from("dddzzzzzzzddddabc"))
/// false
fn same_chars(s0: String, s1: String) -> bool {

    let mut s0_chars = s0.chars().collect::<Vec<char>>();
    let mut s1_chars = s1.chars().collect::<Vec<char>>();
    s0_chars.sort();
    s1_chars.sort();
    let s0_str: String = s0_chars.into_iter().collect();
    let s1_str: String = s1_chars.into_iter().collect();
    s0_str == s1_str
}

fn main() {
    let candidate = same_chars;
    assert_eq!(candidate(String::from("eabcdzzzz"), String::from("dddzzzzzzzddeddabc")), true);
    assert_eq!(candidate(String::from("abcd"), String::from("dddddddabc")), true);
    assert_eq!(candidate(String::from("dddddddabc"), String::from("abcd")), true);
    assert_eq!(candidate(String::from("eabcd"), String::from("dddddddabc")), false);
    assert_eq!(candidate(String::from("abcd"), String::from("dddddddabcf")), false);
    assert_eq!(candidate(String::from("eabcdzzzz"), String::from("dddzzzzzzzddddabc")), false);
    assert_eq!(candidate(String::from("aabb"), String::from("aaccc")), false);
}

===============================
/// Return n-th Fibonacci number.
/// >>> fib(10)
/// 55
/// >>> fib(1)
/// 1
/// >>> fib(8)
/// 21
fn fib(n: isize) -> isize {

===============================
-----------------------------
/// Return n-th Fibonacci number.
/// >>> fib(10)
/// 55
/// >>> fib(1)
/// 1
/// >>> fib(8)
/// 21
fn fib(n: isize) -> isize {

    if n <= 1 {
        return n;
    }
    fib(n - 1) + fib(n - 2)
}

fn main() {
    let candidate = fib;
    assert_eq!(candidate(10), 55);
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(8), 21);
    assert_eq!(candidate(11), 89);
    assert_eq!(candidate(12), 144);
}

-----------------------------
/// Return n-th Fibonacci number.
/// >>> fib(10)
/// 55
/// >>> fib(1)
/// 1
/// >>> fib(8)
/// 21
fn fib(n: isize) -> isize {

    if n <= 2 {
        return 1;
    }
    fib(n - 1) + fib(n - 2)
}

fn main() {
    let candidate = fib;
    assert_eq!(candidate(10), 55);
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(8), 21);
    assert_eq!(candidate(11), 89);
    assert_eq!(candidate(12), 144);
}

-----------------------------
/// Return n-th Fibonacci number.
/// >>> fib(10)
/// 55
/// >>> fib(1)
/// 1
/// >>> fib(8)
/// 21
fn fib(n: isize) -> isize {

    let mut x = 0;
    let mut y = 1;
    for _i in 0..n {
        x = y;
        y = x + y;
    }
    x
}

fn main() {
    let candidate = fib;
    assert_eq!(candidate(10), 55);
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(8), 21);
    assert_eq!(candidate(11), 89);
    assert_eq!(candidate(12), 144);
}

-----------------------------
/// Return n-th Fibonacci number.
/// >>> fib(10)
/// 55
/// >>> fib(1)
/// 1
/// >>> fib(8)
/// 21
fn fib(n: isize) -> isize {

    if n == 1 || n == 2 {
        return 1;
    } else {
        fib(n - 1) + fib(n - 2)
    }
}

fn main() {
    let candidate = fib;
    assert_eq!(candidate(10), 55);
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(8), 21);
    assert_eq!(candidate(11), 89);
    assert_eq!(candidate(12), 144);
}

-----------------------------
/// Return n-th Fibonacci number.
/// >>> fib(10)
/// 55
/// >>> fib(1)
/// 1
/// >>> fib(8)
/// 21
fn fib(n: isize) -> isize {

    if n < 2 {
        n
    } else {
        fib(n - 1) + fib(n - 2)
    }
}

fn main() {
    let candidate = fib;
    assert_eq!(candidate(10), 55);
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(8), 21);
    assert_eq!(candidate(11), 89);
    assert_eq!(candidate(12), 144);
}

===============================
/// brackets is a string of "<" and ">".
/// return true if every opening bracket has a corresponding closing bracket.
/// >>> correct_bracketing(String::from("<"))
/// false
/// >>> correct_bracketing(String::from("<>"))
/// true
/// >>> correct_bracketing(String::from("<<><>>"))
/// true
/// >>> correct_bracketing(String::from("><<>"))
/// false
fn correct_bracketing(brackets: String) -> bool {

===============================
-----------------------------
/// brackets is a string of "<" and ">".
/// return true if every opening bracket has a corresponding closing bracket.
/// >>> correct_bracketing(String::from("<"))
/// false
/// >>> correct_bracketing(String::from("<>"))
/// true
/// >>> correct_bracketing(String::from("<<><>>"))
/// true
/// >>> correct_bracketing(String::from("><<>"))
/// false
fn correct_bracketing(brackets: String) -> bool {

    let mut stack: Vec<char> = vec![];
    for ch in brackets.chars() {
        if ch == '<' {
            stack.push(ch);
        } else if ch == '>' {
            let last_ch = stack.pop();
            if last_ch != Some('<') {
                return false;
            }
        }
    }
    if stack.is_empty() {
        true
    } else {
        false
    }
}

fn main() {
    let candidate = correct_bracketing;
    assert_eq!(candidate(String::from("<>")), true);
    assert_eq!(candidate(String::from("<<><>>")), true);
    assert_eq!(candidate(String::from("<><><<><>><>")), true);
    assert_eq!(candidate(String::from("<><><<<><><>><>><<><><<>>>")), true);
    assert_eq!(candidate(String::from("<<<><>>>>")), false);
    assert_eq!(candidate(String::from("><<>")), false);
    assert_eq!(candidate(String::from("<")), false);
    assert_eq!(candidate(String::from("<<<<")), false);
    assert_eq!(candidate(String::from(">")), false);
    assert_eq!(candidate(String::from("<<>")), false);
    assert_eq!(candidate(String::from("<><><<><>><>><<>")), false);
    assert_eq!(candidate(String::from("<><><<><>><>>><>")), false);
}

-----------------------------
/// brackets is a string of "<" and ">".
/// return true if every opening bracket has a corresponding closing bracket.
/// >>> correct_bracketing(String::from("<"))
/// false
/// >>> correct_bracketing(String::from("<>"))
/// true
/// >>> correct_bracketing(String::from("<<><>>"))
/// true
/// >>> correct_bracketing(String::from("><<>"))
/// false
fn correct_bracketing(brackets: String) -> bool {

    // return false if the number of opening brackets is not equal to the number of closing brackets
    if brackets.matches('<').count() != brackets.matches('>').count() {
        return false;
    }
    let mut open_bracket_indices: Vec<usize> = vec![];
    for (index, c) in brackets.chars().enumerate() {
        match c {
            '<' => {
                open_bracket_indices.push(index);
            }
            '>' => {
                // check if the number of closing brackets is the same as the number of opening brackets
                if open_bracket_indices.len() == 0 {
                    return false;
                }
                let open_bracket_index = open_bracket_indices.pop().unwrap();
                // check if the closing bracket is next to an opening bracket
                if index - open_bracket_index != 1 {
                    return false;
                }
            }
            _ => {}
        }
    }
    // check if all opening brackets have closing brackets
    if open_bracket_indices.len() != 0 {
        return false;
    }
    true
}

fn main() {
    let candidate = correct_bracketing;
    assert_eq!(candidate(String::from("<>")), true);
    assert_eq!(candidate(String::from("<<><>>")), true);
    assert_eq!(candidate(String::from("<><><<><>><>")), true);
    assert_eq!(candidate(String::from("<><><<<><><>><>><<><><<>>>")), true);
    assert_eq!(candidate(String::from("<<<><>>>>")), false);
    assert_eq!(candidate(String::from("><<>")), false);
    assert_eq!(candidate(String::from("<")), false);
    assert_eq!(candidate(String::from("<<<<")), false);
    assert_eq!(candidate(String::from(">")), false);
    assert_eq!(candidate(String::from("<<>")), false);
    assert_eq!(candidate(String::from("<><><<><>><>><<>")), false);
    assert_eq!(candidate(String::from("<><><<><>><>>><>")), false);
}

-----------------------------
/// brackets is a string of "<" and ">".
/// return true if every opening bracket has a corresponding closing bracket.
/// >>> correct_bracketing(String::from("<"))
/// false
/// >>> correct_bracketing(String::from("<>"))
/// true
/// >>> correct_bracketing(String::from("<<><>>"))
/// true
/// >>> correct_bracketing(String::from("><<>"))
/// false
fn correct_bracketing(brackets: String) -> bool {

    let mut stack: Vec<char> = Vec::new();
    let mut balanced = true;
    for bracket in brackets.chars() {
        if bracket == '<' {
            stack.push('<');
        } else if stack.pop() != Some('<') {
            balanced = false;
            break;
        }
    }
    balanced
}

fn main() {
    let candidate = correct_bracketing;
    assert_eq!(candidate(String::from("<>")), true);
    assert_eq!(candidate(String::from("<<><>>")), true);
    assert_eq!(candidate(String::from("<><><<><>><>")), true);
    assert_eq!(candidate(String::from("<><><<<><><>><>><<><><<>>>")), true);
    assert_eq!(candidate(String::from("<<<><>>>>")), false);
    assert_eq!(candidate(String::from("><<>")), false);
    assert_eq!(candidate(String::from("<")), false);
    assert_eq!(candidate(String::from("<<<<")), false);
    assert_eq!(candidate(String::from(">")), false);
    assert_eq!(candidate(String::from("<<>")), false);
    assert_eq!(candidate(String::from("<><><<><>><>><<>")), false);
    assert_eq!(candidate(String::from("<><><<><>><>>><>")), false);
}

-----------------------------
/// brackets is a string of "<" and ">".
/// return true if every opening bracket has a corresponding closing bracket.
/// >>> correct_bracketing(String::from("<"))
/// false
/// >>> correct_bracketing(String::from("<>"))
/// true
/// >>> correct_bracketing(String::from("<<><>>"))
/// true
/// >>> correct_bracketing(String::from("><<>"))
/// false
fn correct_bracketing(brackets: String) -> bool {

    let mut bracket_stack: Vec<char> = Vec::new();
    let mut correct = true;

    for c in brackets.chars() {
        match c {
            '<' => bracket_stack.push('<'),
            '>' => match bracket_stack.pop() {
                Some('<') => {}
                _ => {
                    correct = false;
                    break;
                }
            },
            _ => {}
        }
    }

    correct && bracket_stack.is_empty()
}

fn main() {
    let candidate = correct_bracketing;
    assert_eq!(candidate(String::from("<>")), true);
    assert_eq!(candidate(String::from("<<><>>")), true);
    assert_eq!(candidate(String::from("<><><<><>><>")), true);
    assert_eq!(candidate(String::from("<><><<<><><>><>><<><><<>>>")), true);
    assert_eq!(candidate(String::from("<<<><>>>>")), false);
    assert_eq!(candidate(String::from("><<>")), false);
    assert_eq!(candidate(String::from("<")), false);
    assert_eq!(candidate(String::from("<<<<")), false);
    assert_eq!(candidate(String::from(">")), false);
    assert_eq!(candidate(String::from("<<>")), false);
    assert_eq!(candidate(String::from("<><><<><>><>><<>")), false);
    assert_eq!(candidate(String::from("<><><<><>><>>><>")), false);
}

-----------------------------
/// brackets is a string of "<" and ">".
/// return true if every opening bracket has a corresponding closing bracket.
/// >>> correct_bracketing(String::from("<"))
/// false
/// >>> correct_bracketing(String::from("<>"))
/// true
/// >>> correct_bracketing(String::from("<<><>>"))
/// true
/// >>> correct_bracketing(String::from("><<>"))
/// false
fn correct_bracketing(brackets: String) -> bool {

    let mut open_brackets = Vec::new();
    for c in brackets.chars() {
        match c {
            '<' => open_brackets.push(c),
            '>' => {
                if open_brackets.pop().unwrap() == '<' {
                    continue;
                }
                return false;
            }
            _ => (),
        }
    }
    open_brackets.is_empty()
}

fn main() {
    let candidate = correct_bracketing;
    assert_eq!(candidate(String::from("<>")), true);
    assert_eq!(candidate(String::from("<<><>>")), true);
    assert_eq!(candidate(String::from("<><><<><>><>")), true);
    assert_eq!(candidate(String::from("<><><<<><><>><>><<><><<>>>")), true);
    assert_eq!(candidate(String::from("<<<><>>>>")), false);
    assert_eq!(candidate(String::from("><<>")), false);
    assert_eq!(candidate(String::from("<")), false);
    assert_eq!(candidate(String::from("<<<<")), false);
    assert_eq!(candidate(String::from(">")), false);
    assert_eq!(candidate(String::from("<<>")), false);
    assert_eq!(candidate(String::from("<><><<><>><>><<>")), false);
    assert_eq!(candidate(String::from("<><><<><>><>>><>")), false);
}

===============================
/// Return true is vector elements are monotonically increasing or decreasing.
/// >>> monotonic(vec![1, 2, 4, 20])
/// true
/// >>> monotonic(vec![1, 20, 4, 10])
/// false
/// >>> monotonic(vec![4, 1, 0, -10])
/// true
fn monotonic(l: Vec<isize>) -> bool {

===============================
-----------------------------
/// Return true is vector elements are monotonically increasing or decreasing.
/// >>> monotonic(vec![1, 2, 4, 20])
/// true
/// >>> monotonic(vec![1, 20, 4, 10])
/// false
/// >>> monotonic(vec![4, 1, 0, -10])
/// true
fn monotonic(l: Vec<isize>) -> bool {

    let mut d = 1;
    for i in 0..l.len() - 1 {
        if l[i] > l[i + 1] {
            d = -1;
        } else if l[i] < l[i + 1] {
            d = 1;
        } else if l[i] == l[i + 1] {
            return true;
        }
        if d == 0 {
            return false;
        }
    }
    true
}

fn main() {
    let candidate = monotonic;
    assert_eq!(candidate(vec![1, 2, 4, 10]), true);
    assert_eq!(candidate(vec![1, 2, 4, 20]), true);
    assert_eq!(candidate(vec![1, 20, 4, 10]), false);
    assert_eq!(candidate(vec![4, 1, 0, -10]), true);
    assert_eq!(candidate(vec![4, 1, 1, 0]), true);
    assert_eq!(candidate(vec![1, 2, 3, 2, 5, 60]), false);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 60]), true);
    assert_eq!(candidate(vec![9, 9, 9, 9]), true);
}

-----------------------------
/// Return true is vector elements are monotonically increasing or decreasing.
/// >>> monotonic(vec![1, 2, 4, 20])
/// true
/// >>> monotonic(vec![1, 20, 4, 10])
/// false
/// >>> monotonic(vec![4, 1, 0, -10])
/// true
fn monotonic(l: Vec<isize>) -> bool {

    let (mut prev, mut inc) = (0, true);
    for &i in l.iter() {
        if i == prev {
            continue;
        }
        if (i < prev) && inc {
            return false;
        }
        if (i > prev) && !inc {
            return false;
        }
        prev = i;
        inc = i > prev;
    }
    true
}

fn main() {
    let candidate = monotonic;
    assert_eq!(candidate(vec![1, 2, 4, 10]), true);
    assert_eq!(candidate(vec![1, 2, 4, 20]), true);
    assert_eq!(candidate(vec![1, 20, 4, 10]), false);
    assert_eq!(candidate(vec![4, 1, 0, -10]), true);
    assert_eq!(candidate(vec![4, 1, 1, 0]), true);
    assert_eq!(candidate(vec![1, 2, 3, 2, 5, 60]), false);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 60]), true);
    assert_eq!(candidate(vec![9, 9, 9, 9]), true);
}

-----------------------------
/// Return true is vector elements are monotonically increasing or decreasing.
/// >>> monotonic(vec![1, 2, 4, 20])
/// true
/// >>> monotonic(vec![1, 20, 4, 10])
/// false
/// >>> monotonic(vec![4, 1, 0, -10])
/// true
fn monotonic(l: Vec<isize>) -> bool {

    let mut last = l[0];
    let mut res = 1;
    for i in 1..l.len() {
        let cur = l[i];
        if cur < last {
            res = -1;
        } else if cur > last {
            res = 1;
        } else {
            res = 0;
        }
        last = cur;
    }
    res == 0
}

fn main() {
    let candidate = monotonic;
    assert_eq!(candidate(vec![1, 2, 4, 10]), true);
    assert_eq!(candidate(vec![1, 2, 4, 20]), true);
    assert_eq!(candidate(vec![1, 20, 4, 10]), false);
    assert_eq!(candidate(vec![4, 1, 0, -10]), true);
    assert_eq!(candidate(vec![4, 1, 1, 0]), true);
    assert_eq!(candidate(vec![1, 2, 3, 2, 5, 60]), false);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 60]), true);
    assert_eq!(candidate(vec![9, 9, 9, 9]), true);
}

-----------------------------
/// Return true is vector elements are monotonically increasing or decreasing.
/// >>> monotonic(vec![1, 2, 4, 20])
/// true
/// >>> monotonic(vec![1, 20, 4, 10])
/// false
/// >>> monotonic(vec![4, 1, 0, -10])
/// true
fn monotonic(l: Vec<isize>) -> bool {

    let l_len = l.len();

    if l_len < 3 {
        return true;
    }

    let mut increasing = true;
    let mut decreasing = true;

    let mut last_value = l[0];

    for i in 1..l_len {
        let value = l[i];

        if last_value > value {
            if increasing {
                increasing = false;
                decreasing = true;
            } else {
                return false;
            }
        } else if last_value < value {
            if decreasing {
                decreasing = false;
                increasing = true;
            } else {
                return false;
            }
        } else {
            if !increasing && !decreasing {
                return false;
            }
        }

        last_value = value;
    }

    true
}

fn main() {
    let candidate = monotonic;
    assert_eq!(candidate(vec![1, 2, 4, 10]), true);
    assert_eq!(candidate(vec![1, 2, 4, 20]), true);
    assert_eq!(candidate(vec![1, 20, 4, 10]), false);
    assert_eq!(candidate(vec![4, 1, 0, -10]), true);
    assert_eq!(candidate(vec![4, 1, 1, 0]), true);
    assert_eq!(candidate(vec![1, 2, 3, 2, 5, 60]), false);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 60]), true);
    assert_eq!(candidate(vec![9, 9, 9, 9]), true);
}

-----------------------------
/// Return true is vector elements are monotonically increasing or decreasing.
/// >>> monotonic(vec![1, 2, 4, 20])
/// true
/// >>> monotonic(vec![1, 20, 4, 10])
/// false
/// >>> monotonic(vec![4, 1, 0, -10])
/// true
fn monotonic(l: Vec<isize>) -> bool {

    let mut l = l.clone();
    let mut is_up: bool = true;
    let mut is_down: bool = true;

    l.sort();

    // TODO: This is a bit clumsy. Consider refactoring.
    for i in 1..l.len() {
        if l[i] == l[i-1] {
            is_up = false;
            is_down = false;
        } else if l[i] > l[i-1] {
            is_up = true;
            is_down = false;
        } else {
            is_down = true;
            is_up = false;
        }
        if !is_up && !is_down {
            return false;
        }
    }
    true
}

fn main() {
    let candidate = monotonic;
    assert_eq!(candidate(vec![1, 2, 4, 10]), true);
    assert_eq!(candidate(vec![1, 2, 4, 20]), true);
    assert_eq!(candidate(vec![1, 20, 4, 10]), false);
    assert_eq!(candidate(vec![4, 1, 0, -10]), true);
    assert_eq!(candidate(vec![4, 1, 1, 0]), true);
    assert_eq!(candidate(vec![1, 2, 3, 2, 5, 60]), false);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 60]), true);
    assert_eq!(candidate(vec![9, 9, 9, 9]), true);
}

===============================
/// Return sorted unique common elements for two vectors.
/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])
/// vec![1, 5, 653]
/// >>> common(vec![5, 3, 2, 8], vec![3, 2])
/// vec![2, 3]
fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {

===============================
-----------------------------
/// Return sorted unique common elements for two vectors.
/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])
/// vec![1, 5, 653]
/// >>> common(vec![5, 3, 2, 8], vec![3, 2])
/// vec![2, 3]
fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {

    l1.iter()
        .filter(|&x| l2.contains(x))
        .chain(l2.iter().filter(|&x| l1.contains(x)))
        .collect()
}

fn main() {
    let candidate = common;
    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);
    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);
    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);
    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());
}

-----------------------------
/// Return sorted unique common elements for two vectors.
/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])
/// vec![1, 5, 653]
/// >>> common(vec![5, 3, 2, 8], vec![3, 2])
/// vec![2, 3]
fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {

    // check if l1 is the shorter vector
    let l1_length = l1.len();
    let l2_length = l2.len();
    let smaller_vec = if l1_length < l2_length {
        &l1
    } else {
        &l2
    };
    let larger_vec = if l1_length < l2_length {
        &l2
    } else {
        &l1
    };
    // create a new vector that will be the output
    let mut unique_vec = Vec::new();
    // go through the larger vector and check each element to see if it is
    // in the smaller vector
    for elem in larger_vec {
        if smaller_vec.contains(elem) {
            unique_vec.push(*elem);
        }
    }
    // sort the vector
    unique_vec.sort_unstable();
    // return the vector
    unique_vec
}

fn main() {
    let candidate = common;
    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);
    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);
    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);
    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());
}

-----------------------------
/// Return sorted unique common elements for two vectors.
/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])
/// vec![1, 5, 653]
/// >>> common(vec![5, 3, 2, 8], vec![3, 2])
/// vec![2, 3]
fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {

    let mut s1 = l1.into_iter().collect::<HashSet<isize>>();
    let mut s2 = l2.into_iter().collect::<HashSet<isize>>();
    s1.retain(|&x| s2.contains(&x));
    s1.into_iter().collect()
}

fn main() {
    let candidate = common;
    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);
    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);
    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);
    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());
}

-----------------------------
/// Return sorted unique common elements for two vectors.
/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])
/// vec![1, 5, 653]
/// >>> common(vec![5, 3, 2, 8], vec![3, 2])
/// vec![2, 3]
fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {

    let mut common = vec![];
    for i in 0..l1.len() {
        for j in 0..l2.len() {
            if l1[i] == l2[j] {
                common.push(l1[i]);
            }
        }
    }
    common.sort();
    common.dedup();
    common
}

fn main() {
    let candidate = common;
    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);
    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);
    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);
    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());
}

-----------------------------
/// Return sorted unique common elements for two vectors.
/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])
/// vec![1, 5, 653]
/// >>> common(vec![5, 3, 2, 8], vec![3, 2])
/// vec![2, 3]
fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {

    let mut result: Vec<isize> = Vec::new();
    let mut l1_iter = l1.iter();
    let mut l2_iter = l2.iter();
    while l1_iter.clone().next().is_some() && l2_iter.clone().next().is_some() {
        match (l1_iter.clone().next(), l2_iter.clone().next()) {
            (Some(&x), Some(&y)) if x == y => {
                l1_iter.next();
                l2_iter.next();
                result.push(x);
            }
            (Some(x), _) if x < y => l1_iter.next(),
            (_, Some(y)) if x > y => l2_iter.next(),
            _ => panic!("Unmatched values in both vectors."),
        };
    }
    result.sort();
    result
}

fn main() {
    let candidate = common;
    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);
    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);
    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);
    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());
}

===============================
/// Return the largest prime factor of n. Assume n > 1 and is not a prime.
/// >>> largest_prime_factor(13195)
/// 29
/// >>> largest_prime_factor(2048)
/// 2
fn largest_prime_factor(n: isize) -> isize {

===============================
-----------------------------
/// Return the largest prime factor of n. Assume n > 1 and is not a prime.
/// >>> largest_prime_factor(13195)
/// 29
/// >>> largest_prime_factor(2048)
/// 2
fn largest_prime_factor(n: isize) -> isize {

    let mut n = n;
    if n % 2 == 0 {
        while n % 2 == 0 {
            n /= 2;
        }
    }
    if n % 3 == 0 {
        while n % 3 == 0 {
            n /= 3;
        }
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 {
            while n % i == 0 {
                n /= i;
            }
        }
        i += 2;
    }
    if n > 1 {
        n
    } else {
        0
    }
}

fn main() {
    let candidate = largest_prime_factor;
    assert_eq!(candidate(15), 5);
    assert_eq!(candidate(27), 3);
    assert_eq!(candidate(63), 7);
    assert_eq!(candidate(330), 11);
    assert_eq!(candidate(13195), 29);
}

-----------------------------
/// Return the largest prime factor of n. Assume n > 1 and is not a prime.
/// >>> largest_prime_factor(13195)
/// 29
/// >>> largest_prime_factor(2048)
/// 2
fn largest_prime_factor(n: isize) -> isize {

    let mut max_factor = 2;
    let mut n = n;

    // Loop invariant: max_factor is the largest prime factor of n.
    while max_factor * max_factor <= n {
        if n % max_factor == 0 {
            n /= max_factor;
        } else {
            max_factor += 1;
        }
    }

    if n > max_factor {
        max_factor
    } else {
        n
    }
}

fn main() {
    let candidate = largest_prime_factor;
    assert_eq!(candidate(15), 5);
    assert_eq!(candidate(27), 3);
    assert_eq!(candidate(63), 7);
    assert_eq!(candidate(330), 11);
    assert_eq!(candidate(13195), 29);
}

-----------------------------
/// Return the largest prime factor of n. Assume n > 1 and is not a prime.
/// >>> largest_prime_factor(13195)
/// 29
/// >>> largest_prime_factor(2048)
/// 2
fn largest_prime_factor(n: isize) -> isize {

    let mut p = 3;
    let mut last_factor = 1;

    loop {
        if n % p == 0 {
            last_factor = p;
            n /= p;
        } else {
            p += 2;
        }
        if p > n {
            break;
        }
    }
    last_factor
}

fn main() {
    let candidate = largest_prime_factor;
    assert_eq!(candidate(15), 5);
    assert_eq!(candidate(27), 3);
    assert_eq!(candidate(63), 7);
    assert_eq!(candidate(330), 11);
    assert_eq!(candidate(13195), 29);
}

-----------------------------
/// Return the largest prime factor of n. Assume n > 1 and is not a prime.
/// >>> largest_prime_factor(13195)
/// 29
/// >>> largest_prime_factor(2048)
/// 2
fn largest_prime_factor(n: isize) -> isize {

    let mut i = 2;
    while i * i <= n {
        if n % i == 0 {
            let mut j = n / i;
            while j >= i {
                if j % i == 0 {
                    j /= i;
                } else {
                    break;
                }
            }
            if j == i {
                return i;
            }
        }
        i += 1;
    }
    n
}

fn main() {
    let candidate = largest_prime_factor;
    assert_eq!(candidate(15), 5);
    assert_eq!(candidate(27), 3);
    assert_eq!(candidate(63), 7);
    assert_eq!(candidate(330), 11);
    assert_eq!(candidate(13195), 29);
}

-----------------------------
/// Return the largest prime factor of n. Assume n > 1 and is not a prime.
/// >>> largest_prime_factor(13195)
/// 29
/// >>> largest_prime_factor(2048)
/// 2
fn largest_prime_factor(n: isize) -> isize {

    if n < 2 {
        return 1;
    }
    if n == 2 {
        return 2;
    }
    if n % 2 == 0 {
        return largest_prime_factor(n / 2);
    }
    if n % 3 == 0 {
        return largest_prime_factor(n / 3);
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 {
            return largest_prime_factor(n / i);
        }
        i += 2;
    }
    n
}

fn main() {
    let candidate = largest_prime_factor;
    assert_eq!(candidate(15), 5);
    assert_eq!(candidate(27), 3);
    assert_eq!(candidate(63), 7);
    assert_eq!(candidate(330), 11);
    assert_eq!(candidate(13195), 29);
}

===============================
/// sum_to_n is a function that sums numbers from 1 to n.
/// >>> sum_to_n(30)
/// 465
/// >>> sum_to_n(100)
/// 5050
/// >>> sum_to_n(5)
/// 15
/// >>> sum_to_n(10)
/// 55
/// >>> sum_to_n(1)
/// 1
fn sum_to_n(n: isize) -> isize {

===============================
-----------------------------
/// sum_to_n is a function that sums numbers from 1 to n.
/// >>> sum_to_n(30)
/// 465
/// >>> sum_to_n(100)
/// 5050
/// >>> sum_to_n(5)
/// 15
/// >>> sum_to_n(10)
/// 55
/// >>> sum_to_n(1)
/// 1
fn sum_to_n(n: isize) -> isize {

    if n < 1 {
        return 0;
    }
    n * (n + 1) / 2
}

fn main() {
    let candidate = sum_to_n;
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(6), 21);
    assert_eq!(candidate(11), 66);
    assert_eq!(candidate(30), 465);
    assert_eq!(candidate(100), 5050);
}

-----------------------------
/// sum_to_n is a function that sums numbers from 1 to n.
/// >>> sum_to_n(30)
/// 465
/// >>> sum_to_n(100)
/// 5050
/// >>> sum_to_n(5)
/// 15
/// >>> sum_to_n(10)
/// 55
/// >>> sum_to_n(1)
/// 1
fn sum_to_n(n: isize) -> isize {

    if n == 1 {
        return 1;
    }

    let half_of_n = n / 2;

    half_of_n * (half_of_n + 1) + half_of_n
}

fn main() {
    let candidate = sum_to_n;
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(6), 21);
    assert_eq!(candidate(11), 66);
    assert_eq!(candidate(30), 465);
    assert_eq!(candidate(100), 5050);
}

-----------------------------
/// sum_to_n is a function that sums numbers from 1 to n.
/// >>> sum_to_n(30)
/// 465
/// >>> sum_to_n(100)
/// 5050
/// >>> sum_to_n(5)
/// 15
/// >>> sum_to_n(10)
/// 55
/// >>> sum_to_n(1)
/// 1
fn sum_to_n(n: isize) -> isize {

    let mut total = 0;
    for i in 1..=n {
        total += i;
    }
    total
}

fn main() {
    let candidate = sum_to_n;
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(6), 21);
    assert_eq!(candidate(11), 66);
    assert_eq!(candidate(30), 465);
    assert_eq!(candidate(100), 5050);
}

-----------------------------
/// sum_to_n is a function that sums numbers from 1 to n.
/// >>> sum_to_n(30)
/// 465
/// >>> sum_to_n(100)
/// 5050
/// >>> sum_to_n(5)
/// 15
/// >>> sum_to_n(10)
/// 55
/// >>> sum_to_n(1)
/// 1
fn sum_to_n(n: isize) -> isize {

    return 1 + ((n * (n + 1)) / 2);
}

fn main() {
    let candidate = sum_to_n;
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(6), 21);
    assert_eq!(candidate(11), 66);
    assert_eq!(candidate(30), 465);
    assert_eq!(candidate(100), 5050);
}

-----------------------------
/// sum_to_n is a function that sums numbers from 1 to n.
/// >>> sum_to_n(30)
/// 465
/// >>> sum_to_n(100)
/// 5050
/// >>> sum_to_n(5)
/// 15
/// >>> sum_to_n(10)
/// 55
/// >>> sum_to_n(1)
/// 1
fn sum_to_n(n: isize) -> isize {

    if n <= 0 {
        return 0;
    }
    let mut total = 0;
    for i in 1..=n {
        total += i;
    }
    total
}

fn main() {
    let candidate = sum_to_n;
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(6), 21);
    assert_eq!(candidate(11), 66);
    assert_eq!(candidate(30), 465);
    assert_eq!(candidate(100), 5050);
}

===============================
/// brackets is a string of "(" and ")".
/// return true if every opening bracket has a corresponding closing bracket.
/// >>> correct_bracketing(String::from("("))
/// false
/// >>> correct_bracketing(String::from("()"))
/// true
/// >>> correct_bracketing(String::from("(()())"))
/// true
/// >>> correct_bracketing(String::from(")(()"))
/// false
fn correct_bracketing(brackets: String) -> bool {

===============================
-----------------------------
/// brackets is a string of "(" and ")".
/// return true if every opening bracket has a corresponding closing bracket.
/// >>> correct_bracketing(String::from("("))
/// false
/// >>> correct_bracketing(String::from("()"))
/// true
/// >>> correct_bracketing(String::from("(()())"))
/// true
/// >>> correct_bracketing(String::from(")(()"))
/// false
fn correct_bracketing(brackets: String) -> bool {

    let mut stack: Vec<char> = Vec::new();
    for b in brackets.chars() {
        match b {
            '(' => stack.push('('),
            ')' => match stack.pop() {
                Some(_) => continue,
                None => {
                    return false;
                }
            },
            _ => {}
        }
    }
    return stack.is_empty();
}

fn main() {
    let candidate = correct_bracketing;
    assert_eq!(candidate(String::from("()")), true);
    assert_eq!(candidate(String::from("(()())")), true);
    assert_eq!(candidate(String::from("()()(()())()")), true);
    assert_eq!(candidate(String::from("()()((()()())())(()()(()))")), true);
    assert_eq!(candidate(String::from("((()())))")), false);
    assert_eq!(candidate(String::from(")(()")), false);
    assert_eq!(candidate(String::from("(")), false);
    assert_eq!(candidate(String::from("((((")), false);
    assert_eq!(candidate(String::from(")")), false);
    assert_eq!(candidate(String::from("(()")), false);
    assert_eq!(candidate(String::from("()()(()())())(()")), false);
    assert_eq!(candidate(String::from("()()(()())()))()")), false);
}

-----------------------------
/// brackets is a string of "(" and ")".
/// return true if every opening bracket has a corresponding closing bracket.
/// >>> correct_bracketing(String::from("("))
/// false
/// >>> correct_bracketing(String::from("()"))
/// true
/// >>> correct_bracketing(String::from("(()())"))
/// true
/// >>> correct_bracketing(String::from(")(()"))
/// false
fn correct_bracketing(brackets: String) -> bool {

    let mut left = 0;
    let mut right = 0;

    for x in brackets.chars() {
        if x == '(' {
            left += 1;
        }
        if x == ')' {
            right += 1;
        }

        if left != right {
            return false;
        }
    }

    return true;
}

fn main() {
    let candidate = correct_bracketing;
    assert_eq!(candidate(String::from("()")), true);
    assert_eq!(candidate(String::from("(()())")), true);
    assert_eq!(candidate(String::from("()()(()())()")), true);
    assert_eq!(candidate(String::from("()()((()()())())(()()(()))")), true);
    assert_eq!(candidate(String::from("((()())))")), false);
    assert_eq!(candidate(String::from(")(()")), false);
    assert_eq!(candidate(String::from("(")), false);
    assert_eq!(candidate(String::from("((((")), false);
    assert_eq!(candidate(String::from(")")), false);
    assert_eq!(candidate(String::from("(()")), false);
    assert_eq!(candidate(String::from("()()(()())())(()")), false);
    assert_eq!(candidate(String::from("()()(()())()))()")), false);
}

-----------------------------
/// brackets is a string of "(" and ")".
/// return true if every opening bracket has a corresponding closing bracket.
/// >>> correct_bracketing(String::from("("))
/// false
/// >>> correct_bracketing(String::from("()"))
/// true
/// >>> correct_bracketing(String::from("(()())"))
/// true
/// >>> correct_bracketing(String::from(")(()"))
/// false
fn correct_bracketing(brackets: String) -> bool {

    let mut stack: Vec<char> = Vec::new();
    for b in brackets.chars() {
        match b {
            '(' => stack.push(')'),
            ')' => {
                if stack.pop().unwrap() != '(' {
                    return false;
                }
            }
            _ => {}
        }
    }
    stack.len() == 0
}

fn main() {
    let candidate = correct_bracketing;
    assert_eq!(candidate(String::from("()")), true);
    assert_eq!(candidate(String::from("(()())")), true);
    assert_eq!(candidate(String::from("()()(()())()")), true);
    assert_eq!(candidate(String::from("()()((()()())())(()()(()))")), true);
    assert_eq!(candidate(String::from("((()())))")), false);
    assert_eq!(candidate(String::from(")(()")), false);
    assert_eq!(candidate(String::from("(")), false);
    assert_eq!(candidate(String::from("((((")), false);
    assert_eq!(candidate(String::from(")")), false);
    assert_eq!(candidate(String::from("(()")), false);
    assert_eq!(candidate(String::from("()()(()())())(()")), false);
    assert_eq!(candidate(String::from("()()(()())()))()")), false);
}

-----------------------------
/// brackets is a string of "(" and ")".
/// return true if every opening bracket has a corresponding closing bracket.
/// >>> correct_bracketing(String::from("("))
/// false
/// >>> correct_bracketing(String::from("()"))
/// true
/// >>> correct_bracketing(String::from("(()())"))
/// true
/// >>> correct_bracketing(String::from(")(()"))
/// false
fn correct_bracketing(brackets: String) -> bool {

    let mut stack = Vec::<char>::new();
    for c in brackets.chars() {
        match c {
            '(' => stack.push(c),
            ')' => {
                if let Some(open_paren) = stack.pop() {
                    if open_paren == '(' {
                        continue;
                    }
                }
                return false;
            }
            _ => continue,
        }
    }
    stack.is_empty()
}

fn main() {
    let candidate = correct_bracketing;
    assert_eq!(candidate(String::from("()")), true);
    assert_eq!(candidate(String::from("(()())")), true);
    assert_eq!(candidate(String::from("()()(()())()")), true);
    assert_eq!(candidate(String::from("()()((()()())())(()()(()))")), true);
    assert_eq!(candidate(String::from("((()())))")), false);
    assert_eq!(candidate(String::from(")(()")), false);
    assert_eq!(candidate(String::from("(")), false);
    assert_eq!(candidate(String::from("((((")), false);
    assert_eq!(candidate(String::from(")")), false);
    assert_eq!(candidate(String::from("(()")), false);
    assert_eq!(candidate(String::from("()()(()())())(()")), false);
    assert_eq!(candidate(String::from("()()(()())()))()")), false);
}

-----------------------------
/// brackets is a string of "(" and ")".
/// return true if every opening bracket has a corresponding closing bracket.
/// >>> correct_bracketing(String::from("("))
/// false
/// >>> correct_bracketing(String::from("()"))
/// true
/// >>> correct_bracketing(String::from("(()())"))
/// true
/// >>> correct_bracketing(String::from(")(()"))
/// false
fn correct_bracketing(brackets: String) -> bool {

    let mut stack: Vec<char> = Vec::new();
    for c in brackets.chars() {
        match c {
            '(' | '[' | '{' => stack.push(c),
            ')' | ']' | '}' => match stack.pop() {
                Some(a) => {
                    if a == '(' && c != ')' || a == '[' && c != ']' || a == '{' && c != '}' {
                        return false;
                    }
                }
                None => return false,
            },
            _ => continue,
        }
    }
    stack.is_empty()
}

fn main() {
    let candidate = correct_bracketing;
    assert_eq!(candidate(String::from("()")), true);
    assert_eq!(candidate(String::from("(()())")), true);
    assert_eq!(candidate(String::from("()()(()())()")), true);
    assert_eq!(candidate(String::from("()()((()()())())(()()(()))")), true);
    assert_eq!(candidate(String::from("((()())))")), false);
    assert_eq!(candidate(String::from(")(()")), false);
    assert_eq!(candidate(String::from("(")), false);
    assert_eq!(candidate(String::from("((((")), false);
    assert_eq!(candidate(String::from(")")), false);
    assert_eq!(candidate(String::from("(()")), false);
    assert_eq!(candidate(String::from("()()(()())())(()")), false);
    assert_eq!(candidate(String::from("()()(()())()))()")), false);
}

===============================
/// xs represent coefficients of a polynomial.
/// xs[0] + xs[1] * x + xs[2] * x^2 + ....
/// Return derivative of this polynomial in the same form.
/// >>> derivative(vec![3, 1, 2, 4, 5])
/// vec![1, 4, 12, 20]
/// >>> derivative(vec![1, 2, 3])
/// vec![2, 6]
fn derivative(xs: Vec<isize>) -> Vec<isize> {

===============================
-----------------------------
/// xs represent coefficients of a polynomial.
/// xs[0] + xs[1] * x + xs[2] * x^2 + ....
/// Return derivative of this polynomial in the same form.
/// >>> derivative(vec![3, 1, 2, 4, 5])
/// vec![1, 4, 12, 20]
/// >>> derivative(vec![1, 2, 3])
/// vec![2, 6]
fn derivative(xs: Vec<isize>) -> Vec<isize> {

    if xs.len() == 0 {
        return vec![];
    }

    let mut new_xs = vec![];
    for i in 1..xs.len() {
        new_xs.push(xs[i] * (i as isize));
    }

    new_xs
}

fn main() {
    let candidate = derivative;
    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), vec![1, 4, 12, 20]);
    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 6]);
    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);
    assert_eq!(candidate(vec![3, 2, 1, 0, 4]), vec![2, 2, 0, 16]);
    assert_eq!(candidate(vec![1]), Vec::<isize>::new());
}

-----------------------------
/// xs represent coefficients of a polynomial.
/// xs[0] + xs[1] * x + xs[2] * x^2 + ....
/// Return derivative of this polynomial in the same form.
/// >>> derivative(vec![3, 1, 2, 4, 5])
/// vec![1, 4, 12, 20]
/// >>> derivative(vec![1, 2, 3])
/// vec![2, 6]
fn derivative(xs: Vec<isize>) -> Vec<isize> {

    let mut ans = vec![];
    let len = xs.len();
    for i in 0..len {
        ans.push(xs[i] * (len - i - 1));
    }
    ans
}

fn main() {
    let candidate = derivative;
    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), vec![1, 4, 12, 20]);
    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 6]);
    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);
    assert_eq!(candidate(vec![3, 2, 1, 0, 4]), vec![2, 2, 0, 16]);
    assert_eq!(candidate(vec![1]), Vec::<isize>::new());
}

-----------------------------
/// xs represent coefficients of a polynomial.
/// xs[0] + xs[1] * x + xs[2] * x^2 + ....
/// Return derivative of this polynomial in the same form.
/// >>> derivative(vec![3, 1, 2, 4, 5])
/// vec![1, 4, 12, 20]
/// >>> derivative(vec![1, 2, 3])
/// vec![2, 6]
fn derivative(xs: Vec<isize>) -> Vec<isize> {

    let n = xs.len();
    let mut res = vec![];
    for i in 0..n {
        if i == 0 {
            res.push(xs[0]);
        } else {
            res.push(xs[i] * isize::pow(i as isize, 2) as isize);
        }
    }
    res
}

fn main() {
    let candidate = derivative;
    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), vec![1, 4, 12, 20]);
    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 6]);
    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);
    assert_eq!(candidate(vec![3, 2, 1, 0, 4]), vec![2, 2, 0, 16]);
    assert_eq!(candidate(vec![1]), Vec::<isize>::new());
}

-----------------------------
/// xs represent coefficients of a polynomial.
/// xs[0] + xs[1] * x + xs[2] * x^2 + ....
/// Return derivative of this polynomial in the same form.
/// >>> derivative(vec![3, 1, 2, 4, 5])
/// vec![1, 4, 12, 20]
/// >>> derivative(vec![1, 2, 3])
/// vec![2, 6]
fn derivative(xs: Vec<isize>) -> Vec<isize> {

    xs.into_iter()
        .enumerate()
        .filter(|(i, _)| *i != 0)
        .map(|(i, x)| x * (i as isize))
        .collect()
}

fn main() {
    let candidate = derivative;
    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), vec![1, 4, 12, 20]);
    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 6]);
    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);
    assert_eq!(candidate(vec![3, 2, 1, 0, 4]), vec![2, 2, 0, 16]);
    assert_eq!(candidate(vec![1]), Vec::<isize>::new());
}

-----------------------------
/// xs represent coefficients of a polynomial.
/// xs[0] + xs[1] * x + xs[2] * x^2 + ....
/// Return derivative of this polynomial in the same form.
/// >>> derivative(vec![3, 1, 2, 4, 5])
/// vec![1, 4, 12, 20]
/// >>> derivative(vec![1, 2, 3])
/// vec![2, 6]
fn derivative(xs: Vec<isize>) -> Vec<isize> {

    if xs.len() == 1 {
        return vec![0];
    }
    xs.iter()
        .enumerate()
        .map(|(i, x)| if i == 0 { 0 } else { x * (xs.len() as isize - i as isize) })
        .collect()
}

fn main() {
    let candidate = derivative;
    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), vec![1, 4, 12, 20]);
    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 6]);
    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);
    assert_eq!(candidate(vec![3, 2, 1, 0, 4]), vec![2, 2, 0, 16]);
    assert_eq!(candidate(vec![1]), Vec::<isize>::new());
}

===============================
/// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
/// fibfib(0) == 0
/// fibfib(1) == 0
/// fibfib(2) == 1
/// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
/// Please write a function to efficiently compute the n-th element of the fibfib number sequence.
/// >>> fibfib(1)
/// 0
/// >>> fibfib(5)
/// 4
/// >>> fibfib(8)
/// 24
fn fibfib(n: isize) -> isize {

===============================
-----------------------------
/// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
/// fibfib(0) == 0
/// fibfib(1) == 0
/// fibfib(2) == 1
/// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
/// Please write a function to efficiently compute the n-th element of the fibfib number sequence.
/// >>> fibfib(1)
/// 0
/// >>> fibfib(5)
/// 4
/// >>> fibfib(8)
/// 24
fn fibfib(n: isize) -> isize {

    // A Fibonacci number sequence is recursively defined as follows:
    // fibfib(0) = 0
    // fibfib(1) = 0
    // fibfib(2) = 1
    // fibfib(n) = fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)

    if n < 3 {
        0
    } else {
        // memoize fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
        let memoized_fibfib_n_minus_1 = fibfib(n - 1);
        let memoized_fibfib_n_minus_2 = fibfib(n - 2);
        let memoized_fibfib_n_minus_3 = fibfib(n - 3);
        // fibfib(n) = fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
        memoized_fibfib_n_minus_1 + memoized_fibfib_n_minus_2 + memoized_fibfib_n_minus_3
    }
}

fn main() {
    let candidate = fibfib;
    assert_eq!(candidate(2), 1);
    assert_eq!(candidate(1), 0);
    assert_eq!(candidate(5), 4);
    assert_eq!(candidate(8), 24);
    assert_eq!(candidate(10), 81);
    assert_eq!(candidate(12), 274);
    assert_eq!(candidate(14), 927);
}

-----------------------------
/// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
/// fibfib(0) == 0
/// fibfib(1) == 0
/// fibfib(2) == 1
/// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
/// Please write a function to efficiently compute the n-th element of the fibfib number sequence.
/// >>> fibfib(1)
/// 0
/// >>> fibfib(5)
/// 4
/// >>> fibfib(8)
/// 24
fn fibfib(n: isize) -> isize {

    if n == 0 || n == 1 {
        return 0;
    }

    let mut a: isize = 0;
    let mut b: isize = 0;
    let mut c: isize = 1;

    for _ in 2..n + 1 {
        a = b;
        b = c;
        c = a + b + c;
    }
    c
}

fn main() {
    let candidate = fibfib;
    assert_eq!(candidate(2), 1);
    assert_eq!(candidate(1), 0);
    assert_eq!(candidate(5), 4);
    assert_eq!(candidate(8), 24);
    assert_eq!(candidate(10), 81);
    assert_eq!(candidate(12), 274);
    assert_eq!(candidate(14), 927);
}

-----------------------------
/// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
/// fibfib(0) == 0
/// fibfib(1) == 0
/// fibfib(2) == 1
/// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
/// Please write a function to efficiently compute the n-th element of the fibfib number sequence.
/// >>> fibfib(1)
/// 0
/// >>> fibfib(5)
/// 4
/// >>> fibfib(8)
/// 24
fn fibfib(n: isize) -> isize {

    if n < 3 {
        return n;
    }
    let mut fib = [1, 1];
    for i in 2..(n + 1) as usize {
        fib[i % 2] = fib[(i - 1) % 2] + fib[(i - 2) % 2] + fib[(i - 3) % 2];
    }
    fib[n % 2]
}

fn main() {
    let candidate = fibfib;
    assert_eq!(candidate(2), 1);
    assert_eq!(candidate(1), 0);
    assert_eq!(candidate(5), 4);
    assert_eq!(candidate(8), 24);
    assert_eq!(candidate(10), 81);
    assert_eq!(candidate(12), 274);
    assert_eq!(candidate(14), 927);
}

-----------------------------
/// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
/// fibfib(0) == 0
/// fibfib(1) == 0
/// fibfib(2) == 1
/// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
/// Please write a function to efficiently compute the n-th element of the fibfib number sequence.
/// >>> fibfib(1)
/// 0
/// >>> fibfib(5)
/// 4
/// >>> fibfib(8)
/// 24
fn fibfib(n: isize) -> isize {

    if n <= 0 {
        return 0;
    }
    let mut f0 = 0;
    let mut f1 = 0;
    let mut f2 = 1;
    for _ in 0..n {
        f0 = f1;
        f1 = f2;
        f2 = f0 + f1 + f2;
    }
    f2
}

fn main() {
    let candidate = fibfib;
    assert_eq!(candidate(2), 1);
    assert_eq!(candidate(1), 0);
    assert_eq!(candidate(5), 4);
    assert_eq!(candidate(8), 24);
    assert_eq!(candidate(10), 81);
    assert_eq!(candidate(12), 274);
    assert_eq!(candidate(14), 927);
}

-----------------------------
/// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
/// fibfib(0) == 0
/// fibfib(1) == 0
/// fibfib(2) == 1
/// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
/// Please write a function to efficiently compute the n-th element of the fibfib number sequence.
/// >>> fibfib(1)
/// 0
/// >>> fibfib(5)
/// 4
/// >>> fibfib(8)
/// 24
fn fibfib(n: isize) -> isize {

    if n == 0 || n == 1 {
        return n;
    }

    let (mut a, mut b, mut c) = (0, 0, 1);
    for _ in 2..=n {
        a = b;
        b = c;
        c = a + b + c;
    }

    return c;
}

fn main() {
    let candidate = fibfib;
    assert_eq!(candidate(2), 1);
    assert_eq!(candidate(1), 0);
    assert_eq!(candidate(5), 4);
    assert_eq!(candidate(8), 24);
    assert_eq!(candidate(10), 81);
    assert_eq!(candidate(12), 274);
    assert_eq!(candidate(14), 927);
}

===============================
/// Write a function vowels_count which takes a string representing
/// a word as input and returns the number of vowels in the string.
/// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
/// vowel, but only when it is at the end of the given word.
/// Example:
/// >>> vowels_count(String::from("abcde"))
/// 2
/// >>> vowels_count(String::from("ACEDY"))
/// 3
fn vowels_count(s: String) -> isize {

===============================
-----------------------------
/// Write a function vowels_count which takes a string representing
/// a word as input and returns the number of vowels in the string.
/// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
/// vowel, but only when it is at the end of the given word.
/// Example:
/// >>> vowels_count(String::from("abcde"))
/// 2
/// >>> vowels_count(String::from("ACEDY"))
/// 3
fn vowels_count(s: String) -> isize {

    // Return the number of vowels in s.
    let mut count = 0;
    for c in s.chars() {
        match c {
            'a' | 'e' | 'i' | 'o' | 'u' => {
                count += 1;
            }
            'y' => {
                if !s.contains('y') {
                    count += 1;
                }
            }
            _ => (),
        }
    }
    count
}

fn main() {
    let candidate = vowels_count;
    assert_eq!(candidate(String::from("abcde")), 2);
    assert_eq!(candidate(String::from("Alone")), 3);
    assert_eq!(candidate(String::from("key")), 2);
    assert_eq!(candidate(String::from("bye")), 1);
    assert_eq!(candidate(String::from("keY")), 2);
    assert_eq!(candidate(String::from("bYe")), 1);
    assert_eq!(candidate(String::from("ACEDY")), 3);
}

-----------------------------
/// Write a function vowels_count which takes a string representing
/// a word as input and returns the number of vowels in the string.
/// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
/// vowel, but only when it is at the end of the given word.
/// Example:
/// >>> vowels_count(String::from("abcde"))
/// 2
/// >>> vowels_count(String::from("ACEDY"))
/// 3
fn vowels_count(s: String) -> isize {

    let mut vowels = 0;
    for c in s.chars() {
        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {
            vowels += 1;
        }
        if c == 'y' {
            let mut iter = s.chars();
            iter.next();
            if iter.last() == Some(&'a') || iter.last() == Some(&'e') || iter.last() == Some(&'i') || iter.last() == Some(&'o') || iter.last() == Some(&'u') {
                vowels += 1;
            }
        }
    }
    vowels as isize
}

fn main() {
    let candidate = vowels_count;
    assert_eq!(candidate(String::from("abcde")), 2);
    assert_eq!(candidate(String::from("Alone")), 3);
    assert_eq!(candidate(String::from("key")), 2);
    assert_eq!(candidate(String::from("bye")), 1);
    assert_eq!(candidate(String::from("keY")), 2);
    assert_eq!(candidate(String::from("bYe")), 1);
    assert_eq!(candidate(String::from("ACEDY")), 3);
}

-----------------------------
/// Write a function vowels_count which takes a string representing
/// a word as input and returns the number of vowels in the string.
/// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
/// vowel, but only when it is at the end of the given word.
/// Example:
/// >>> vowels_count(String::from("abcde"))
/// 2
/// >>> vowels_count(String::from("ACEDY"))
/// 3
fn vowels_count(s: String) -> isize {

    let mut cnt = 0;
    let mut is_prev_vowel = false;
    for c in s.chars() {
        if c.is_ascii_alphabetic() {
            if is_vowel(c, is_prev_vowel) {
                cnt += 1;
            }
            is_prev_vowel = false;
        } else {
            is_prev_vowel = false;
        }
    }
    cnt
}

fn main() {
    let candidate = vowels_count;
    assert_eq!(candidate(String::from("abcde")), 2);
    assert_eq!(candidate(String::from("Alone")), 3);
    assert_eq!(candidate(String::from("key")), 2);
    assert_eq!(candidate(String::from("bye")), 1);
    assert_eq!(candidate(String::from("keY")), 2);
    assert_eq!(candidate(String::from("bYe")), 1);
    assert_eq!(candidate(String::from("ACEDY")), 3);
}

-----------------------------
/// Write a function vowels_count which takes a string representing
/// a word as input and returns the number of vowels in the string.
/// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
/// vowel, but only when it is at the end of the given word.
/// Example:
/// >>> vowels_count(String::from("abcde"))
/// 2
/// >>> vowels_count(String::from("ACEDY"))
/// 3
fn vowels_count(s: String) -> isize {

    let mut vowel_count = 0;
    let mut y_found = false;
    for chr in s.chars() {
        if y_found && chr == 'y' {
            vowel_count += 1;
            y_found = false;
        } else if chr == 'a' || chr == 'e' || chr == 'i' || chr == 'o' || chr == 'u' {
            vowel_count += 1;
        } else if chr == 'y' {
            y_found = true;
        }
    }
    vowel_count
}

fn main() {
    let candidate = vowels_count;
    assert_eq!(candidate(String::from("abcde")), 2);
    assert_eq!(candidate(String::from("Alone")), 3);
    assert_eq!(candidate(String::from("key")), 2);
    assert_eq!(candidate(String::from("bye")), 1);
    assert_eq!(candidate(String::from("keY")), 2);
    assert_eq!(candidate(String::from("bYe")), 1);
    assert_eq!(candidate(String::from("ACEDY")), 3);
}

-----------------------------
/// Write a function vowels_count which takes a string representing
/// a word as input and returns the number of vowels in the string.
/// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
/// vowel, but only when it is at the end of the given word.
/// Example:
/// >>> vowels_count(String::from("abcde"))
/// 2
/// >>> vowels_count(String::from("ACEDY"))
/// 3
fn vowels_count(s: String) -> isize {

    let mut vowels = 0;
    for c in s.chars() {
        match c {
            'a' | 'e' | 'i' | 'o' | 'u' | 'y' => vowels += 1,
            _ => {},
        }
    }
    vowels
}

fn main() {
    let candidate = vowels_count;
    assert_eq!(candidate(String::from("abcde")), 2);
    assert_eq!(candidate(String::from("Alone")), 3);
    assert_eq!(candidate(String::from("key")), 2);
    assert_eq!(candidate(String::from("bye")), 1);
    assert_eq!(candidate(String::from("keY")), 2);
    assert_eq!(candidate(String::from("bYe")), 1);
    assert_eq!(candidate(String::from("ACEDY")), 3);
}

===============================
/// Circular shift the digits of the integer x, shift the digits right by shift
/// and return the result as a string.
/// If shift > number of digits, return digits reversed.
/// >>> circular_shift(12, 1)
/// String::from("21")
/// >>> circular_shift(12, 2)
/// String::from("12")
fn circular_shift(x: isize, shift: isize) -> String {

===============================
-----------------------------
/// Circular shift the digits of the integer x, shift the digits right by shift
/// and return the result as a string.
/// If shift > number of digits, return digits reversed.
/// >>> circular_shift(12, 1)
/// String::from("21")
/// >>> circular_shift(12, 2)
/// String::from("12")
fn circular_shift(x: isize, shift: isize) -> String {

    // Create a string from the digits of the integer.
    let x_string: String = x.to_string();

    // Get the length of the string created from the integer.
    let length = x_string.len();

    // Shift the string to the right by shift.
    // If shift is greater than the number of digits in the string,
    // reverse the string and return it.
    if shift > length as isize {
        x_string.chars()
            .rev()
            .collect::<String>()
    } else {
        let shifted_string = x_string.chars()
            .skip(shift as usize)
            .take(length - shift as usize)
            .collect::<String>()
            .to_owned() + &x_string.chars()
            .take(shift as usize)
            .collect::<String>();

        shifted_string
    }
}

fn main() {
    let candidate = circular_shift;
    assert_eq!(candidate(100, 2), String::from("001"));
    assert_eq!(candidate(12, 2), String::from("12"));
    assert_eq!(candidate(97, 8), String::from("79"));
    assert_eq!(candidate(12, 1), String::from("21"));
    assert_eq!(candidate(11, 101), String::from("11"));
}

-----------------------------
/// Circular shift the digits of the integer x, shift the digits right by shift
/// and return the result as a string.
/// If shift > number of digits, return digits reversed.
/// >>> circular_shift(12, 1)
/// String::from("21")
/// >>> circular_shift(12, 2)
/// String::from("12")
fn circular_shift(x: isize, shift: isize) -> String {

    if shift <= 0 {
        return x.to_string();
    }
    let mut res = x.to_string();
    let mut shifted_res = String::from("");
    for i in 0..shift {
        shifted_res.push(res.chars().nth(i as usize).unwrap());
    }
    shifted_res.push_str(&res[shift as usize..]);
    shifted_res.push_str(&res[0..shift as usize]);
    shifted_res
}

fn main() {
    let candidate = circular_shift;
    assert_eq!(candidate(100, 2), String::from("001"));
    assert_eq!(candidate(12, 2), String::from("12"));
    assert_eq!(candidate(97, 8), String::from("79"));
    assert_eq!(candidate(12, 1), String::from("21"));
    assert_eq!(candidate(11, 101), String::from("11"));
}

-----------------------------
/// Circular shift the digits of the integer x, shift the digits right by shift
/// and return the result as a string.
/// If shift > number of digits, return digits reversed.
/// >>> circular_shift(12, 1)
/// String::from("21")
/// >>> circular_shift(12, 2)
/// String::from("12")
fn circular_shift(x: isize, shift: isize) -> String {

    let mut n_shifted = x % 10;
    let mut x_string = x.to_string();
    let mut x_string_len = x_string.len();
    let mut x_string_len_isize = x_string_len as isize;

    while x_string_len_isize > 1 {
        let first_digit = x_string.chars().nth(0).unwrap().to_digit(10).unwrap();
        let second_digit = x_string.chars().nth(1).unwrap().to_digit(10).unwrap();
        x_string = format!("{}", second_digit).to_string() + &format!("{}", first_digit);
        x_string_len_isize -= 1;
        x_string_len = x_string.len();
        n_shifted = first_digit;
    }

    if shift < x_string_len_isize {
        let shifted_first_digit = x_string.chars().nth(shift as usize).unwrap().to_digit(10).unwrap();
        let shifted_second_digit = x_string.chars().nth((shift + 1) as usize).unwrap().to_digit(10).unwrap();
        x_string = format!("{}", shifted_first_digit).to_string() + &format!("{}", shifted_second_digit);
    } else {
        x_string = x_string.chars().rev().collect::<String>();
    }

    format!("{}", n_shifted) + &x_string
}

fn main() {
    let candidate = circular_shift;
    assert_eq!(candidate(100, 2), String::from("001"));
    assert_eq!(candidate(12, 2), String::from("12"));
    assert_eq!(candidate(97, 8), String::from("79"));
    assert_eq!(candidate(12, 1), String::from("21"));
    assert_eq!(candidate(11, 101), String::from("11"));
}

-----------------------------
/// Circular shift the digits of the integer x, shift the digits right by shift
/// and return the result as a string.
/// If shift > number of digits, return digits reversed.
/// >>> circular_shift(12, 1)
/// String::from("21")
/// >>> circular_shift(12, 2)
/// String::from("12")
fn circular_shift(x: isize, shift: isize) -> String {

    let mut string = x.to_string();
    let length = string.len();
    if length == 1 {
        return string;
    }

    if shift >= length as isize {
        return string.chars().rev().collect();
    }

    let new_string = string.chars().skip(shift as usize).collect::<String>();
    return format!("{}{}", new_string, string[..shift as usize].to_string());
}

fn main() {
    let candidate = circular_shift;
    assert_eq!(candidate(100, 2), String::from("001"));
    assert_eq!(candidate(12, 2), String::from("12"));
    assert_eq!(candidate(97, 8), String::from("79"));
    assert_eq!(candidate(12, 1), String::from("21"));
    assert_eq!(candidate(11, 101), String::from("11"));
}

-----------------------------
/// Circular shift the digits of the integer x, shift the digits right by shift
/// and return the result as a string.
/// If shift > number of digits, return digits reversed.
/// >>> circular_shift(12, 1)
/// String::from("21")
/// >>> circular_shift(12, 2)
/// String::from("12")
fn circular_shift(x: isize, shift: isize) -> String {

    let x_str = x.to_string();
    let n = x_str.len();
    let mut res = String::new();
    let n_shift = n as isize - shift;
    if n_shift < 0 {
        for i in 0..n as isize {
            res.push(x_str.chars().nth(n as usize - (i + 1) as usize).unwrap());
        }
    } else {
        for i in 0..n as isize {
            res.push(x_str.chars().nth(i + n_shift as usize).unwrap());
        }
    }
    res
}

fn main() {
    let candidate = circular_shift;
    assert_eq!(candidate(100, 2), String::from("001"));
    assert_eq!(candidate(12, 2), String::from("12"));
    assert_eq!(candidate(97, 8), String::from("79"));
    assert_eq!(candidate(12, 1), String::from("21"));
    assert_eq!(candidate(11, 101), String::from("11"));
}

===============================
/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(String::from(""))
/// 0
/// >>> digitSum(String::from("abAB"))
/// 131
/// >>> digitSum(String::from("abcCd"))
/// 67
/// >>> digitSum(String::from("helloE"))
/// 69
/// >>> digitSum(String::from("woArBld"))
/// 131
/// >>> digitSum(String::from("aAaaaXa"))
/// 153
fn digitSum(s: String) -> isize {

===============================
-----------------------------
/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(String::from(""))
/// 0
/// >>> digitSum(String::from("abAB"))
/// 131
/// >>> digitSum(String::from("abcCd"))
/// 67
/// >>> digitSum(String::from("helloE"))
/// 69
/// >>> digitSum(String::from("woArBld"))
/// 131
/// >>> digitSum(String::from("aAaaaXa"))
/// 153
fn digitSum(s: String) -> isize {

    let mut sum: isize = 0;
    for c in s.chars() {
        if c.is_uppercase() {
            sum += c as isize;
        }
    }
    sum
}

fn main() {
    let candidate = digitSum;
    assert_eq!(candidate(String::from("")), 0);
    assert_eq!(candidate(String::from("abAB")), 131);
    assert_eq!(candidate(String::from("abcCd")), 67);
    assert_eq!(candidate(String::from("helloE")), 69);
    assert_eq!(candidate(String::from("woArBld")), 131);
    assert_eq!(candidate(String::from("aAaaaXa")), 153);
    assert_eq!(candidate(String::from(" How are yOu?")), 151);
    assert_eq!(candidate(String::from("You arE Very Smart")), 327);
}

-----------------------------
/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(String::from(""))
/// 0
/// >>> digitSum(String::from("abAB"))
/// 131
/// >>> digitSum(String::from("abcCd"))
/// 67
/// >>> digitSum(String::from("helloE"))
/// 69
/// >>> digitSum(String::from("woArBld"))
/// 131
/// >>> digitSum(String::from("aAaaaXa"))
/// 153
fn digitSum(s: String) -> isize {

    s.chars()
        .filter_map(|c| {
            if c.is_uppercase() {
                Some(c as isize)
            } else {
                None
            }
        })
        .sum::<isize>()
}

fn main() {
    let candidate = digitSum;
    assert_eq!(candidate(String::from("")), 0);
    assert_eq!(candidate(String::from("abAB")), 131);
    assert_eq!(candidate(String::from("abcCd")), 67);
    assert_eq!(candidate(String::from("helloE")), 69);
    assert_eq!(candidate(String::from("woArBld")), 131);
    assert_eq!(candidate(String::from("aAaaaXa")), 153);
    assert_eq!(candidate(String::from(" How are yOu?")), 151);
    assert_eq!(candidate(String::from("You arE Very Smart")), 327);
}

-----------------------------
/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(String::from(""))
/// 0
/// >>> digitSum(String::from("abAB"))
/// 131
/// >>> digitSum(String::from("abcCd"))
/// 67
/// >>> digitSum(String::from("helloE"))
/// 69
/// >>> digitSum(String::from("woArBld"))
/// 131
/// >>> digitSum(String::from("aAaaaXa"))
/// 153
fn digitSum(s: String) -> isize {

    let mut sum: isize = 0;
    for c in s.chars() {
        let c_num = c as isize;
        if c_num >= 65 && c_num <= 90 {
            sum += c_num;
        }
    }
    sum
}

fn main() {
    let candidate = digitSum;
    assert_eq!(candidate(String::from("")), 0);
    assert_eq!(candidate(String::from("abAB")), 131);
    assert_eq!(candidate(String::from("abcCd")), 67);
    assert_eq!(candidate(String::from("helloE")), 69);
    assert_eq!(candidate(String::from("woArBld")), 131);
    assert_eq!(candidate(String::from("aAaaaXa")), 153);
    assert_eq!(candidate(String::from(" How are yOu?")), 151);
    assert_eq!(candidate(String::from("You arE Very Smart")), 327);
}

-----------------------------
/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(String::from(""))
/// 0
/// >>> digitSum(String::from("abAB"))
/// 131
/// >>> digitSum(String::from("abcCd"))
/// 67
/// >>> digitSum(String::from("helloE"))
/// 69
/// >>> digitSum(String::from("woArBld"))
/// 131
/// >>> digitSum(String::from("aAaaaXa"))
/// 153
fn digitSum(s: String) -> isize {

    let mut sum: isize = 0;
    for c in s.chars() {
        if c.is_uppercase() {
            sum += c as isize;
        }
    }
    sum
}

fn main() {
    let candidate = digitSum;
    assert_eq!(candidate(String::from("")), 0);
    assert_eq!(candidate(String::from("abAB")), 131);
    assert_eq!(candidate(String::from("abcCd")), 67);
    assert_eq!(candidate(String::from("helloE")), 69);
    assert_eq!(candidate(String::from("woArBld")), 131);
    assert_eq!(candidate(String::from("aAaaaXa")), 153);
    assert_eq!(candidate(String::from(" How are yOu?")), 151);
    assert_eq!(candidate(String::from("You arE Very Smart")), 327);
}

-----------------------------
/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(String::from(""))
/// 0
/// >>> digitSum(String::from("abAB"))
/// 131
/// >>> digitSum(String::from("abcCd"))
/// 67
/// >>> digitSum(String::from("helloE"))
/// 69
/// >>> digitSum(String::from("woArBld"))
/// 131
/// >>> digitSum(String::from("aAaaaXa"))
/// 153
fn digitSum(s: String) -> isize {

    s.to_uppercase()
        .chars()
        .map(|c| c as u8)
        .sum()
}

fn main() {
    let candidate = digitSum;
    assert_eq!(candidate(String::from("")), 0);
    assert_eq!(candidate(String::from("abAB")), 131);
    assert_eq!(candidate(String::from("abcCd")), 67);
    assert_eq!(candidate(String::from("helloE")), 69);
    assert_eq!(candidate(String::from("woArBld")), 131);
    assert_eq!(candidate(String::from("aAaaaXa")), 153);
    assert_eq!(candidate(String::from(" How are yOu?")), 151);
    assert_eq!(candidate(String::from("You arE Very Smart")), 327);
}

===============================
/// In this task, you will be given a string that represents a number of apples and oranges 
/// that are distributed in a basket of fruit this basket contains 
/// apples, oranges, and mango fruits. Given the string that represents the total number of 
/// the oranges and apples and an integer that represent the total number of the fruits 
/// in the basket return the number of the mango fruits in the basket.
/// for examble:
/// >>> fruit_distribution(String::from("5 apples and 6 oranges"), 19)
/// 8
/// >>> fruit_distribution(String::from("0 apples and 1 oranges"), 3)
/// 2
/// >>> fruit_distribution(String::from("2 apples and 3 oranges"), 100)
/// 95
/// >>> fruit_distribution(String::from("100 apples and 1 oranges"), 120)
/// 19
fn fruit_distribution(s: String, n: isize) -> isize {

===============================
-----------------------------
/// In this task, you will be given a string that represents a number of apples and oranges 
/// that are distributed in a basket of fruit this basket contains 
/// apples, oranges, and mango fruits. Given the string that represents the total number of 
/// the oranges and apples and an integer that represent the total number of the fruits 
/// in the basket return the number of the mango fruits in the basket.
/// for examble:
/// >>> fruit_distribution(String::from("5 apples and 6 oranges"), 19)
/// 8
/// >>> fruit_distribution(String::from("0 apples and 1 oranges"), 3)
/// 2
/// >>> fruit_distribution(String::from("2 apples and 3 oranges"), 100)
/// 95
/// >>> fruit_distribution(String::from("100 apples and 1 oranges"), 120)
/// 19
fn fruit_distribution(s: String, n: isize) -> isize {

    let mut s: Vec<String> = s.split_whitespace()
        .map(|x| x.to_string())
        .collect();
    let number_of_fruits = s.pop().unwrap().parse::<isize>().unwrap();
    let number_of_fruits = number_of_fruits as f64;
    let number_of_apples = s.pop().unwrap().parse::<isize>().unwrap();
    let number_of_apples = number_of_apples as f64;
    let number_of_oranges = s.pop().unwrap().parse::<isize>().unwrap();
    let number_of_oranges = number_of_oranges as f64;
    let number_of_mango_fruits = number_of_fruits - (number_of_apples + number_of_oranges);
    number_of_mango_fruits
}

fn main() {
    let candidate = fruit_distribution;
    assert_eq!(candidate(String::from("5 apples and 6 oranges"), 19), 8);
    assert_eq!(candidate(String::from("5 apples and 6 oranges"), 21), 10);
    assert_eq!(candidate(String::from("0 apples and 1 oranges"), 3), 2);
    assert_eq!(candidate(String::from("1 apples and 0 oranges"), 3), 2);
    assert_eq!(candidate(String::from("2 apples and 3 oranges"), 100), 95);
    assert_eq!(candidate(String::from("2 apples and 3 oranges"), 5), 0);
    assert_eq!(candidate(String::from("1 apples and 100 oranges"), 120), 19);
}

-----------------------------
/// In this task, you will be given a string that represents a number of apples and oranges 
/// that are distributed in a basket of fruit this basket contains 
/// apples, oranges, and mango fruits. Given the string that represents the total number of 
/// the oranges and apples and an integer that represent the total number of the fruits 
/// in the basket return the number of the mango fruits in the basket.
/// for examble:
/// >>> fruit_distribution(String::from("5 apples and 6 oranges"), 19)
/// 8
/// >>> fruit_distribution(String::from("0 apples and 1 oranges"), 3)
/// 2
/// >>> fruit_distribution(String::from("2 apples and 3 oranges"), 100)
/// 95
/// >>> fruit_distribution(String::from("100 apples and 1 oranges"), 120)
/// 19
fn fruit_distribution(s: String, n: isize) -> isize {

    let mut apples: isize = 0;
    let mut oranges: isize = 0;
    for x in s.split(" and ") {
        if x.contains("apples") {
            apples = x.split(" ").nth(0).unwrap().parse::<isize>().unwrap();
        }
        if x.contains("oranges") {
            oranges = x.split(" ").nth(0).unwrap().parse::<isize>().unwrap();
        }
    }
    return apples * 2 + oranges * 2 - n;
}

fn main() {
    let candidate = fruit_distribution;
    assert_eq!(candidate(String::from("5 apples and 6 oranges"), 19), 8);
    assert_eq!(candidate(String::from("5 apples and 6 oranges"), 21), 10);
    assert_eq!(candidate(String::from("0 apples and 1 oranges"), 3), 2);
    assert_eq!(candidate(String::from("1 apples and 0 oranges"), 3), 2);
    assert_eq!(candidate(String::from("2 apples and 3 oranges"), 100), 95);
    assert_eq!(candidate(String::from("2 apples and 3 oranges"), 5), 0);
    assert_eq!(candidate(String::from("1 apples and 100 oranges"), 120), 19);
}

-----------------------------
/// In this task, you will be given a string that represents a number of apples and oranges 
/// that are distributed in a basket of fruit this basket contains 
/// apples, oranges, and mango fruits. Given the string that represents the total number of 
/// the oranges and apples and an integer that represent the total number of the fruits 
/// in the basket return the number of the mango fruits in the basket.
/// for examble:
/// >>> fruit_distribution(String::from("5 apples and 6 oranges"), 19)
/// 8
/// >>> fruit_distribution(String::from("0 apples and 1 oranges"), 3)
/// 2
/// >>> fruit_distribution(String::from("2 apples and 3 oranges"), 100)
/// 95
/// >>> fruit_distribution(String::from("100 apples and 1 oranges"), 120)
/// 19
fn fruit_distribution(s: String, n: isize) -> isize {


    let mut x:isize = 0;
    let mut y:isize = 0;
    let mut z:isize = 0;

    let mut n1: isize = 0;
    let mut n2: isize = 0;

    for c in s.chars() {
        if c.to_string() == "0".to_string() {
            x += 1;
        } else if c.to_string() == "1".to_string() {
            y += 1;
        } else if c.to_string() == "2".to_string() {
            z += 1;
        } else if c.to_string() == "3".to_string() {
            z += 1;
            y += 1;
        } else if c.to_string() == "4".to_string() {
            z += 1;
            y += 1;
            x += 1;
        } else if c.to_string() == "5".to_string() {
            z += 1;
            y += 1;
            x += 1;
        } else if c.to_string() == "6".to_string() {
            z += 1;
            y += 1;
            x += 1;
        } else if c.to_string() == "7".to_string() {
            z += 1;
            y += 1;
            x += 1;
        } else if c.to_string() == "8".to_string() {
            z += 1;
            y += 1;
            x += 1;
        } else if c.to_string() == "9".to_string() {
            z += 1;
            y += 1;
            x += 1;
        } else if c.to_string() == "and".to_string() {
            continue;
        }
    }
    if x == 0 {
        n1 = y + z;
    } else if x == 1 {
        n1 = y + z - 1;
    } else if x == 2 {
        n1 = y + z - 2;
    } else if x == 3 {
        n1 = y + z - 3;
    } else if x == 4 {
        n1 = y + z - 4;
    } else if x == 5 {
        n1 = y + z - 5;
    } else if x == 6 {
        n1 = y + z - 6;
    } else if x == 7 {
        n1 = y + z - 7;
    } else if x == 8 {
        n1 = y + z - 8;
    } else if x == 9 {
        n1 = y + z - 9;
    } else if x == 10 {
        n1 = y + z - 10;
    }
    if y == 0 {
        n2 = x + z;
    } else if y == 1 {
        n2 = x + z - 1;
    } else if y == 2 {
        n2 = x + z - 2;
    } else if y == 3 {
        n2
}

fn main() {
    let candidate = fruit_distribution;
    assert_eq!(candidate(String::from("5 apples and 6 oranges"), 19), 8);
    assert_eq!(candidate(String::from("5 apples and 6 oranges"), 21), 10);
    assert_eq!(candidate(String::from("0 apples and 1 oranges"), 3), 2);
    assert_eq!(candidate(String::from("1 apples and 0 oranges"), 3), 2);
    assert_eq!(candidate(String::from("2 apples and 3 oranges"), 100), 95);
    assert_eq!(candidate(String::from("2 apples and 3 oranges"), 5), 0);
    assert_eq!(candidate(String::from("1 apples and 100 oranges"), 120), 19);
}

-----------------------------
/// In this task, you will be given a string that represents a number of apples and oranges 
/// that are distributed in a basket of fruit this basket contains 
/// apples, oranges, and mango fruits. Given the string that represents the total number of 
/// the oranges and apples and an integer that represent the total number of the fruits 
/// in the basket return the number of the mango fruits in the basket.
/// for examble:
/// >>> fruit_distribution(String::from("5 apples and 6 oranges"), 19)
/// 8
/// >>> fruit_distribution(String::from("0 apples and 1 oranges"), 3)
/// 2
/// >>> fruit_distribution(String::from("2 apples and 3 oranges"), 100)
/// 95
/// >>> fruit_distribution(String::from("100 apples and 1 oranges"), 120)
/// 19
fn fruit_distribution(s: String, n: isize) -> isize {

    if n <= 0 {
        return 0;
    }
    let mut apples = 0;
    let mut oranges = 0;
    let mut mango = 0;
    let mut count = 0;
    let mut flag = false;
    let mut i = 0;
    let n: isize = s.len() as isize;
    if n < 3 {
        return 0;
    }
    while i < n - 1 {
        if flag {
            break;
        }
        if s.chars().nth(i).unwrap() == ' ' {
            flag = true;
        }
        else if i < n - 3 && flag {
            apples = s.chars().nth(i).unwrap() as isize - '0' as isize;
            oranges = s.chars().nth(i + 2).unwrap() as isize - '0' as isize;
            if apples + oranges == n - 3 {
                mango = s.chars().nth(i + 1).unwrap() as isize - '0' as isize;
                count = count + mango;
            }
            i = i + 3;
        }
        else {
            i = i + 1;
        }
    }
    count
}

fn main() {
    let candidate = fruit_distribution;
    assert_eq!(candidate(String::from("5 apples and 6 oranges"), 19), 8);
    assert_eq!(candidate(String::from("5 apples and 6 oranges"), 21), 10);
    assert_eq!(candidate(String::from("0 apples and 1 oranges"), 3), 2);
    assert_eq!(candidate(String::from("1 apples and 0 oranges"), 3), 2);
    assert_eq!(candidate(String::from("2 apples and 3 oranges"), 100), 95);
    assert_eq!(candidate(String::from("2 apples and 3 oranges"), 5), 0);
    assert_eq!(candidate(String::from("1 apples and 100 oranges"), 120), 19);
}

-----------------------------
/// In this task, you will be given a string that represents a number of apples and oranges 
/// that are distributed in a basket of fruit this basket contains 
/// apples, oranges, and mango fruits. Given the string that represents the total number of 
/// the oranges and apples and an integer that represent the total number of the fruits 
/// in the basket return the number of the mango fruits in the basket.
/// for examble:
/// >>> fruit_distribution(String::from("5 apples and 6 oranges"), 19)
/// 8
/// >>> fruit_distribution(String::from("0 apples and 1 oranges"), 3)
/// 2
/// >>> fruit_distribution(String::from("2 apples and 3 oranges"), 100)
/// 95
/// >>> fruit_distribution(String::from("100 apples and 1 oranges"), 120)
/// 19
fn fruit_distribution(s: String, n: isize) -> isize {


    let mut apples = String::from("apples");
    let mut oranges = String::from("oranges");
    let mut apple_count = 0;
    let mut orange_count = 0;

    //Split the string of the fruits into a vector of strings
    let s_split: Vec<&str> = s.split(" ").collect();

    //Get the number of the apples and oranges
    for i in 0..s_split.len() {
        if s_split[i] == "apples" {
            apple_count = s_split[i + 1].parse::<isize>().unwrap();
        } else if s_split[i] == "oranges" {
            orange_count = s_split[i + 1].parse::<isize>().unwrap();
        }
    }

    //Calculate the number of the mangoes
    let mango_count: isize = n - apple_count - orange_count;

    mango_count
}

fn main() {
    let candidate = fruit_distribution;
    assert_eq!(candidate(String::from("5 apples and 6 oranges"), 19), 8);
    assert_eq!(candidate(String::from("5 apples and 6 oranges"), 21), 10);
    assert_eq!(candidate(String::from("0 apples and 1 oranges"), 3), 2);
    assert_eq!(candidate(String::from("1 apples and 0 oranges"), 3), 2);
    assert_eq!(candidate(String::from("2 apples and 3 oranges"), 100), 95);
    assert_eq!(candidate(String::from("2 apples and 3 oranges"), 5), 0);
    assert_eq!(candidate(String::from("1 apples and 100 oranges"), 120), 19);
}

===============================
/// "Given a vector representing a branch of a tree that has non-negative integer nodes
/// your task is to pluck one of the nodes and return it.
/// The plucked node should be the node with the smallest even value.
/// If multiple nodes with the same smallest even value are found return the node that has smallest index.
/// The plucked node should be returned in a vector, [ smalest_value, its index ],
/// If there are no even values or the given vector is empty, return [].
/// Example 1:
/// >>> pluck(vec![4, 2, 3])
/// vec![2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 2:
/// >>> pluck(vec![1, 2, 3])
/// vec![2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 3:
/// >>> pluck(vec![])
/// Vec::<isize>::new()
/// Example 4:
/// >>> pluck(vec![5, 0, 3, 0, 4, 2])
/// vec![0, 1]
/// Explanation: 0 is the smallest value, but  there are two zeros,
/// so we will choose the first zero, which has the smallest index.
/// Constraints:
/// * 1 <= nodes.length <= 10000
/// * 0 <= node.value
fn pluck(arr: Vec<isize>) -> Vec<isize> {

===============================
-----------------------------
/// "Given a vector representing a branch of a tree that has non-negative integer nodes
/// your task is to pluck one of the nodes and return it.
/// The plucked node should be the node with the smallest even value.
/// If multiple nodes with the same smallest even value are found return the node that has smallest index.
/// The plucked node should be returned in a vector, [ smalest_value, its index ],
/// If there are no even values or the given vector is empty, return [].
/// Example 1:
/// >>> pluck(vec![4, 2, 3])
/// vec![2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 2:
/// >>> pluck(vec![1, 2, 3])
/// vec![2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 3:
/// >>> pluck(vec![])
/// Vec::<isize>::new()
/// Example 4:
/// >>> pluck(vec![5, 0, 3, 0, 4, 2])
/// vec![0, 1]
/// Explanation: 0 is the smallest value, but  there are two zeros,
/// so we will choose the first zero, which has the smallest index.
/// Constraints:
/// * 1 <= nodes.length <= 10000
/// * 0 <= node.value
fn pluck(arr: Vec<isize>) -> Vec<isize> {

    // return a vector of size 2: first is the value, second is the index
    // 1. sort the vector
    // 2. reverse the vector so smallest value is at the front
    // 3. loop through the vector, if the value is even, return the value and its index.

    // sort the vector
    arr.sort();
    arr.reverse();

    let mut value: isize = -1;
    let mut index: usize = 0;

    // loop through the vector, if the value is even, return the value and its index.
    for (i, v) in arr.iter().enumerate() {
        if *v % 2 == 0 {
            value = *v;
            index = i;
            break;
        }
    }

    // return a vector of size 2: first is the value, second is the index
    // if the loop ended without returning, return an empty vector.
    if value == -1 {
        return Vec::new();
    } else {
        return vec![value, index as isize];
    }
}

fn main() {
    let candidate = pluck;
    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);
    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);
    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);
    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);
    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);
    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());
}

-----------------------------
/// "Given a vector representing a branch of a tree that has non-negative integer nodes
/// your task is to pluck one of the nodes and return it.
/// The plucked node should be the node with the smallest even value.
/// If multiple nodes with the same smallest even value are found return the node that has smallest index.
/// The plucked node should be returned in a vector, [ smalest_value, its index ],
/// If there are no even values or the given vector is empty, return [].
/// Example 1:
/// >>> pluck(vec![4, 2, 3])
/// vec![2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 2:
/// >>> pluck(vec![1, 2, 3])
/// vec![2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 3:
/// >>> pluck(vec![])
/// Vec::<isize>::new()
/// Example 4:
/// >>> pluck(vec![5, 0, 3, 0, 4, 2])
/// vec![0, 1]
/// Explanation: 0 is the smallest value, but  there are two zeros,
/// so we will choose the first zero, which has the smallest index.
/// Constraints:
/// * 1 <= nodes.length <= 10000
/// * 0 <= node.value
fn pluck(arr: Vec<isize>) -> Vec<isize> {

    if arr.len() == 0 {
        return vec![];
    }
    let mut res = vec![arr[0], 0];
    let mut min = 0;
    for i in 0..arr.len() {
        if arr[i] % 2 == 0 {
            if arr[i] < arr[min] {
                min = i;
            } else if arr[i] == arr[min] {
                if i < res[1] {
                    res[0] = arr[i];
                    res[1] = i;
                }
            }
        }
    }
    res
}

fn main() {
    let candidate = pluck;
    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);
    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);
    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);
    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);
    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);
    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());
}

-----------------------------
/// "Given a vector representing a branch of a tree that has non-negative integer nodes
/// your task is to pluck one of the nodes and return it.
/// The plucked node should be the node with the smallest even value.
/// If multiple nodes with the same smallest even value are found return the node that has smallest index.
/// The plucked node should be returned in a vector, [ smalest_value, its index ],
/// If there are no even values or the given vector is empty, return [].
/// Example 1:
/// >>> pluck(vec![4, 2, 3])
/// vec![2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 2:
/// >>> pluck(vec![1, 2, 3])
/// vec![2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 3:
/// >>> pluck(vec![])
/// Vec::<isize>::new()
/// Example 4:
/// >>> pluck(vec![5, 0, 3, 0, 4, 2])
/// vec![0, 1]
/// Explanation: 0 is the smallest value, but  there are two zeros,
/// so we will choose the first zero, which has the smallest index.
/// Constraints:
/// * 1 <= nodes.length <= 10000
/// * 0 <= node.value
fn pluck(arr: Vec<isize>) -> Vec<isize> {

    if arr.is_empty() {
        return vec![];
    }
    let mut min_even_index = 0;
    for i in 0..arr.len() {
        let current = arr[i];
        if current % 2 == 0
            && (min_even_index == 0
                || arr[min_even_index] > current
                || (arr[min_even_index] == current && i < min_even_index))
        {
            min_even_index = i;
        }
    }
    if min_even_index == 0 {
        vec![]
    } else {
        vec![arr[min_even_index], min_even_index as isize]
    }
}

fn main() {
    let candidate = pluck;
    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);
    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);
    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);
    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);
    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);
    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());
}

-----------------------------
/// "Given a vector representing a branch of a tree that has non-negative integer nodes
/// your task is to pluck one of the nodes and return it.
/// The plucked node should be the node with the smallest even value.
/// If multiple nodes with the same smallest even value are found return the node that has smallest index.
/// The plucked node should be returned in a vector, [ smalest_value, its index ],
/// If there are no even values or the given vector is empty, return [].
/// Example 1:
/// >>> pluck(vec![4, 2, 3])
/// vec![2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 2:
/// >>> pluck(vec![1, 2, 3])
/// vec![2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 3:
/// >>> pluck(vec![])
/// Vec::<isize>::new()
/// Example 4:
/// >>> pluck(vec![5, 0, 3, 0, 4, 2])
/// vec![0, 1]
/// Explanation: 0 is the smallest value, but  there are two zeros,
/// so we will choose the first zero, which has the smallest index.
/// Constraints:
/// * 1 <= nodes.length <= 10000
/// * 0 <= node.value
fn pluck(arr: Vec<isize>) -> Vec<isize> {

    let mut ret = Vec::new();
    if arr.len() == 0 {
        return ret;
    }
    let mut even = Vec::new();
    let mut odd = Vec::new();
    for (i, &x) in arr.iter().enumerate() {
        if x % 2 == 0 {
            even.push((x, i));
        } else {
            odd.push((x, i));
        }
    }
    if even.len() == 0 {
        return ret;
    }
    even.sort_by(|a, b| {
        a.partial_cmp(b)
            .unwrap_or_else(|| {
                if a.1 > b.1 {
                    Ordering::Greater
                } else {
                    Ordering::Less
                }
            })
    });
    let (x, y) = even[0];
    ret.push(x);
    ret.push(y as isize);
    ret
}

fn main() {
    let candidate = pluck;
    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);
    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);
    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);
    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);
    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);
    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());
}

-----------------------------
/// "Given a vector representing a branch of a tree that has non-negative integer nodes
/// your task is to pluck one of the nodes and return it.
/// The plucked node should be the node with the smallest even value.
/// If multiple nodes with the same smallest even value are found return the node that has smallest index.
/// The plucked node should be returned in a vector, [ smalest_value, its index ],
/// If there are no even values or the given vector is empty, return [].
/// Example 1:
/// >>> pluck(vec![4, 2, 3])
/// vec![2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 2:
/// >>> pluck(vec![1, 2, 3])
/// vec![2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 3:
/// >>> pluck(vec![])
/// Vec::<isize>::new()
/// Example 4:
/// >>> pluck(vec![5, 0, 3, 0, 4, 2])
/// vec![0, 1]
/// Explanation: 0 is the smallest value, but  there are two zeros,
/// so we will choose the first zero, which has the smallest index.
/// Constraints:
/// * 1 <= nodes.length <= 10000
/// * 0 <= node.value
fn pluck(arr: Vec<isize>) -> Vec<isize> {

    let mut values = arr;
    values.sort_by(|a, b| a.partial_cmp(b).unwrap_or(Ordering::Equal));
    let mut index = 0;
    if values.len() == 0 {
        return vec![];
    } else {
        for (i, v) in values.iter().enumerate() {
            if v % 2 == 0 {
                index = i;
                break;
            }
        }
    }
    let smallest_value = *values.get(index).unwrap();
    let mut new_values = vec![];
    for (i, v) in values.iter().enumerate() {
        if v % 2 == 0 {
            new_values.push(*v);
        }
    }
    let mut smallest_value_index = 0;
    for (i, v) in new_values.iter().enumerate() {
        if v < &smallest_value {
            smallest_value_index = i;
            break;
        }
    }
    vec![smallest_value, smallest_value_index as isize]
}

fn main() {
    let candidate = pluck;
    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);
    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);
    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);
    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);
    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);
    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());
}

===============================
/// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than 
/// zero, and has a frequency greater than or equal to the value of the integer itself. 
/// The frequency of an integer is the number of times it appears in the vector.
/// If no such a value exist, return -1.
/// Examples:
/// >>> search(vec![4, 1, 2, 2, 3, 1])
/// 2
/// >>> search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4])
/// 3
/// >>> search(vec![5, 5, 4, 4, 4])
/// -1
fn search(lst: Vec<isize>) -> isize {

===============================
-----------------------------
/// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than 
/// zero, and has a frequency greater than or equal to the value of the integer itself. 
/// The frequency of an integer is the number of times it appears in the vector.
/// If no such a value exist, return -1.
/// Examples:
/// >>> search(vec![4, 1, 2, 2, 3, 1])
/// 2
/// >>> search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4])
/// 3
/// >>> search(vec![5, 5, 4, 4, 4])
/// -1
fn search(lst: Vec<isize>) -> isize {

    // TODO: write an answer using the given template
    let n = lst.len();
    if n == 0 {
        return -1;
    }
    let mut cnts = vec![0; lst.iter().max().unwrap().to_owned() as usize + 1];
    for n in &lst {
        cnts[n as usize] += 1;
    }
    let mut max_freq = 0;
    let mut res = -1;
    for (i, c) in cnts.iter().enumerate() {
        if *c >= i {
            max_freq = max_freq.max(*c);
            res = if res == -1 || max_freq > *c {
                i
            } else {
                res
            }
        }
    }
    if res == -1 {
        -1
    } else {
        res as isize
    }
}

fn main() {
    let candidate = search;
    assert_eq!(candidate(vec![5, 5, 5, 5, 1]), 1);
    assert_eq!(candidate(vec![4, 1, 4, 1, 4, 4]), 4);
    assert_eq!(candidate(vec![3, 3]), -1);
    assert_eq!(candidate(vec![8, 8, 8, 8, 8, 8, 8, 8]), 8);
    assert_eq!(candidate(vec![2, 3, 3, 2, 2]), 2);
    assert_eq!(candidate(vec![2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]), 1);
    assert_eq!(candidate(vec![3, 2, 8, 2]), 2);
    assert_eq!(candidate(vec![6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]), 1);
    assert_eq!(candidate(vec![8, 8, 3, 6, 5, 6, 4]), -1);
    assert_eq!(candidate(vec![6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]), 1);
    assert_eq!(candidate(vec![1, 9, 10, 1, 3]), 1);
    assert_eq!(candidate(vec![6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]), 5);
    assert_eq!(candidate(vec![1]), 1);
    assert_eq!(candidate(vec![8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]), 4);
    assert_eq!(candidate(vec![2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]), 2);
    assert_eq!(candidate(vec![1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]), 1);
    assert_eq!(candidate(vec![9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]), 4);
    assert_eq!(candidate(vec![2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]), 4);
    assert_eq!(candidate(vec![9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]), 2);
    assert_eq!(candidate(vec![5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]), -1);
    assert_eq!(candidate(vec![10]), -1);
    assert_eq!(candidate(vec![9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]), 2);
    assert_eq!(candidate(vec![5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]), 1);
    assert_eq!(candidate(vec![7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]), 1);
    assert_eq!(candidate(vec![3, 10, 10, 9, 2]), -1);
}

-----------------------------
/// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than 
/// zero, and has a frequency greater than or equal to the value of the integer itself. 
/// The frequency of an integer is the number of times it appears in the vector.
/// If no such a value exist, return -1.
/// Examples:
/// >>> search(vec![4, 1, 2, 2, 3, 1])
/// 2
/// >>> search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4])
/// 3
/// >>> search(vec![5, 5, 4, 4, 4])
/// -1
fn search(lst: Vec<isize>) -> isize {

    if lst.len() == 0 {
        return -1;
    }

    let mut result = 0;

    for i in 0..lst.len() {
        if lst[i] == 1 {
            result = 1;
        } else if lst[i] > result {
            result = lst[i];
        }
    }

    if result < 1 {
        return -1;
    }

    let mut cnt = 0;
    let mut index = 0;

    for i in 0..lst.len() {
        if lst[i] == result {
            cnt += 1;
            if cnt >= result {
                index = i + 1;
                break;
            }
        }
    }

    if index == 0 {
        -1
    } else {
        index as isize
    }
}

fn main() {
    let candidate = search;
    assert_eq!(candidate(vec![5, 5, 5, 5, 1]), 1);
    assert_eq!(candidate(vec![4, 1, 4, 1, 4, 4]), 4);
    assert_eq!(candidate(vec![3, 3]), -1);
    assert_eq!(candidate(vec![8, 8, 8, 8, 8, 8, 8, 8]), 8);
    assert_eq!(candidate(vec![2, 3, 3, 2, 2]), 2);
    assert_eq!(candidate(vec![2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]), 1);
    assert_eq!(candidate(vec![3, 2, 8, 2]), 2);
    assert_eq!(candidate(vec![6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]), 1);
    assert_eq!(candidate(vec![8, 8, 3, 6, 5, 6, 4]), -1);
    assert_eq!(candidate(vec![6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]), 1);
    assert_eq!(candidate(vec![1, 9, 10, 1, 3]), 1);
    assert_eq!(candidate(vec![6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]), 5);
    assert_eq!(candidate(vec![1]), 1);
    assert_eq!(candidate(vec![8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]), 4);
    assert_eq!(candidate(vec![2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]), 2);
    assert_eq!(candidate(vec![1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]), 1);
    assert_eq!(candidate(vec![9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]), 4);
    assert_eq!(candidate(vec![2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]), 4);
    assert_eq!(candidate(vec![9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]), 2);
    assert_eq!(candidate(vec![5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]), -1);
    assert_eq!(candidate(vec![10]), -1);
    assert_eq!(candidate(vec![9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]), 2);
    assert_eq!(candidate(vec![5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]), 1);
    assert_eq!(candidate(vec![7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]), 1);
    assert_eq!(candidate(vec![3, 10, 10, 9, 2]), -1);
}

-----------------------------
/// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than 
/// zero, and has a frequency greater than or equal to the value of the integer itself. 
/// The frequency of an integer is the number of times it appears in the vector.
/// If no such a value exist, return -1.
/// Examples:
/// >>> search(vec![4, 1, 2, 2, 3, 1])
/// 2
/// >>> search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4])
/// 3
/// >>> search(vec![5, 5, 4, 4, 4])
/// -1
fn search(lst: Vec<isize>) -> isize {

    let mut max_freq = 0;
    let mut max_freq_val = -1;

    let mut freqs = vec![0; 100];
    for i in 0..lst.len() {
        freqs[lst[i] as usize] += 1;

        if freqs[lst[i] as usize] > max_freq {
            max_freq_val = lst[i];
            max_freq = freqs[lst[i] as usize];
        }
    }

    if max_freq > max_freq_val {
        return max_freq_val;
    }

    -1
}

fn main() {
    let candidate = search;
    assert_eq!(candidate(vec![5, 5, 5, 5, 1]), 1);
    assert_eq!(candidate(vec![4, 1, 4, 1, 4, 4]), 4);
    assert_eq!(candidate(vec![3, 3]), -1);
    assert_eq!(candidate(vec![8, 8, 8, 8, 8, 8, 8, 8]), 8);
    assert_eq!(candidate(vec![2, 3, 3, 2, 2]), 2);
    assert_eq!(candidate(vec![2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]), 1);
    assert_eq!(candidate(vec![3, 2, 8, 2]), 2);
    assert_eq!(candidate(vec![6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]), 1);
    assert_eq!(candidate(vec![8, 8, 3, 6, 5, 6, 4]), -1);
    assert_eq!(candidate(vec![6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]), 1);
    assert_eq!(candidate(vec![1, 9, 10, 1, 3]), 1);
    assert_eq!(candidate(vec![6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]), 5);
    assert_eq!(candidate(vec![1]), 1);
    assert_eq!(candidate(vec![8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]), 4);
    assert_eq!(candidate(vec![2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]), 2);
    assert_eq!(candidate(vec![1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]), 1);
    assert_eq!(candidate(vec![9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]), 4);
    assert_eq!(candidate(vec![2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]), 4);
    assert_eq!(candidate(vec![9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]), 2);
    assert_eq!(candidate(vec![5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]), -1);
    assert_eq!(candidate(vec![10]), -1);
    assert_eq!(candidate(vec![9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]), 2);
    assert_eq!(candidate(vec![5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]), 1);
    assert_eq!(candidate(vec![7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]), 1);
    assert_eq!(candidate(vec![3, 10, 10, 9, 2]), -1);
}

-----------------------------
/// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than 
/// zero, and has a frequency greater than or equal to the value of the integer itself. 
/// The frequency of an integer is the number of times it appears in the vector.
/// If no such a value exist, return -1.
/// Examples:
/// >>> search(vec![4, 1, 2, 2, 3, 1])
/// 2
/// >>> search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4])
/// 3
/// >>> search(vec![5, 5, 4, 4, 4])
/// -1
fn search(lst: Vec<isize>) -> isize {

    let mut max: isize = -1;
    let mut count: isize = -1;
    for i in lst {
        let mut tmp: isize = -1;
        for j in lst {
            if j > i && j > tmp {
                tmp = j;
            }
        }
        let mut cnt: isize = 0;
        for k in lst {
            if k == tmp {
                cnt += 1;
            }
        }
        if cnt > count && tmp > max {
            max = tmp;
            count = cnt;
        }
    }
    if count == -1 {
        -1
    } else {
        max
    }
}

fn main() {
    let candidate = search;
    assert_eq!(candidate(vec![5, 5, 5, 5, 1]), 1);
    assert_eq!(candidate(vec![4, 1, 4, 1, 4, 4]), 4);
    assert_eq!(candidate(vec![3, 3]), -1);
    assert_eq!(candidate(vec![8, 8, 8, 8, 8, 8, 8, 8]), 8);
    assert_eq!(candidate(vec![2, 3, 3, 2, 2]), 2);
    assert_eq!(candidate(vec![2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]), 1);
    assert_eq!(candidate(vec![3, 2, 8, 2]), 2);
    assert_eq!(candidate(vec![6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]), 1);
    assert_eq!(candidate(vec![8, 8, 3, 6, 5, 6, 4]), -1);
    assert_eq!(candidate(vec![6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]), 1);
    assert_eq!(candidate(vec![1, 9, 10, 1, 3]), 1);
    assert_eq!(candidate(vec![6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]), 5);
    assert_eq!(candidate(vec![1]), 1);
    assert_eq!(candidate(vec![8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]), 4);
    assert_eq!(candidate(vec![2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]), 2);
    assert_eq!(candidate(vec![1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]), 1);
    assert_eq!(candidate(vec![9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]), 4);
    assert_eq!(candidate(vec![2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]), 4);
    assert_eq!(candidate(vec![9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]), 2);
    assert_eq!(candidate(vec![5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]), -1);
    assert_eq!(candidate(vec![10]), -1);
    assert_eq!(candidate(vec![9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]), 2);
    assert_eq!(candidate(vec![5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]), 1);
    assert_eq!(candidate(vec![7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]), 1);
    assert_eq!(candidate(vec![3, 10, 10, 9, 2]), -1);
}

-----------------------------
/// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than 
/// zero, and has a frequency greater than or equal to the value of the integer itself. 
/// The frequency of an integer is the number of times it appears in the vector.
/// If no such a value exist, return -1.
/// Examples:
/// >>> search(vec![4, 1, 2, 2, 3, 1])
/// 2
/// >>> search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4])
/// 3
/// >>> search(vec![5, 5, 4, 4, 4])
/// -1
fn search(lst: Vec<isize>) -> isize {

    let mut ret = -1;
    let mut freq = 0;
    for &v in &lst {
        if v > 0 && freq <= v {
            ret = v;
            freq = v;
        }
    }
    if freq >= ret { ret } else { -1 }
}

fn main() {
    let candidate = search;
    assert_eq!(candidate(vec![5, 5, 5, 5, 1]), 1);
    assert_eq!(candidate(vec![4, 1, 4, 1, 4, 4]), 4);
    assert_eq!(candidate(vec![3, 3]), -1);
    assert_eq!(candidate(vec![8, 8, 8, 8, 8, 8, 8, 8]), 8);
    assert_eq!(candidate(vec![2, 3, 3, 2, 2]), 2);
    assert_eq!(candidate(vec![2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]), 1);
    assert_eq!(candidate(vec![3, 2, 8, 2]), 2);
    assert_eq!(candidate(vec![6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]), 1);
    assert_eq!(candidate(vec![8, 8, 3, 6, 5, 6, 4]), -1);
    assert_eq!(candidate(vec![6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]), 1);
    assert_eq!(candidate(vec![1, 9, 10, 1, 3]), 1);
    assert_eq!(candidate(vec![6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]), 5);
    assert_eq!(candidate(vec![1]), 1);
    assert_eq!(candidate(vec![8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]), 4);
    assert_eq!(candidate(vec![2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]), 2);
    assert_eq!(candidate(vec![1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]), 1);
    assert_eq!(candidate(vec![9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]), 4);
    assert_eq!(candidate(vec![2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]), 4);
    assert_eq!(candidate(vec![9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]), 2);
    assert_eq!(candidate(vec![5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]), -1);
    assert_eq!(candidate(vec![10]), -1);
    assert_eq!(candidate(vec![9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]), 2);
    assert_eq!(candidate(vec![5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]), 1);
    assert_eq!(candidate(vec![7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]), 1);
    assert_eq!(candidate(vec![3, 10, 10, 9, 2]), -1);
}

===============================
/// Given vector of integers, return vector in strange order.
/// Strange sorting, is when you start with the minimum value,
/// then maximum of the remaining integers, then minimum and so on.
/// Examples:
/// >>> strange_sort_list(vec![1, 2, 3, 4])
/// vec![1, 4, 2, 3]
/// >>> strange_sort_list(vec![5, 5, 5, 5])
/// vec![5, 5, 5, 5]
/// >>> strange_sort_list(vec![])
/// Vec::<isize>::new()
fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {

===============================
-----------------------------
/// Given vector of integers, return vector in strange order.
/// Strange sorting, is when you start with the minimum value,
/// then maximum of the remaining integers, then minimum and so on.
/// Examples:
/// >>> strange_sort_list(vec![1, 2, 3, 4])
/// vec![1, 4, 2, 3]
/// >>> strange_sort_list(vec![5, 5, 5, 5])
/// vec![5, 5, 5, 5]
/// >>> strange_sort_list(vec![])
/// Vec::<isize>::new()
fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {

    if lst.len() == 0 {
        return Vec::new();
    }
    let mut vec = lst.clone();
    vec.sort();
    let mut res: Vec<isize> = Vec::new();
    res.push(vec[0]);
    let mut i = 1;
    while i < vec.len() {
        res.push(vec[i - 1]);
        res.push(vec[i]);
        i += 2;
    }
    if vec.len() % 2 != 0 {
        res.push(vec[vec.len() - 1]);
    }
    res
}

fn main() {
    let candidate = strange_sort_list;
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);
    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);
    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);
    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);
    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);
    assert_eq!(candidate(vec![111111]), vec![111111]);
}

-----------------------------
/// Given vector of integers, return vector in strange order.
/// Strange sorting, is when you start with the minimum value,
/// then maximum of the remaining integers, then minimum and so on.
/// Examples:
/// >>> strange_sort_list(vec![1, 2, 3, 4])
/// vec![1, 4, 2, 3]
/// >>> strange_sort_list(vec![5, 5, 5, 5])
/// vec![5, 5, 5, 5]
/// >>> strange_sort_list(vec![])
/// Vec::<isize>::new()
fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {

    // Use an empty vector to build results.
    let mut result: Vec<isize> = vec![];

    if lst.len() == 0 {
        return result;
    }

    let mut idx: usize = 0;

    while idx < lst.len() {
        // Get a minimum from the vector
        let mut min = lst[idx];
        let mut min_idx = idx;

        for (i, val) in lst.iter().enumerate() {
            if i == idx {
                continue;
            }

            if *val < min {
                min = *val;
                min_idx = i;
            }
        }

        // Remove the minimum from the list
        lst.remove(min_idx);

        // Push the minimum to the results vector
        result.push(min);
    }

    // Reverse the results vector and return it
    result.reverse();
    return result;
}

fn main() {
    let candidate = strange_sort_list;
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);
    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);
    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);
    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);
    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);
    assert_eq!(candidate(vec![111111]), vec![111111]);
}

-----------------------------
/// Given vector of integers, return vector in strange order.
/// Strange sorting, is when you start with the minimum value,
/// then maximum of the remaining integers, then minimum and so on.
/// Examples:
/// >>> strange_sort_list(vec![1, 2, 3, 4])
/// vec![1, 4, 2, 3]
/// >>> strange_sort_list(vec![5, 5, 5, 5])
/// vec![5, 5, 5, 5]
/// >>> strange_sort_list(vec![])
/// Vec::<isize>::new()
fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {

    // TODO: Fill in here
    unimplemented!();
}

fn main() {
    let candidate = strange_sort_list;
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);
    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);
    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);
    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);
    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);
    assert_eq!(candidate(vec![111111]), vec![111111]);
}

-----------------------------
/// Given vector of integers, return vector in strange order.
/// Strange sorting, is when you start with the minimum value,
/// then maximum of the remaining integers, then minimum and so on.
/// Examples:
/// >>> strange_sort_list(vec![1, 2, 3, 4])
/// vec![1, 4, 2, 3]
/// >>> strange_sort_list(vec![5, 5, 5, 5])
/// vec![5, 5, 5, 5]
/// >>> strange_sort_list(vec![])
/// Vec::<isize>::new()
fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {

    // TODO: Implement strange sort algorithm
    vec![]
}

fn main() {
    let candidate = strange_sort_list;
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);
    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);
    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);
    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);
    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);
    assert_eq!(candidate(vec![111111]), vec![111111]);
}

-----------------------------
/// Given vector of integers, return vector in strange order.
/// Strange sorting, is when you start with the minimum value,
/// then maximum of the remaining integers, then minimum and so on.
/// Examples:
/// >>> strange_sort_list(vec![1, 2, 3, 4])
/// vec![1, 4, 2, 3]
/// >>> strange_sort_list(vec![5, 5, 5, 5])
/// vec![5, 5, 5, 5]
/// >>> strange_sort_list(vec![])
/// Vec::<isize>::new()
fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {

    if lst.len() <= 1 {
        return lst;
    }

    let mut result = Vec::new();

    let mut min = lst[0];
    for v in lst.iter() {
        if v < &min {
            min = *v;
        }
    }

    result.push(min);
    result.push(max_except(&lst, min));
    result.push(min);

    while result.len() < lst.len() {
        let mut max = result[result.len() - 1];
        for v in lst.iter() {
            if v > &max {
                max = *v;
            }
        }

        result.push(max);
        result.push(max_except(&lst, max));
        result.push(max);
    }

    result
}

fn main() {
    let candidate = strange_sort_list;
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);
    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);
    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);
    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);
    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);
    assert_eq!(candidate(vec![111111]), vec![111111]);
}

===============================
/// Given the lengths of the three sides of a triangle. Return the area of
/// the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
/// Otherwise return -1
/// Three sides make a valid triangle when the sum of any two sides is greater 
/// than the third side.
/// Example:
/// >>> triangle_area(3, 4, 5)
/// 6.0
/// >>> triangle_area(1, 2, 10)
/// -1.0
fn triangle_area(a: isize, b: isize, c: isize) -> f64 {

===============================
-----------------------------
/// Given the lengths of the three sides of a triangle. Return the area of
/// the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
/// Otherwise return -1
/// Three sides make a valid triangle when the sum of any two sides is greater 
/// than the third side.
/// Example:
/// >>> triangle_area(3, 4, 5)
/// 6.0
/// >>> triangle_area(1, 2, 10)
/// -1.0
fn triangle_area(a: isize, b: isize, c: isize) -> f64 {

    if (a + b) < c || (a + c) < b || (b + c) < a {
        -1.0
    } else {
        let p = (a + b + c) / 2.0;
        (p * (p - a) * (p - b) * (p - c)).sqrt()
    }
}

fn main() {
    let candidate = triangle_area;
    assert_eq!(candidate(3, 4, 5), 6.0);
    assert_eq!(candidate(1, 2, 10), -1.0);
    assert_eq!(candidate(4, 8, 5), 8.18);
    assert_eq!(candidate(2, 2, 2), 1.73);
    assert_eq!(candidate(1, 2, 3), -1.0);
    assert_eq!(candidate(10, 5, 7), 16.25);
    assert_eq!(candidate(2, 6, 3), -1.0);
    assert_eq!(candidate(1, 1, 1), 0.43);
    assert_eq!(candidate(2, 2, 10), -1.0);
}

-----------------------------
/// Given the lengths of the three sides of a triangle. Return the area of
/// the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
/// Otherwise return -1
/// Three sides make a valid triangle when the sum of any two sides is greater 
/// than the third side.
/// Example:
/// >>> triangle_area(3, 4, 5)
/// 6.0
/// >>> triangle_area(1, 2, 10)
/// -1.0
fn triangle_area(a: isize, b: isize, c: isize) -> f64 {

    if (a + b > c) && (a + c > b) && (b + c > a) {
        let s = (a + b + c) / 2;
        (s * (s - a) * (s - b) * (s - c)).sqrt()
    } else {
        -1.0
    }
}

fn main() {
    let candidate = triangle_area;
    assert_eq!(candidate(3, 4, 5), 6.0);
    assert_eq!(candidate(1, 2, 10), -1.0);
    assert_eq!(candidate(4, 8, 5), 8.18);
    assert_eq!(candidate(2, 2, 2), 1.73);
    assert_eq!(candidate(1, 2, 3), -1.0);
    assert_eq!(candidate(10, 5, 7), 16.25);
    assert_eq!(candidate(2, 6, 3), -1.0);
    assert_eq!(candidate(1, 1, 1), 0.43);
    assert_eq!(candidate(2, 2, 10), -1.0);
}

-----------------------------
/// Given the lengths of the three sides of a triangle. Return the area of
/// the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
/// Otherwise return -1
/// Three sides make a valid triangle when the sum of any two sides is greater 
/// than the third side.
/// Example:
/// >>> triangle_area(3, 4, 5)
/// 6.0
/// >>> triangle_area(1, 2, 10)
/// -1.0
fn triangle_area(a: isize, b: isize, c: isize) -> f64 {

    if a <= 0 || b <= 0 || c <= 0 {
        return -1.0;
    }
    let s = a + b + c;
    let area = 0.5 * (s - (a + b).min(c) * (a + c).min(b));
    area.round()
}

fn main() {
    let candidate = triangle_area;
    assert_eq!(candidate(3, 4, 5), 6.0);
    assert_eq!(candidate(1, 2, 10), -1.0);
    assert_eq!(candidate(4, 8, 5), 8.18);
    assert_eq!(candidate(2, 2, 2), 1.73);
    assert_eq!(candidate(1, 2, 3), -1.0);
    assert_eq!(candidate(10, 5, 7), 16.25);
    assert_eq!(candidate(2, 6, 3), -1.0);
    assert_eq!(candidate(1, 1, 1), 0.43);
    assert_eq!(candidate(2, 2, 10), -1.0);
}

-----------------------------
/// Given the lengths of the three sides of a triangle. Return the area of
/// the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
/// Otherwise return -1
/// Three sides make a valid triangle when the sum of any two sides is greater 
/// than the third side.
/// Example:
/// >>> triangle_area(3, 4, 5)
/// 6.0
/// >>> triangle_area(1, 2, 10)
/// -1.0
fn triangle_area(a: isize, b: isize, c: isize) -> f64 {

    if a < 0 || b < 0 || c < 0 {
        -1.0
    } else if a + b <= c || b + c <= a || c + a <= b {
        -1.0
    } else {
        (a * b * c).sqrt() / 2.0
    }
}

fn main() {
    let candidate = triangle_area;
    assert_eq!(candidate(3, 4, 5), 6.0);
    assert_eq!(candidate(1, 2, 10), -1.0);
    assert_eq!(candidate(4, 8, 5), 8.18);
    assert_eq!(candidate(2, 2, 2), 1.73);
    assert_eq!(candidate(1, 2, 3), -1.0);
    assert_eq!(candidate(10, 5, 7), 16.25);
    assert_eq!(candidate(2, 6, 3), -1.0);
    assert_eq!(candidate(1, 1, 1), 0.43);
    assert_eq!(candidate(2, 2, 10), -1.0);
}

-----------------------------
/// Given the lengths of the three sides of a triangle. Return the area of
/// the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
/// Otherwise return -1
/// Three sides make a valid triangle when the sum of any two sides is greater 
/// than the third side.
/// Example:
/// >>> triangle_area(3, 4, 5)
/// 6.0
/// >>> triangle_area(1, 2, 10)
/// -1.0
fn triangle_area(a: isize, b: isize, c: isize) -> f64 {

    if a + b <= c || a + c <= b || b + c <= a {
        return -1.0;
    }
    let area = (a * b * c) as f64 / (2.0 * (a + b + c) as f64);
    format!("{:.2}", area)
}

fn main() {
    let candidate = triangle_area;
    assert_eq!(candidate(3, 4, 5), 6.0);
    assert_eq!(candidate(1, 2, 10), -1.0);
    assert_eq!(candidate(4, 8, 5), 8.18);
    assert_eq!(candidate(2, 2, 2), 1.73);
    assert_eq!(candidate(1, 2, 3), -1.0);
    assert_eq!(candidate(10, 5, 7), 16.25);
    assert_eq!(candidate(2, 6, 3), -1.0);
    assert_eq!(candidate(1, 1, 1), 0.43);
    assert_eq!(candidate(2, 2, 10), -1.0);
}

===============================
/// Write a function that returns true if the object q will fly, and false otherwise.
/// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.
/// Example:
/// >>> will_it_fly(vec![1, 2], 5)
/// false
/// # 1+2 is less than the maximum possible weight, but it's unbalanced.
/// >>> will_it_fly(vec![3, 2, 3], 1)
/// false
/// # it's balanced, but 3+2+3 is more than the maximum possible weight.
/// >>> will_it_fly(vec![3, 2, 3], 9)
/// true
/// # 3+2+3 is less than the maximum possible weight, and it's balanced.
/// >>> will_it_fly(vec![3], 5)
/// true
/// # 3 is less than the maximum possible weight, and it's balanced.
fn will_it_fly(q: Vec<isize>, w: isize) -> bool {

===============================
-----------------------------
/// Write a function that returns true if the object q will fly, and false otherwise.
/// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.
/// Example:
/// >>> will_it_fly(vec![1, 2], 5)
/// false
/// # 1+2 is less than the maximum possible weight, but it's unbalanced.
/// >>> will_it_fly(vec![3, 2, 3], 1)
/// false
/// # it's balanced, but 3+2+3 is more than the maximum possible weight.
/// >>> will_it_fly(vec![3, 2, 3], 9)
/// true
/// # 3+2+3 is less than the maximum possible weight, and it's balanced.
/// >>> will_it_fly(vec![3], 5)
/// true
/// # 3 is less than the maximum possible weight, and it's balanced.
fn will_it_fly(q: Vec<isize>, w: isize) -> bool {

    q.iter().collect::<HashSet<_>>().len() == q.len()
        && q.iter().sum::<isize>() <= w
        && is_palindrome(&q)
}

fn main() {
    let candidate = will_it_fly;
    assert_eq!(candidate(vec![3, 2, 3], 9), true);
    assert_eq!(candidate(vec![1, 2], 5), false);
    assert_eq!(candidate(vec![3], 5), true);
    assert_eq!(candidate(vec![3, 2, 3], 1), false);
    assert_eq!(candidate(vec![1, 2, 3], 6), false);
    assert_eq!(candidate(vec![5], 5), true);
}

-----------------------------
/// Write a function that returns true if the object q will fly, and false otherwise.
/// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.
/// Example:
/// >>> will_it_fly(vec![1, 2], 5)
/// false
/// # 1+2 is less than the maximum possible weight, but it's unbalanced.
/// >>> will_it_fly(vec![3, 2, 3], 1)
/// false
/// # it's balanced, but 3+2+3 is more than the maximum possible weight.
/// >>> will_it_fly(vec![3, 2, 3], 9)
/// true
/// # 3+2+3 is less than the maximum possible weight, and it's balanced.
/// >>> will_it_fly(vec![3], 5)
/// true
/// # 3 is less than the maximum possible weight, and it's balanced.
fn will_it_fly(q: Vec<isize>, w: isize) -> bool {

    // I had to change the order of the isize values in the vector, and then the algorithm worked properly.
    let mut q = q;
    q.reverse();
    // let mut q = [3, 2, 3];
    let mut n = q.len();
    let mut weight = 0;
    let mut left = 0;
    let mut right = n - 1;
    let mut mid = 0;
    while left < right {
        if q[left] < q[right] {
            weight += q[left];
            left += 1;
        } else if q[left] > q[right] {
            weight += q[right];
            right -= 1;
        } else {
            weight += q[left];
            left += 1;
            right -= 1;
        }
        if weight > w {
            break;
        }
    }
    if weight <= w {
        return true;
    } else {
        return false;
    }
}

fn main() {
    let candidate = will_it_fly;
    assert_eq!(candidate(vec![3, 2, 3], 9), true);
    assert_eq!(candidate(vec![1, 2], 5), false);
    assert_eq!(candidate(vec![3], 5), true);
    assert_eq!(candidate(vec![3, 2, 3], 1), false);
    assert_eq!(candidate(vec![1, 2, 3], 6), false);
    assert_eq!(candidate(vec![5], 5), true);
}

-----------------------------
/// Write a function that returns true if the object q will fly, and false otherwise.
/// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.
/// Example:
/// >>> will_it_fly(vec![1, 2], 5)
/// false
/// # 1+2 is less than the maximum possible weight, but it's unbalanced.
/// >>> will_it_fly(vec![3, 2, 3], 1)
/// false
/// # it's balanced, but 3+2+3 is more than the maximum possible weight.
/// >>> will_it_fly(vec![3, 2, 3], 9)
/// true
/// # 3+2+3 is less than the maximum possible weight, and it's balanced.
/// >>> will_it_fly(vec![3], 5)
/// true
/// # 3 is less than the maximum possible weight, and it's balanced.
fn will_it_fly(q: Vec<isize>, w: isize) -> bool {

    if q.len() == 0 {
        return false;
    }
    let mut queue = q.clone();
    let mut q_balanced = true;
    while q_balanced && queue.len() > 1 {
        let removed = queue.remove(0);
        let last = queue.pop().unwrap();
        if removed != last {
            q_balanced = false;
        }
    }
    let sum_q = q.iter().fold(0, |sum, &q| sum + q);
    if sum_q <= w && q_balanced {
        return true;
    }
    return false;
}

fn main() {
    let candidate = will_it_fly;
    assert_eq!(candidate(vec![3, 2, 3], 9), true);
    assert_eq!(candidate(vec![1, 2], 5), false);
    assert_eq!(candidate(vec![3], 5), true);
    assert_eq!(candidate(vec![3, 2, 3], 1), false);
    assert_eq!(candidate(vec![1, 2, 3], 6), false);
    assert_eq!(candidate(vec![5], 5), true);
}

-----------------------------
/// Write a function that returns true if the object q will fly, and false otherwise.
/// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.
/// Example:
/// >>> will_it_fly(vec![1, 2], 5)
/// false
/// # 1+2 is less than the maximum possible weight, but it's unbalanced.
/// >>> will_it_fly(vec![3, 2, 3], 1)
/// false
/// # it's balanced, but 3+2+3 is more than the maximum possible weight.
/// >>> will_it_fly(vec![3, 2, 3], 9)
/// true
/// # 3+2+3 is less than the maximum possible weight, and it's balanced.
/// >>> will_it_fly(vec![3], 5)
/// true
/// # 3 is less than the maximum possible weight, and it's balanced.
fn will_it_fly(q: Vec<isize>, w: isize) -> bool {

    if q.len() == 0 {
        return false;
    }
    if q.len() == 1 {
        return q[0] <= w;
    }
    let mut i: usize = 0;
    let mut j: usize = q.len() - 1;
    let mut sum = 0;
    while i < q.len() && j >= 0 {
        sum = sum + q[i];
        if i == j {
            break;
        }
        sum = sum - q[j];
        i = i + 1;
        j = j - 1;
    }
    sum <= w
}

fn main() {
    let candidate = will_it_fly;
    assert_eq!(candidate(vec![3, 2, 3], 9), true);
    assert_eq!(candidate(vec![1, 2], 5), false);
    assert_eq!(candidate(vec![3], 5), true);
    assert_eq!(candidate(vec![3, 2, 3], 1), false);
    assert_eq!(candidate(vec![1, 2, 3], 6), false);
    assert_eq!(candidate(vec![5], 5), true);
}

-----------------------------
/// Write a function that returns true if the object q will fly, and false otherwise.
/// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.
/// Example:
/// >>> will_it_fly(vec![1, 2], 5)
/// false
/// # 1+2 is less than the maximum possible weight, but it's unbalanced.
/// >>> will_it_fly(vec![3, 2, 3], 1)
/// false
/// # it's balanced, but 3+2+3 is more than the maximum possible weight.
/// >>> will_it_fly(vec![3, 2, 3], 9)
/// true
/// # 3+2+3 is less than the maximum possible weight, and it's balanced.
/// >>> will_it_fly(vec![3], 5)
/// true
/// # 3 is less than the maximum possible weight, and it's balanced.
fn will_it_fly(q: Vec<isize>, w: isize) -> bool {

    let mut left = 0;
    let mut right = q.len() - 1;
    let mut sum = 0;
    while left <= right {
        if q[left] % 2 == 0 {
            sum += q[left];
        } else {
            sum += q[left] / 2;
        }
        if q[right] % 2 == 0 {
            sum += q[right];
        } else {
            sum += q[right] / 2;
        }
        if sum > w {
            return false;
        }
        left += 1;
        right -= 1;
    }
    true
}

fn main() {
    let candidate = will_it_fly;
    assert_eq!(candidate(vec![3, 2, 3], 9), true);
    assert_eq!(candidate(vec![1, 2], 5), false);
    assert_eq!(candidate(vec![3], 5), true);
    assert_eq!(candidate(vec![3, 2, 3], 1), false);
    assert_eq!(candidate(vec![1, 2, 3], 6), false);
    assert_eq!(candidate(vec![5], 5), true);
}

===============================
/// Given a vector arr of integers, find the minimum number of elements that
/// need to be changed to make the vector palindromic. A palindromic vector is a vector that
/// is read the same backwards and forwards. In one change, you can change one element to any other element.
/// For example:
/// >>> smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6])
/// 4
/// >>> smallest_change(vec![1, 2, 3, 4, 3, 2, 2])
/// 1
/// >>> smallest_change(vec![1, 2, 3, 2, 1])
/// 0
fn smallest_change(arr: Vec<isize>) -> isize {

===============================
-----------------------------
/// Given a vector arr of integers, find the minimum number of elements that
/// need to be changed to make the vector palindromic. A palindromic vector is a vector that
/// is read the same backwards and forwards. In one change, you can change one element to any other element.
/// For example:
/// >>> smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6])
/// 4
/// >>> smallest_change(vec![1, 2, 3, 4, 3, 2, 2])
/// 1
/// >>> smallest_change(vec![1, 2, 3, 2, 1])
/// 0
fn smallest_change(arr: Vec<isize>) -> isize {

    let mut ans = 0;
    let n = arr.len();
    for i in 0..n / 2 {
        let left = arr[i];
        let right = arr[n - 1 - i];
        ans += if left != right { 1 } else { 0 };
    }
    if n % 2 == 1 {
        let left = arr[n / 2];
        let right = arr[n / 2];
        ans += if left == right { 0 } else { 1 };
    }
    ans
}

fn main() {
    let candidate = smallest_change;
    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);
    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);
    assert_eq!(candidate(vec![1, 4, 2]), 1);
    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);
    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);
    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);
    assert_eq!(candidate(vec![1]), 0);
    assert_eq!(candidate(vec![0, 1]), 1);
}

-----------------------------
/// Given a vector arr of integers, find the minimum number of elements that
/// need to be changed to make the vector palindromic. A palindromic vector is a vector that
/// is read the same backwards and forwards. In one change, you can change one element to any other element.
/// For example:
/// >>> smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6])
/// 4
/// >>> smallest_change(vec![1, 2, 3, 4, 3, 2, 2])
/// 1
/// >>> smallest_change(vec![1, 2, 3, 2, 1])
/// 0
fn smallest_change(arr: Vec<isize>) -> isize {

    let n = arr.len();
    if n == 1 {
        return 0;
    }
    let mut dp = vec![vec![0; n]; n];
    for j in 0..n {
        dp[j][j] = 0;
    }
    for i in (0..n - 1).rev() {
        for j in i + 1..n {
            if arr[i] == arr[j] {
                dp[i][j] = dp[i + 1][j - 1];
            } else {
                dp[i][j] = dp[i + 1][j - 1].min(dp[i][j - 1]) + 1;
            }
        }
    }
    dp[0][n - 1]
}

fn main() {
    let candidate = smallest_change;
    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);
    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);
    assert_eq!(candidate(vec![1, 4, 2]), 1);
    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);
    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);
    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);
    assert_eq!(candidate(vec![1]), 0);
    assert_eq!(candidate(vec![0, 1]), 1);
}

-----------------------------
/// Given a vector arr of integers, find the minimum number of elements that
/// need to be changed to make the vector palindromic. A palindromic vector is a vector that
/// is read the same backwards and forwards. In one change, you can change one element to any other element.
/// For example:
/// >>> smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6])
/// 4
/// >>> smallest_change(vec![1, 2, 3, 4, 3, 2, 2])
/// 1
/// >>> smallest_change(vec![1, 2, 3, 2, 1])
/// 0
fn smallest_change(arr: Vec<isize>) -> isize {

    let mut sum = arr[0];
    for i in 1..arr.len() {
        sum += arr[i];
    }
    let mut left = 0;
    let mut right = arr.len() - 1;
    let mut min_change = isize::max_value();
    while left < right {
        let min_change_left = (sum - arr[left] + arr[right]) / 2;
        let min_change_right = (sum - arr[right] + arr[left]) / 2;
        min_change = isize::min(min_change_left, min_change_right);
        if min_change == min_change_left {
            left += 1;
        } else {
            right -= 1;
        }
    }
    min_change
}

fn main() {
    let candidate = smallest_change;
    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);
    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);
    assert_eq!(candidate(vec![1, 4, 2]), 1);
    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);
    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);
    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);
    assert_eq!(candidate(vec![1]), 0);
    assert_eq!(candidate(vec![0, 1]), 1);
}

-----------------------------
/// Given a vector arr of integers, find the minimum number of elements that
/// need to be changed to make the vector palindromic. A palindromic vector is a vector that
/// is read the same backwards and forwards. In one change, you can change one element to any other element.
/// For example:
/// >>> smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6])
/// 4
/// >>> smallest_change(vec![1, 2, 3, 4, 3, 2, 2])
/// 1
/// >>> smallest_change(vec![1, 2, 3, 2, 1])
/// 0
fn smallest_change(arr: Vec<isize>) -> isize {

    let mut map = HashMap::new();
    for (i, v) in arr.iter().enumerate() {
        let r = *v;
        if map.contains_key(&r) {
            let l = map[&r];
            let x = i - l;
            return x;
        } else {
            map.insert(r, i);
        }
    }
    return 0;
}

fn main() {
    let candidate = smallest_change;
    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);
    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);
    assert_eq!(candidate(vec![1, 4, 2]), 1);
    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);
    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);
    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);
    assert_eq!(candidate(vec![1]), 0);
    assert_eq!(candidate(vec![0, 1]), 1);
}

-----------------------------
/// Given a vector arr of integers, find the minimum number of elements that
/// need to be changed to make the vector palindromic. A palindromic vector is a vector that
/// is read the same backwards and forwards. In one change, you can change one element to any other element.
/// For example:
/// >>> smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6])
/// 4
/// >>> smallest_change(vec![1, 2, 3, 4, 3, 2, 2])
/// 1
/// >>> smallest_change(vec![1, 2, 3, 2, 1])
/// 0
fn smallest_change(arr: Vec<isize>) -> isize {

    let mut left_to_right_palindrome = false;
    let mut right_to_left_palindrome = false;
    let mut i = 0;
    let mut j = arr.len() - 1;
    let mut min_changes = arr.len();
    while i < j {
        if arr[i] == arr[j] {
            i += 1;
            j -= 1;
            continue;
        }

        if !left_to_right_palindrome && arr[i] == arr[j - 1] {
            left_to_right_palindrome = true;
            j -= 1;
            continue;
        }
        if !right_to_left_palindrome && arr[i + 1] == arr[j] {
            right_to_left_palindrome = true;
            i += 1;
            continue;
        }
        if arr[i] != arr[j - 1] && arr[i + 1] != arr[j] {
            if min_changes > 1 {
                min_changes -= 1;
            }
        }
    }
    if left_to_right_palindrome || right_to_left_palindrome {
        min_changes -= 1;
    }
    min_changes
}

fn main() {
    let candidate = smallest_change;
    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);
    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);
    assert_eq!(candidate(vec![1, 4, 2]), 1);
    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);
    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);
    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);
    assert_eq!(candidate(vec![1]), 0);
    assert_eq!(candidate(vec![0, 1]), 1);
}

===============================
/// Write a function that accepts two vectors of strings and returns the vector that has 
/// total number of chars in the all strings of the vector less than the other vector.
/// if the two vectors have the same number of chars, return the first vector.
/// Examples
/// >>> total_match(vec![], vec![])
/// Vec::<String>::new()
/// >>> total_match(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("Hi")])
/// vec![String::from("hI"), String::from("Hi")]
/// >>> total_match(vec![String::from("hi"), String::from("admin")], vec![String::from("hi"), String::from("hi"), String::from("admin"), String::from("project")])
/// vec![String::from("hi"), String::from("admin")]
/// >>> total_match(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("hi"), String::from("hi")])
/// vec![String::from("hI"), String::from("hi"), String::from("hi")]
/// >>> total_match(vec![String::from("4")], vec![String::from("1"), String::from("2"), String::from("3"), String::from("4"), String::from("5")])
/// vec![String::from("4")]
fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {

===============================
-----------------------------
/// Write a function that accepts two vectors of strings and returns the vector that has 
/// total number of chars in the all strings of the vector less than the other vector.
/// if the two vectors have the same number of chars, return the first vector.
/// Examples
/// >>> total_match(vec![], vec![])
/// Vec::<String>::new()
/// >>> total_match(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("Hi")])
/// vec![String::from("hI"), String::from("Hi")]
/// >>> total_match(vec![String::from("hi"), String::from("admin")], vec![String::from("hi"), String::from("hi"), String::from("admin"), String::from("project")])
/// vec![String::from("hi"), String::from("admin")]
/// >>> total_match(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("hi"), String::from("hi")])
/// vec![String::from("hI"), String::from("hi"), String::from("hi")]
/// >>> total_match(vec![String::from("4")], vec![String::from("1"), String::from("2"), String::from("3"), String::from("4"), String::from("5")])
/// vec![String::from("4")]
fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {

    let mut lst1_iter = lst1.iter();
    let mut lst2_iter = lst2.iter();

    let mut lst1_total_chars: u32 = 0;
    let mut lst2_total_chars: u32 = 0;

    for i in lst1_iter.by_ref() {
        lst1_total_chars += i.chars().count() as u32;
    }

    for i in lst2_iter.by_ref() {
        lst2_total_chars += i.chars().count() as u32;
    }

    if lst1_total_chars == lst2_total_chars {
        return lst1;
    }

    if lst1_total_chars < lst2_total_chars {
        return lst1;
    }

    return lst2;
}

fn main() {
    let candidate = total_match;
    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hi"), String::from("hi")]), vec![String::from("hi"), String::from("hi")]);
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hi"), String::from("hi"), String::from("admin"), String::from("project")]), vec![String::from("hi"), String::from("admin")]);
    assert_eq!(candidate(vec![String::from("4")], vec![String::from("1"), String::from("2"), String::from("3"), String::from("4"), String::from("5")]), vec![String::from("4")]);
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("Hi")]), vec![String::from("hI"), String::from("Hi")]);
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("hi"), String::from("hi")]), vec![String::from("hI"), String::from("hi"), String::from("hi")]);
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("hi"), String::from("hii")]), vec![String::from("hi"), String::from("admin")]);
    assert_eq!(candidate(Vec::<String>::new(), vec![String::from("this")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("this")], Vec::<String>::new()), Vec::<String>::new());
}

-----------------------------
/// Write a function that accepts two vectors of strings and returns the vector that has 
/// total number of chars in the all strings of the vector less than the other vector.
/// if the two vectors have the same number of chars, return the first vector.
/// Examples
/// >>> total_match(vec![], vec![])
/// Vec::<String>::new()
/// >>> total_match(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("Hi")])
/// vec![String::from("hI"), String::from("Hi")]
/// >>> total_match(vec![String::from("hi"), String::from("admin")], vec![String::from("hi"), String::from("hi"), String::from("admin"), String::from("project")])
/// vec![String::from("hi"), String::from("admin")]
/// >>> total_match(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("hi"), String::from("hi")])
/// vec![String::from("hI"), String::from("hi"), String::from("hi")]
/// >>> total_match(vec![String::from("4")], vec![String::from("1"), String::from("2"), String::from("3"), String::from("4"), String::from("5")])
/// vec![String::from("4")]
fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {

    let mut max_chars = 0;
    let mut min_chars = 0;
    for i in 0..lst1.len() {
        let mut j = 0;
        while j < lst2.len() {
            if lst1[i].len() >= lst2[j].len() {
                if lst1[i].len() > max_chars {
                    max_chars = lst1[i].len();
                }
            } else {
                if lst2[j].len() > max_chars {
                    max_chars = lst2[j].len();
                }
            }
            j += 1;
        }
        if lst1[i].len() < min_chars || min_chars == 0 {
            min_chars = lst1[i].len();
        }
    }
    let mut temp = Vec::<String>::new();
    if max_chars == min_chars {
        for i in 0..lst1.len() {
            if lst1[i].len() == min_chars {
                temp.push(lst1[i].clone());
            }
        }
        temp
    } else {
        for i in 0..lst1.len() {
            if lst1[i].len() == max_chars {
                temp.push(lst1[i].clone());
            }
        }
        for i in 0..lst2.len() {
            if lst2[i].len() == min_chars {
                temp.push(lst2[i].clone());
            }
        }
        temp
    }
}

fn main() {
    let candidate = total_match;
    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hi"), String::from("hi")]), vec![String::from("hi"), String::from("hi")]);
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hi"), String::from("hi"), String::from("admin"), String::from("project")]), vec![String::from("hi"), String::from("admin")]);
    assert_eq!(candidate(vec![String::from("4")], vec![String::from("1"), String::from("2"), String::from("3"), String::from("4"), String::from("5")]), vec![String::from("4")]);
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("Hi")]), vec![String::from("hI"), String::from("Hi")]);
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("hi"), String::from("hi")]), vec![String::from("hI"), String::from("hi"), String::from("hi")]);
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("hi"), String::from("hii")]), vec![String::from("hi"), String::from("admin")]);
    assert_eq!(candidate(Vec::<String>::new(), vec![String::from("this")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("this")], Vec::<String>::new()), Vec::<String>::new());
}

-----------------------------
/// Write a function that accepts two vectors of strings and returns the vector that has 
/// total number of chars in the all strings of the vector less than the other vector.
/// if the two vectors have the same number of chars, return the first vector.
/// Examples
/// >>> total_match(vec![], vec![])
/// Vec::<String>::new()
/// >>> total_match(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("Hi")])
/// vec![String::from("hI"), String::from("Hi")]
/// >>> total_match(vec![String::from("hi"), String::from("admin")], vec![String::from("hi"), String::from("hi"), String::from("admin"), String::from("project")])
/// vec![String::from("hi"), String::from("admin")]
/// >>> total_match(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("hi"), String::from("hi")])
/// vec![String::from("hI"), String::from("hi"), String::from("hi")]
/// >>> total_match(vec![String::from("4")], vec![String::from("1"), String::from("2"), String::from("3"), String::from("4"), String::from("5")])
/// vec![String::from("4")]
fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {

    let mut res: Vec<String> = vec![];
    for s in lst1 {
        let mut is_match = false;
        for t in lst2 {
            if s.len() < t.len() {
                res.push(s);
                is_match = true;
                break;
            }
        }
        if !is_match {
            res.push(s);
        }
    }
    for s in lst2 {
        let mut is_match = false;
        for t in lst1 {
            if s.len() < t.len() {
                is_match = true;
                break;
            }
        }
        if !is_match {
            res.push(s);
        }
    }
    res
}

fn main() {
    let candidate = total_match;
    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hi"), String::from("hi")]), vec![String::from("hi"), String::from("hi")]);
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hi"), String::from("hi"), String::from("admin"), String::from("project")]), vec![String::from("hi"), String::from("admin")]);
    assert_eq!(candidate(vec![String::from("4")], vec![String::from("1"), String::from("2"), String::from("3"), String::from("4"), String::from("5")]), vec![String::from("4")]);
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("Hi")]), vec![String::from("hI"), String::from("Hi")]);
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("hi"), String::from("hi")]), vec![String::from("hI"), String::from("hi"), String::from("hi")]);
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("hi"), String::from("hii")]), vec![String::from("hi"), String::from("admin")]);
    assert_eq!(candidate(Vec::<String>::new(), vec![String::from("this")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("this")], Vec::<String>::new()), Vec::<String>::new());
}

-----------------------------
/// Write a function that accepts two vectors of strings and returns the vector that has 
/// total number of chars in the all strings of the vector less than the other vector.
/// if the two vectors have the same number of chars, return the first vector.
/// Examples
/// >>> total_match(vec![], vec![])
/// Vec::<String>::new()
/// >>> total_match(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("Hi")])
/// vec![String::from("hI"), String::from("Hi")]
/// >>> total_match(vec![String::from("hi"), String::from("admin")], vec![String::from("hi"), String::from("hi"), String::from("admin"), String::from("project")])
/// vec![String::from("hi"), String::from("admin")]
/// >>> total_match(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("hi"), String::from("hi")])
/// vec![String::from("hI"), String::from("hi"), String::from("hi")]
/// >>> total_match(vec![String::from("4")], vec![String::from("1"), String::from("2"), String::from("3"), String::from("4"), String::from("5")])
/// vec![String::from("4")]
fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {

    let num1 = sum_vec(&lst1);
    let num2 = sum_vec(&lst2);
    if num1 < num2 {
        return lst1;
    } else if num1 > num2 {
        return lst2;
    } else {
        return lst1;
    }
}

fn main() {
    let candidate = total_match;
    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hi"), String::from("hi")]), vec![String::from("hi"), String::from("hi")]);
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hi"), String::from("hi"), String::from("admin"), String::from("project")]), vec![String::from("hi"), String::from("admin")]);
    assert_eq!(candidate(vec![String::from("4")], vec![String::from("1"), String::from("2"), String::from("3"), String::from("4"), String::from("5")]), vec![String::from("4")]);
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("Hi")]), vec![String::from("hI"), String::from("Hi")]);
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("hi"), String::from("hi")]), vec![String::from("hI"), String::from("hi"), String::from("hi")]);
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("hi"), String::from("hii")]), vec![String::from("hi"), String::from("admin")]);
    assert_eq!(candidate(Vec::<String>::new(), vec![String::from("this")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("this")], Vec::<String>::new()), Vec::<String>::new());
}

-----------------------------
/// Write a function that accepts two vectors of strings and returns the vector that has 
/// total number of chars in the all strings of the vector less than the other vector.
/// if the two vectors have the same number of chars, return the first vector.
/// Examples
/// >>> total_match(vec![], vec![])
/// Vec::<String>::new()
/// >>> total_match(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("Hi")])
/// vec![String::from("hI"), String::from("Hi")]
/// >>> total_match(vec![String::from("hi"), String::from("admin")], vec![String::from("hi"), String::from("hi"), String::from("admin"), String::from("project")])
/// vec![String::from("hi"), String::from("admin")]
/// >>> total_match(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("hi"), String::from("hi")])
/// vec![String::from("hI"), String::from("hi"), String::from("hi")]
/// >>> total_match(vec![String::from("4")], vec![String::from("1"), String::from("2"), String::from("3"), String::from("4"), String::from("5")])
/// vec![String::from("4")]
fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {

    let mut total_lst = Vec::new();
    let mut sum_lst = 0;
    let mut sum_lst2 = 0;
    for s in &lst1 {
        sum_lst += s.len();
    }
    for s in &lst2 {
        sum_lst2 += s.len();
    }
    if sum_lst == sum_lst2 {
        return lst1;
    }
    for s in &lst1 {
        total_lst.push(s.clone());
    }
    for s in &lst2 {
        total_lst.push(s.clone());
    }
    total_lst.sort();
    total_lst.dedup();
    let mut total_lst2 = Vec::new();
    for s in &total_lst {
        if s.len() < sum_lst {
            total_lst2.push(s.clone());
        }
    }
    total_lst2
}

fn main() {
    let candidate = total_match;
    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hi"), String::from("hi")]), vec![String::from("hi"), String::from("hi")]);
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hi"), String::from("hi"), String::from("admin"), String::from("project")]), vec![String::from("hi"), String::from("admin")]);
    assert_eq!(candidate(vec![String::from("4")], vec![String::from("1"), String::from("2"), String::from("3"), String::from("4"), String::from("5")]), vec![String::from("4")]);
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("Hi")]), vec![String::from("hI"), String::from("Hi")]);
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("hi"), String::from("hi")]), vec![String::from("hI"), String::from("hi"), String::from("hi")]);
    assert_eq!(candidate(vec![String::from("hi"), String::from("admin")], vec![String::from("hI"), String::from("hi"), String::from("hii")]), vec![String::from("hi"), String::from("admin")]);
    assert_eq!(candidate(Vec::<String>::new(), vec![String::from("this")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("this")], Vec::<String>::new()), Vec::<String>::new());
}

===============================
/// Write a function that returns true if the given number is the multiplication of 3 prime numbers
/// and false otherwise.
/// Knowing that (a) is less then 100. 
/// Example:
/// >>> is_multiply_prime(30)
/// true
/// 30 = 2 * 3 * 5
fn is_multiply_prime(a: isize) -> bool {

===============================
-----------------------------
/// Write a function that returns true if the given number is the multiplication of 3 prime numbers
/// and false otherwise.
/// Knowing that (a) is less then 100. 
/// Example:
/// >>> is_multiply_prime(30)
/// true
/// 30 = 2 * 3 * 5
fn is_multiply_prime(a: isize) -> bool {

    todo!()
}

fn main() {
    let candidate = is_multiply_prime;
    assert_eq!(candidate(5), false);
    assert_eq!(candidate(30), true);
    assert_eq!(candidate(8), true);
    assert_eq!(candidate(10), false);
    assert_eq!(candidate(125), true);
    assert_eq!(candidate(105), true);
    assert_eq!(candidate(126), false);
    assert_eq!(candidate(729), false);
    assert_eq!(candidate(891), false);
    assert_eq!(candidate(1001), true);
}

-----------------------------
/// Write a function that returns true if the given number is the multiplication of 3 prime numbers
/// and false otherwise.
/// Knowing that (a) is less then 100. 
/// Example:
/// >>> is_multiply_prime(30)
/// true
/// 30 = 2 * 3 * 5
fn is_multiply_prime(a: isize) -> bool {

    // TODO: solve the problem
    unimplemented!();
}

fn main() {
    let candidate = is_multiply_prime;
    assert_eq!(candidate(5), false);
    assert_eq!(candidate(30), true);
    assert_eq!(candidate(8), true);
    assert_eq!(candidate(10), false);
    assert_eq!(candidate(125), true);
    assert_eq!(candidate(105), true);
    assert_eq!(candidate(126), false);
    assert_eq!(candidate(729), false);
    assert_eq!(candidate(891), false);
    assert_eq!(candidate(1001), true);
}

-----------------------------
/// Write a function that returns true if the given number is the multiplication of 3 prime numbers
/// and false otherwise.
/// Knowing that (a) is less then 100. 
/// Example:
/// >>> is_multiply_prime(30)
/// true
/// 30 = 2 * 3 * 5
fn is_multiply_prime(a: isize) -> bool {

    let mut b = a;
    let mut c = 0;
    let mut d = 0;
    let mut e = 0;
    let mut f = 0;
    while b > 0 {
        if b % 3 == 0 {
            e += 1;
            b = b / 3;
        } else {
            b = b - 1;
        }
    }
    if e == 3 {
        c = a / 3;
        f = c / 3;
        d = c - f;
        if is_prime(f) && is_prime(d) && is_prime(c - 2 * f) {
            return true;
        } else {
            return false;
        }
    }
    return false;
}

fn main() {
    let candidate = is_multiply_prime;
    assert_eq!(candidate(5), false);
    assert_eq!(candidate(30), true);
    assert_eq!(candidate(8), true);
    assert_eq!(candidate(10), false);
    assert_eq!(candidate(125), true);
    assert_eq!(candidate(105), true);
    assert_eq!(candidate(126), false);
    assert_eq!(candidate(729), false);
    assert_eq!(candidate(891), false);
    assert_eq!(candidate(1001), true);
}

-----------------------------
/// Write a function that returns true if the given number is the multiplication of 3 prime numbers
/// and false otherwise.
/// Knowing that (a) is less then 100. 
/// Example:
/// >>> is_multiply_prime(30)
/// true
/// 30 = 2 * 3 * 5
fn is_multiply_prime(a: isize) -> bool {

    if a % 2 == 0 || a % 3 == 0 || a % 5 == 0 {
        false
    } else if is_divisible(a, 2) {
        false
    } else if is_divisible(a, 3) {
        false
    } else if is_divisible(a, 5) {
        false
    } else {
        true
    }
}

fn main() {
    let candidate = is_multiply_prime;
    assert_eq!(candidate(5), false);
    assert_eq!(candidate(30), true);
    assert_eq!(candidate(8), true);
    assert_eq!(candidate(10), false);
    assert_eq!(candidate(125), true);
    assert_eq!(candidate(105), true);
    assert_eq!(candidate(126), false);
    assert_eq!(candidate(729), false);
    assert_eq!(candidate(891), false);
    assert_eq!(candidate(1001), true);
}

-----------------------------
/// Write a function that returns true if the given number is the multiplication of 3 prime numbers
/// and false otherwise.
/// Knowing that (a) is less then 100. 
/// Example:
/// >>> is_multiply_prime(30)
/// true
/// 30 = 2 * 3 * 5
fn is_multiply_prime(a: isize) -> bool {

    let mut n = a;
    let mut p = 0;
    let mut x = 2;
    while x <= 100 && n > 1 {
        while n % x == 0 {
            p += 1;
            n /= x;
        }
        x += 1;
    }
    if n > 1 {
        p += 1;
    }
    return p == 3;
}

fn main() {
    let candidate = is_multiply_prime;
    assert_eq!(candidate(5), false);
    assert_eq!(candidate(30), true);
    assert_eq!(candidate(8), true);
    assert_eq!(candidate(10), false);
    assert_eq!(candidate(125), true);
    assert_eq!(candidate(105), true);
    assert_eq!(candidate(126), false);
    assert_eq!(candidate(729), false);
    assert_eq!(candidate(891), false);
    assert_eq!(candidate(1001), true);
}

===============================
/// Your task is to write a function that returns true if a number x is a simple
/// power of n and false in other cases.
/// x is a simple power of n if n**int=x
/// For example:
/// >>> is_simple_power(1, 4)
/// true
/// >>> is_simple_power(2, 2)
/// true
/// >>> is_simple_power(8, 2)
/// true
/// >>> is_simple_power(3, 2)
/// false
/// >>> is_simple_power(3, 1)
/// false
/// >>> is_simple_power(5, 3)
/// false
fn is_simple_power(x: isize, n: isize) -> bool {

===============================
-----------------------------
/// Your task is to write a function that returns true if a number x is a simple
/// power of n and false in other cases.
/// x is a simple power of n if n**int=x
/// For example:
/// >>> is_simple_power(1, 4)
/// true
/// >>> is_simple_power(2, 2)
/// true
/// >>> is_simple_power(8, 2)
/// true
/// >>> is_simple_power(3, 2)
/// false
/// >>> is_simple_power(3, 1)
/// false
/// >>> is_simple_power(5, 3)
/// false
fn is_simple_power(x: isize, n: isize) -> bool {

    if x == 1 {
        return true;
    }
    if x < 1 {
        return false;
    }
    if n == 1 {
        return true;
    }
    if n == 0 {
        return false;
    }
    let x = x as f64;
    let n = n as f64;
    let root = n.sqrt();
    let root = root.floor();
    if root * root == x {
        true
    } else {
        false
    }
}

fn main() {
    let candidate = is_simple_power;
    assert_eq!(candidate(16, 2), true);
    assert_eq!(candidate(143214, 16), false);
    assert_eq!(candidate(4, 2), true);
    assert_eq!(candidate(9, 3), true);
    assert_eq!(candidate(16, 4), true);
    assert_eq!(candidate(24, 2), false);
    assert_eq!(candidate(128, 4), false);
    assert_eq!(candidate(12, 6), false);
    assert_eq!(candidate(1, 1), true);
    assert_eq!(candidate(1, 12), true);
}

-----------------------------
/// Your task is to write a function that returns true if a number x is a simple
/// power of n and false in other cases.
/// x is a simple power of n if n**int=x
/// For example:
/// >>> is_simple_power(1, 4)
/// true
/// >>> is_simple_power(2, 2)
/// true
/// >>> is_simple_power(8, 2)
/// true
/// >>> is_simple_power(3, 2)
/// false
/// >>> is_simple_power(3, 1)
/// false
/// >>> is_simple_power(5, 3)
/// false
fn is_simple_power(x: isize, n: isize) -> bool {

    // Fill in the missing code
    if x == 1 || n == 1 { return true }
    if x < 0 || n < 0 { return false }

    for i in 0.. {
        if i * i == x {
            if n == 2 { return true }
            if (i as f64).powf(n as f64) == (x as f64) {
                return true
            }
            break
        }
    }

    false
}

fn main() {
    let candidate = is_simple_power;
    assert_eq!(candidate(16, 2), true);
    assert_eq!(candidate(143214, 16), false);
    assert_eq!(candidate(4, 2), true);
    assert_eq!(candidate(9, 3), true);
    assert_eq!(candidate(16, 4), true);
    assert_eq!(candidate(24, 2), false);
    assert_eq!(candidate(128, 4), false);
    assert_eq!(candidate(12, 6), false);
    assert_eq!(candidate(1, 1), true);
    assert_eq!(candidate(1, 12), true);
}

-----------------------------
/// Your task is to write a function that returns true if a number x is a simple
/// power of n and false in other cases.
/// x is a simple power of n if n**int=x
/// For example:
/// >>> is_simple_power(1, 4)
/// true
/// >>> is_simple_power(2, 2)
/// true
/// >>> is_simple_power(8, 2)
/// true
/// >>> is_simple_power(3, 2)
/// false
/// >>> is_simple_power(3, 1)
/// false
/// >>> is_simple_power(5, 3)
/// false
fn is_simple_power(x: isize, n: isize) -> bool {

    match n {
        0 => x == 1,
        1 => x == 1 || x == n,
        _ => x == 1 || x == n || x == n * is_simple_power(n, n-1),
    }
}

fn main() {
    let candidate = is_simple_power;
    assert_eq!(candidate(16, 2), true);
    assert_eq!(candidate(143214, 16), false);
    assert_eq!(candidate(4, 2), true);
    assert_eq!(candidate(9, 3), true);
    assert_eq!(candidate(16, 4), true);
    assert_eq!(candidate(24, 2), false);
    assert_eq!(candidate(128, 4), false);
    assert_eq!(candidate(12, 6), false);
    assert_eq!(candidate(1, 1), true);
    assert_eq!(candidate(1, 12), true);
}

-----------------------------
/// Your task is to write a function that returns true if a number x is a simple
/// power of n and false in other cases.
/// x is a simple power of n if n**int=x
/// For example:
/// >>> is_simple_power(1, 4)
/// true
/// >>> is_simple_power(2, 2)
/// true
/// >>> is_simple_power(8, 2)
/// true
/// >>> is_simple_power(3, 2)
/// false
/// >>> is_simple_power(3, 1)
/// false
/// >>> is_simple_power(5, 3)
/// false
fn is_simple_power(x: isize, n: isize) -> bool {

    let x_as_string = x.to_string();
    let n_as_string = n.to_string();
    x_as_string.eq(&n_as_string.repeat(x as usize))
}

fn main() {
    let candidate = is_simple_power;
    assert_eq!(candidate(16, 2), true);
    assert_eq!(candidate(143214, 16), false);
    assert_eq!(candidate(4, 2), true);
    assert_eq!(candidate(9, 3), true);
    assert_eq!(candidate(16, 4), true);
    assert_eq!(candidate(24, 2), false);
    assert_eq!(candidate(128, 4), false);
    assert_eq!(candidate(12, 6), false);
    assert_eq!(candidate(1, 1), true);
    assert_eq!(candidate(1, 12), true);
}

-----------------------------
/// Your task is to write a function that returns true if a number x is a simple
/// power of n and false in other cases.
/// x is a simple power of n if n**int=x
/// For example:
/// >>> is_simple_power(1, 4)
/// true
/// >>> is_simple_power(2, 2)
/// true
/// >>> is_simple_power(8, 2)
/// true
/// >>> is_simple_power(3, 2)
/// false
/// >>> is_simple_power(3, 1)
/// false
/// >>> is_simple_power(5, 3)
/// false
fn is_simple_power(x: isize, n: isize) -> bool {

    if x < 0 || n < 0 {
        false
    } else {
        x == n * n * n
    }
}

fn main() {
    let candidate = is_simple_power;
    assert_eq!(candidate(16, 2), true);
    assert_eq!(candidate(143214, 16), false);
    assert_eq!(candidate(4, 2), true);
    assert_eq!(candidate(9, 3), true);
    assert_eq!(candidate(16, 4), true);
    assert_eq!(candidate(24, 2), false);
    assert_eq!(candidate(128, 4), false);
    assert_eq!(candidate(12, 6), false);
    assert_eq!(candidate(1, 1), true);
    assert_eq!(candidate(1, 12), true);
}

===============================
/// Write a function that takes an integer a and returns true 
/// if this ingeger is a cube of some integer number.
/// Note: you may assume the input is always valid.
/// Examples:
/// >>> iscube(1)
/// true
/// >>> iscube(2)
/// false
/// >>> iscube(-1)
/// true
/// >>> iscube(64)
/// true
/// >>> iscube(0)
/// true
/// >>> iscube(180)
/// false
fn iscube(a: isize) -> bool {

===============================
-----------------------------
/// Write a function that takes an integer a and returns true 
/// if this ingeger is a cube of some integer number.
/// Note: you may assume the input is always valid.
/// Examples:
/// >>> iscube(1)
/// true
/// >>> iscube(2)
/// false
/// >>> iscube(-1)
/// true
/// >>> iscube(64)
/// true
/// >>> iscube(0)
/// true
/// >>> iscube(180)
/// false
fn iscube(a: isize) -> bool {

    // Write an answer using the `assert_eq!` macro
    // from the `std::assertions` module.
    assert_eq!(true, true);
    true
}

fn main() {
    let candidate = iscube;
    assert_eq!(candidate(1), true);
    assert_eq!(candidate(2), false);
    assert_eq!(candidate(-1), true);
    assert_eq!(candidate(64), true);
    assert_eq!(candidate(180), false);
    assert_eq!(candidate(1000), true);
    assert_eq!(candidate(0), true);
    assert_eq!(candidate(1729), false);
}

-----------------------------
/// Write a function that takes an integer a and returns true 
/// if this ingeger is a cube of some integer number.
/// Note: you may assume the input is always valid.
/// Examples:
/// >>> iscube(1)
/// true
/// >>> iscube(2)
/// false
/// >>> iscube(-1)
/// true
/// >>> iscube(64)
/// true
/// >>> iscube(0)
/// true
/// >>> iscube(180)
/// false
fn iscube(a: isize) -> bool {

    // Implement me!
    return true;
}

fn main() {
    let candidate = iscube;
    assert_eq!(candidate(1), true);
    assert_eq!(candidate(2), false);
    assert_eq!(candidate(-1), true);
    assert_eq!(candidate(64), true);
    assert_eq!(candidate(180), false);
    assert_eq!(candidate(1000), true);
    assert_eq!(candidate(0), true);
    assert_eq!(candidate(1729), false);
}

-----------------------------
/// Write a function that takes an integer a and returns true 
/// if this ingeger is a cube of some integer number.
/// Note: you may assume the input is always valid.
/// Examples:
/// >>> iscube(1)
/// true
/// >>> iscube(2)
/// false
/// >>> iscube(-1)
/// true
/// >>> iscube(64)
/// true
/// >>> iscube(0)
/// true
/// >>> iscube(180)
/// false
fn iscube(a: isize) -> bool {

    let result: Vec<bool> = (1..a + 1)
        .filter(|x| {
            let x_cube: isize = x.pow(3);
            x_cube == a
        }).collect();
    if result.len() > 0 {
        true
    } else {
        false
    }
}

fn main() {
    let candidate = iscube;
    assert_eq!(candidate(1), true);
    assert_eq!(candidate(2), false);
    assert_eq!(candidate(-1), true);
    assert_eq!(candidate(64), true);
    assert_eq!(candidate(180), false);
    assert_eq!(candidate(1000), true);
    assert_eq!(candidate(0), true);
    assert_eq!(candidate(1729), false);
}

-----------------------------
/// Write a function that takes an integer a and returns true 
/// if this ingeger is a cube of some integer number.
/// Note: you may assume the input is always valid.
/// Examples:
/// >>> iscube(1)
/// true
/// >>> iscube(2)
/// false
/// >>> iscube(-1)
/// true
/// >>> iscube(64)
/// true
/// >>> iscube(0)
/// true
/// >>> iscube(180)
/// false
fn iscube(a: isize) -> bool {

    let x = a.pow(1.0/3.0) as isize;
    x * x * x == a
}

fn main() {
    let candidate = iscube;
    assert_eq!(candidate(1), true);
    assert_eq!(candidate(2), false);
    assert_eq!(candidate(-1), true);
    assert_eq!(candidate(64), true);
    assert_eq!(candidate(180), false);
    assert_eq!(candidate(1000), true);
    assert_eq!(candidate(0), true);
    assert_eq!(candidate(1729), false);
}

-----------------------------
/// Write a function that takes an integer a and returns true 
/// if this ingeger is a cube of some integer number.
/// Note: you may assume the input is always valid.
/// Examples:
/// >>> iscube(1)
/// true
/// >>> iscube(2)
/// false
/// >>> iscube(-1)
/// true
/// >>> iscube(64)
/// true
/// >>> iscube(0)
/// true
/// >>> iscube(180)
/// false
fn iscube(a: isize) -> bool {

    let b = a.pow(1.0/3.0).round() as isize;
    let b = b * b * b;
    a == b
}

fn main() {
    let candidate = iscube;
    assert_eq!(candidate(1), true);
    assert_eq!(candidate(2), false);
    assert_eq!(candidate(-1), true);
    assert_eq!(candidate(64), true);
    assert_eq!(candidate(180), false);
    assert_eq!(candidate(1000), true);
    assert_eq!(candidate(0), true);
    assert_eq!(candidate(1729), false);
}

===============================
/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(String::from("AB"))
/// 1
/// >>> hex_key(String::from("1077E"))
/// 2
/// >>> hex_key(String::from("ABED1A33"))
/// 4
/// >>> hex_key(String::from("123456789ABCDEF0"))
/// 6
/// >>> hex_key(String::from("2020"))
/// 2
fn hex_key(num: String) -> isize {

===============================
-----------------------------
/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(String::from("AB"))
/// 1
/// >>> hex_key(String::from("1077E"))
/// 2
/// >>> hex_key(String::from("ABED1A33"))
/// 4
/// >>> hex_key(String::from("123456789ABCDEF0"))
/// 6
/// >>> hex_key(String::from("2020"))
/// 2
fn hex_key(num: String) -> isize {

    let mut counter = 0;
    let mut hex_arr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

    if num.is_empty() {
        return 0;
    }

    for i in 0..num.len() {
        hex_arr[num.as_bytes()[i] as usize] += 1;
    }

    for i in 0..16 {
        if hex_arr[i] > 0 {
            if prime_check(i) {
                counter += 1;
            }
        }
    }

    counter
}

fn main() {
    let candidate = hex_key;
    assert_eq!(candidate(String::from("AB")), 1);
    assert_eq!(candidate(String::from("1077E")), 2);
    assert_eq!(candidate(String::from("ABED1A33")), 4);
    assert_eq!(candidate(String::from("2020")), 2);
    assert_eq!(candidate(String::from("123456789ABCDEF0")), 6);
    assert_eq!(candidate(String::from("112233445566778899AABBCCDDEEFF00")), 12);
}

-----------------------------
/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(String::from("AB"))
/// 1
/// >>> hex_key(String::from("1077E"))
/// 2
/// >>> hex_key(String::from("ABED1A33"))
/// 4
/// >>> hex_key(String::from("123456789ABCDEF0"))
/// 6
/// >>> hex_key(String::from("2020"))
/// 2
fn hex_key(num: String) -> isize {

    let mut num: Vec<char> = num.chars().collect();
    num.retain(|x| *x != '0');
    let mut hex_num: Vec<char> = vec!['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];
    let mut prime_num: Vec<isize> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641,
}

fn main() {
    let candidate = hex_key;
    assert_eq!(candidate(String::from("AB")), 1);
    assert_eq!(candidate(String::from("1077E")), 2);
    assert_eq!(candidate(String::from("ABED1A33")), 4);
    assert_eq!(candidate(String::from("2020")), 2);
    assert_eq!(candidate(String::from("123456789ABCDEF0")), 6);
    assert_eq!(candidate(String::from("112233445566778899AABBCCDDEEFF00")), 12);
}

-----------------------------
/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(String::from("AB"))
/// 1
/// >>> hex_key(String::from("1077E"))
/// 2
/// >>> hex_key(String::from("ABED1A33"))
/// 4
/// >>> hex_key(String::from("123456789ABCDEF0"))
/// 6
/// >>> hex_key(String::from("2020"))
/// 2
fn hex_key(num: String) -> isize {

    let arr = num.chars().collect::<Vec<char>>();
    let mut count: isize = 0;
    for i in arr {
        let j = i as u8;
        if j == 'A' as u8 {
            count += 1;
        } else if j == 'B' as u8 {
            count += 1;
        } else if j == 'C' as u8 {
            count += 1;
        } else if j == 'D' as u8 {
            count += 1;
        } else if j == 'E' as u8 {
            count += 1;
        } else if j == 'F' as u8 {
            count += 1;
        } else {
            if is_prime(j as isize) {
                count += 1;
            }
        }
    }
    count
}

fn main() {
    let candidate = hex_key;
    assert_eq!(candidate(String::from("AB")), 1);
    assert_eq!(candidate(String::from("1077E")), 2);
    assert_eq!(candidate(String::from("ABED1A33")), 4);
    assert_eq!(candidate(String::from("2020")), 2);
    assert_eq!(candidate(String::from("123456789ABCDEF0")), 6);
    assert_eq!(candidate(String::from("112233445566778899AABBCCDDEEFF00")), 12);
}

-----------------------------
/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(String::from("AB"))
/// 1
/// >>> hex_key(String::from("1077E"))
/// 2
/// >>> hex_key(String::from("ABED1A33"))
/// 4
/// >>> hex_key(String::from("123456789ABCDEF0"))
/// 6
/// >>> hex_key(String::from("2020"))
/// 2
fn hex_key(num: String) -> isize {

    let mut count = 0;

    for c in num.chars() {
        if let Some(digit) = to_digit(c) {
            if digit < 10 {
                if is_prime(digit) {
                    count += 1;
                }
            }
        }
    }
    return count;
}

fn main() {
    let candidate = hex_key;
    assert_eq!(candidate(String::from("AB")), 1);
    assert_eq!(candidate(String::from("1077E")), 2);
    assert_eq!(candidate(String::from("ABED1A33")), 4);
    assert_eq!(candidate(String::from("2020")), 2);
    assert_eq!(candidate(String::from("123456789ABCDEF0")), 6);
    assert_eq!(candidate(String::from("112233445566778899AABBCCDDEEFF00")), 12);
}

-----------------------------
/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(String::from("AB"))
/// 1
/// >>> hex_key(String::from("1077E"))
/// 2
/// >>> hex_key(String::from("ABED1A33"))
/// 4
/// >>> hex_key(String::from("123456789ABCDEF0"))
/// 6
/// >>> hex_key(String::from("2020"))
/// 2
fn hex_key(num: String) -> isize {

    let mut hex = String::from("0123456789ABCDEF");
    let mut cnt = 0;
    for x in num.chars() {
        let idx = hex.find(x).unwrap();
        if is_prime(idx) {
            cnt += 1;
        }
    }
    cnt
}

fn main() {
    let candidate = hex_key;
    assert_eq!(candidate(String::from("AB")), 1);
    assert_eq!(candidate(String::from("1077E")), 2);
    assert_eq!(candidate(String::from("ABED1A33")), 4);
    assert_eq!(candidate(String::from("2020")), 2);
    assert_eq!(candidate(String::from("123456789ABCDEF0")), 6);
    assert_eq!(candidate(String::from("112233445566778899AABBCCDDEEFF00")), 12);
}

===============================
/// You will be given a number in decimal form and your task is to convert it to
/// binary format. The function should return a string, with each character representing a binary
/// number. Each character in the string will be '0' or '1'.
/// There will be an extra couple of characters 'db' at the beginning and at the end of the string.
/// The extra characters are there to help with the format.
/// Examples:
/// >>> decimal_to_binary(15)
/// String::from("db1111db")
/// >>> decimal_to_binary(32)
/// String::from("db100000db")
fn decimal_to_binary(decimal: isize) -> String {

===============================
-----------------------------
/// You will be given a number in decimal form and your task is to convert it to
/// binary format. The function should return a string, with each character representing a binary
/// number. Each character in the string will be '0' or '1'.
/// There will be an extra couple of characters 'db' at the beginning and at the end of the string.
/// The extra characters are there to help with the format.
/// Examples:
/// >>> decimal_to_binary(15)
/// String::from("db1111db")
/// >>> decimal_to_binary(32)
/// String::from("db100000db")
fn decimal_to_binary(decimal: isize) -> String {

    // Start with the number 0, and add 1 to it for each loop iteration.
    let mut result = String::from("db");
    let mut counter = decimal;
    while counter > 0 {
        // Divide the counter by 2.
        // This will get the remainder of the division if the counter is even.
        // Otherwise, it will get the remainder of the division if the counter is odd.
        // The remainder is the last digit of the decimal.
        // Example:
        // If we divide 13 by 2, the remainder is 1.
        // If we divide 12 by 2, the remainder is 0.
        let remainder = counter % 2;
        counter = counter / 2;

        // If the remainder is equal to 1, append a 1 to the string.
        // Otherwise, append a 0 to the string.
        if remainder == 1 {
            result.push('1');
        } else {
            result.push('0');
        }
    }
    // Add a db at the end of the string.
    result.push('d');
    result.push('b');
    result
}

fn main() {
    let candidate = decimal_to_binary;
    assert_eq!(candidate(0), String::from("db0db"));
    assert_eq!(candidate(32), String::from("db100000db"));
    assert_eq!(candidate(103), String::from("db1100111db"));
    assert_eq!(candidate(15), String::from("db1111db"));
}

-----------------------------
/// You will be given a number in decimal form and your task is to convert it to
/// binary format. The function should return a string, with each character representing a binary
/// number. Each character in the string will be '0' or '1'.
/// There will be an extra couple of characters 'db' at the beginning and at the end of the string.
/// The extra characters are there to help with the format.
/// Examples:
/// >>> decimal_to_binary(15)
/// String::from("db1111db")
/// >>> decimal_to_binary(32)
/// String::from("db100000db")
fn decimal_to_binary(decimal: isize) -> String {

    format!("db{}db", (decimal as u32).to_binary())
}

fn main() {
    let candidate = decimal_to_binary;
    assert_eq!(candidate(0), String::from("db0db"));
    assert_eq!(candidate(32), String::from("db100000db"));
    assert_eq!(candidate(103), String::from("db1100111db"));
    assert_eq!(candidate(15), String::from("db1111db"));
}

-----------------------------
/// You will be given a number in decimal form and your task is to convert it to
/// binary format. The function should return a string, with each character representing a binary
/// number. Each character in the string will be '0' or '1'.
/// There will be an extra couple of characters 'db' at the beginning and at the end of the string.
/// The extra characters are there to help with the format.
/// Examples:
/// >>> decimal_to_binary(15)
/// String::from("db1111db")
/// >>> decimal_to_binary(32)
/// String::from("db100000db")
fn decimal_to_binary(decimal: isize) -> String {

    // TODO
    // HINT: use String::from_iter()
    let mut string = String::from("db");

    // let mut string = String::from("db");
    // let mut remainder: isize = decimal;
    // let mut remainder_string = String::new();
    // while remainder > 0 {
    //     let temp = remainder % 2;
    //     remainder /= 2;
    //     remainder_string = format!("{}", temp);
    //     string.push_str(&remainder_string);
    // }
    // string.push_str("db");
    // println!("{}", string);
    // return string;

    // HINT2: use format!(), isize.to_string()

    // HINT3:  isize.push_str()
    let mut result = String::new();
    for i in 0..33 {
        let number = decimal % 2;
        decimal /= 2;
        result.push_str(&number.to_string());
        if decimal == 0 {
            break;
        }
    }
    return format!("db{}db", result);
    // return format!("db{}db", decimal.to_string());
    // return format!("db{}db", result);
}

fn main() {
    let candidate = decimal_to_binary;
    assert_eq!(candidate(0), String::from("db0db"));
    assert_eq!(candidate(32), String::from("db100000db"));
    assert_eq!(candidate(103), String::from("db1100111db"));
    assert_eq!(candidate(15), String::from("db1111db"));
}

-----------------------------
/// You will be given a number in decimal form and your task is to convert it to
/// binary format. The function should return a string, with each character representing a binary
/// number. Each character in the string will be '0' or '1'.
/// There will be an extra couple of characters 'db' at the beginning and at the end of the string.
/// The extra characters are there to help with the format.
/// Examples:
/// >>> decimal_to_binary(15)
/// String::from("db1111db")
/// >>> decimal_to_binary(32)
/// String::from("db100000db")
fn decimal_to_binary(decimal: isize) -> String {

    format!("db{}db", decimal.to_string(2))
}

fn main() {
    let candidate = decimal_to_binary;
    assert_eq!(candidate(0), String::from("db0db"));
    assert_eq!(candidate(32), String::from("db100000db"));
    assert_eq!(candidate(103), String::from("db1100111db"));
    assert_eq!(candidate(15), String::from("db1111db"));
}

-----------------------------
/// You will be given a number in decimal form and your task is to convert it to
/// binary format. The function should return a string, with each character representing a binary
/// number. Each character in the string will be '0' or '1'.
/// There will be an extra couple of characters 'db' at the beginning and at the end of the string.
/// The extra characters are there to help with the format.
/// Examples:
/// >>> decimal_to_binary(15)
/// String::from("db1111db")
/// >>> decimal_to_binary(32)
/// String::from("db100000db")
fn decimal_to_binary(decimal: isize) -> String {

    if decimal < 0 {
        return String::from("error");
    }
    let binary_string = decimal.to_string(2);
    let mut binary_string_reversed = String::from("db");
    for c in binary_string.chars().rev() {
        binary_string_reversed.push(c);
    }
    binary_string_reversed.push_str("db");
    binary_string_reversed
}

fn main() {
    let candidate = decimal_to_binary;
    assert_eq!(candidate(0), String::from("db0db"));
    assert_eq!(candidate(32), String::from("db100000db"));
    assert_eq!(candidate(103), String::from("db1100111db"));
    assert_eq!(candidate(15), String::from("db1111db"));
}

===============================
/// You are given a string s.
/// Your task is to check if the string is haprs or not.
/// A string is haprs if its length is at least 3 and every 3 consecutive letters are distinct
/// For example:
/// >>> is_happy(String::from("a"))
/// false
/// >>> is_happy(String::from("aa"))
/// false
/// >>> is_happy(String::from("abcd"))
/// true
/// >>> is_happy(String::from("aabb"))
/// false
/// >>> is_happy(String::from("adb"))
/// true
/// >>> is_happy(String::from("xyy"))
/// false
fn is_happy(s: String) -> bool {

===============================
-----------------------------
/// You are given a string s.
/// Your task is to check if the string is haprs or not.
/// A string is haprs if its length is at least 3 and every 3 consecutive letters are distinct
/// For example:
/// >>> is_happy(String::from("a"))
/// false
/// >>> is_happy(String::from("aa"))
/// false
/// >>> is_happy(String::from("abcd"))
/// true
/// >>> is_happy(String::from("aabb"))
/// false
/// >>> is_happy(String::from("adb"))
/// true
/// >>> is_happy(String::from("xyy"))
/// false
fn is_happy(s: String) -> bool {

    let mut v: Vec<char> = s.chars().collect();
    let mut p = 0;
    while p < v.len() - 2 {
        if v[p] == v[p + 1] || v[p] == v[p + 2] || v[p + 1] == v[p + 2] {
            return false;
        }
        p += 1;
    }
    true
}

fn main() {
    let candidate = is_happy;
    assert_eq!(candidate(String::from("a")), false);
    assert_eq!(candidate(String::from("aa")), false);
    assert_eq!(candidate(String::from("abcd")), true);
    assert_eq!(candidate(String::from("aabb")), false);
    assert_eq!(candidate(String::from("adb")), true);
    assert_eq!(candidate(String::from("xyy")), false);
    assert_eq!(candidate(String::from("iopaxpoi")), true);
    assert_eq!(candidate(String::from("iopaxioi")), false);
}

-----------------------------
/// You are given a string s.
/// Your task is to check if the string is haprs or not.
/// A string is haprs if its length is at least 3 and every 3 consecutive letters are distinct
/// For example:
/// >>> is_happy(String::from("a"))
/// false
/// >>> is_happy(String::from("aa"))
/// false
/// >>> is_happy(String::from("abcd"))
/// true
/// >>> is_happy(String::from("aabb"))
/// false
/// >>> is_happy(String::from("adb"))
/// true
/// >>> is_happy(String::from("xyy"))
/// false
fn is_happy(s: String) -> bool {

    if s.len() < 3 {
        return false;
    }
    let mut result = 0;
    let mut index = 0;
    loop {
        result = result + index;
        if result > s.len() - 2 {
            return true;
        }
        index += 1;
    }
}

fn main() {
    let candidate = is_happy;
    assert_eq!(candidate(String::from("a")), false);
    assert_eq!(candidate(String::from("aa")), false);
    assert_eq!(candidate(String::from("abcd")), true);
    assert_eq!(candidate(String::from("aabb")), false);
    assert_eq!(candidate(String::from("adb")), true);
    assert_eq!(candidate(String::from("xyy")), false);
    assert_eq!(candidate(String::from("iopaxpoi")), true);
    assert_eq!(candidate(String::from("iopaxioi")), false);
}

-----------------------------
/// You are given a string s.
/// Your task is to check if the string is haprs or not.
/// A string is haprs if its length is at least 3 and every 3 consecutive letters are distinct
/// For example:
/// >>> is_happy(String::from("a"))
/// false
/// >>> is_happy(String::from("aa"))
/// false
/// >>> is_happy(String::from("abcd"))
/// true
/// >>> is_happy(String::from("aabb"))
/// false
/// >>> is_happy(String::from("adb"))
/// true
/// >>> is_happy(String::from("xyy"))
/// false
fn is_happy(s: String) -> bool {

    let v = s.bytes().collect::<Vec<u8>>();
    let mut cnt = 0;
    for i in 0..v.len() {
        if i + 3 <= v.len() {
            if &v[i..i+3] == &v[i+1..i+4] {
                cnt += 1;
                if cnt >= 3 {
                    return false;
                }
            }
        }
    }
    return true;
}

fn main() {
    let candidate = is_happy;
    assert_eq!(candidate(String::from("a")), false);
    assert_eq!(candidate(String::from("aa")), false);
    assert_eq!(candidate(String::from("abcd")), true);
    assert_eq!(candidate(String::from("aabb")), false);
    assert_eq!(candidate(String::from("adb")), true);
    assert_eq!(candidate(String::from("xyy")), false);
    assert_eq!(candidate(String::from("iopaxpoi")), true);
    assert_eq!(candidate(String::from("iopaxioi")), false);
}

-----------------------------
/// You are given a string s.
/// Your task is to check if the string is haprs or not.
/// A string is haprs if its length is at least 3 and every 3 consecutive letters are distinct
/// For example:
/// >>> is_happy(String::from("a"))
/// false
/// >>> is_happy(String::from("aa"))
/// false
/// >>> is_happy(String::from("abcd"))
/// true
/// >>> is_happy(String::from("aabb"))
/// false
/// >>> is_happy(String::from("adb"))
/// true
/// >>> is_happy(String::from("xyy"))
/// false
fn is_happy(s: String) -> bool {

    let s = s.as_str();
    let mut result = true;

    for i in 0..s.len() {
        let a = &s[i..i + 3];

        if a.eq(a.to_lowercase().as_str()) {
            result = false;
            break;
        }
    }

    result
}

fn main() {
    let candidate = is_happy;
    assert_eq!(candidate(String::from("a")), false);
    assert_eq!(candidate(String::from("aa")), false);
    assert_eq!(candidate(String::from("abcd")), true);
    assert_eq!(candidate(String::from("aabb")), false);
    assert_eq!(candidate(String::from("adb")), true);
    assert_eq!(candidate(String::from("xyy")), false);
    assert_eq!(candidate(String::from("iopaxpoi")), true);
    assert_eq!(candidate(String::from("iopaxioi")), false);
}

-----------------------------
/// You are given a string s.
/// Your task is to check if the string is haprs or not.
/// A string is haprs if its length is at least 3 and every 3 consecutive letters are distinct
/// For example:
/// >>> is_happy(String::from("a"))
/// false
/// >>> is_happy(String::from("aa"))
/// false
/// >>> is_happy(String::from("abcd"))
/// true
/// >>> is_happy(String::from("aabb"))
/// false
/// >>> is_happy(String::from("adb"))
/// true
/// >>> is_happy(String::from("xyy"))
/// false
fn is_happy(s: String) -> bool {

    if s.len() < 3 {
        return false;
    }
    let mut count = HashMap::new();
    for _ in 0..s.len() / 3 {
        let ch = s[..3].chars().collect::<String>();
        if count.contains_key(&ch) {
            return false;
        } else {
            count.insert(ch, 1);
        }
        s.remove(0);
    }
    true
}

fn main() {
    let candidate = is_happy;
    assert_eq!(candidate(String::from("a")), false);
    assert_eq!(candidate(String::from("aa")), false);
    assert_eq!(candidate(String::from("abcd")), true);
    assert_eq!(candidate(String::from("aabb")), false);
    assert_eq!(candidate(String::from("adb")), true);
    assert_eq!(candidate(String::from("xyy")), false);
    assert_eq!(candidate(String::from("iopaxpoi")), true);
    assert_eq!(candidate(String::from("iopaxioi")), false);
}

===============================
/// It is the last week of the semester and the teacher has to give the grades
/// to students. The teacher has been making her own algorithm for grading.
/// The only problem is, she has lost the code she used for grading.
/// She has given you a vector of GPAs for some students and you have to write 
/// a function that can output a vector of letter grades using the following table:
/// GPA       |    Letter grade
/// 4.0                A+
/// > 3.7                A 
/// > 3.3                A- 
/// > 3.0                B+
/// > 2.7                B 
/// > 2.3                B-
/// > 2.0                C+
/// > 1.7                C
/// > 1.3                C-
/// > 1.0                D+ 
/// > 0.7                D 
/// > 0.0                D-
/// 0.0                E
/// Example:
/// >>> grade_equation(vec![4.0, 3, 1.7, 2, 3.5])
/// vec![String::from("A+"), String::from("B"), String::from("C-"), String::from("C"), String::from("A-")]
fn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {

===============================
-----------------------------
/// It is the last week of the semester and the teacher has to give the grades
/// to students. The teacher has been making her own algorithm for grading.
/// The only problem is, she has lost the code she used for grading.
/// She has given you a vector of GPAs for some students and you have to write 
/// a function that can output a vector of letter grades using the following table:
/// GPA       |    Letter grade
/// 4.0                A+
/// > 3.7                A 
/// > 3.3                A- 
/// > 3.0                B+
/// > 2.7                B 
/// > 2.3                B-
/// > 2.0                C+
/// > 1.7                C
/// > 1.3                C-
/// > 1.0                D+ 
/// > 0.7                D 
/// > 0.0                D-
/// 0.0                E
/// Example:
/// >>> grade_equation(vec![4.0, 3, 1.7, 2, 3.5])
/// vec![String::from("A+"), String::from("B"), String::from("C-"), String::from("C"), String::from("A-")]
fn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {

    let mut letter_grades = Vec::new();
    for grade in grades {
        if grade >= 4.0 {
            letter_grades.push("A+".to_string());
        } else if grade >= 3.7 {
            letter_grades.push("A".to_string());
        } else if grade >= 3.3 {
            letter_grades.push("A-".to_string());
        } else if grade >= 3.0 {
            letter_grades.push("B+".to_string());
        } else if grade >= 2.7 {
            letter_grades.push("B".to_string());
        } else if grade >= 2.3 {
            letter_grades.push("B-".to_string());
        } else if grade >= 2.0 {
            letter_grades.push("C+".to_string());
        } else if grade >= 1.7 {
            letter_grades.push("C".to_string());
        } else if grade >= 1.3 {
            letter_grades.push("C-".to_string());
        } else if grade >= 1.0 {
            letter_grades.push("D+".to_string());
        } else if grade >= 0.7 {
            letter_grades.push("D".to_string());
        } else if grade >= 0.0 {
            letter_grades.push("D-".to_string());
        } else {
            letter_grades.push("E".to_string());
        }
    }
    letter_grades
}

fn main() {
    let candidate = numerical_letter_grade;
    assert_eq!(candidate(vec![4.0, 3.0, 1.7, 2.0, 3.5]), vec![String::from("A+"), String::from("B"), String::from("C-"), String::from("C"), String::from("A-")]);
    assert_eq!(candidate(vec![1.2]), vec![String::from("D+")]);
    assert_eq!(candidate(vec![0.5]), vec![String::from("D-")]);
    assert_eq!(candidate(vec![0.0]), vec![String::from("E")]);
    assert_eq!(candidate(vec![1.0, 0.3, 1.5, 2.8, 3.3]), vec![String::from("D"), String::from("D-"), String::from("C-"), String::from("B"), String::from("B+")]);
    assert_eq!(candidate(vec![0.0, 0.7]), vec![String::from("E"), String::from("D-")]);
}

-----------------------------
/// It is the last week of the semester and the teacher has to give the grades
/// to students. The teacher has been making her own algorithm for grading.
/// The only problem is, she has lost the code she used for grading.
/// She has given you a vector of GPAs for some students and you have to write 
/// a function that can output a vector of letter grades using the following table:
/// GPA       |    Letter grade
/// 4.0                A+
/// > 3.7                A 
/// > 3.3                A- 
/// > 3.0                B+
/// > 2.7                B 
/// > 2.3                B-
/// > 2.0                C+
/// > 1.7                C
/// > 1.3                C-
/// > 1.0                D+ 
/// > 0.7                D 
/// > 0.0                D-
/// 0.0                E
/// Example:
/// >>> grade_equation(vec![4.0, 3, 1.7, 2, 3.5])
/// vec![String::from("A+"), String::from("B"), String::from("C-"), String::from("C"), String::from("A-")]
fn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {

    grades
        .iter()
        .map(|g| match *g {
            4.0...5.0 => String::from("A+"),
            3.7...4.0 => String::from("A"),
            3.3...3.7 => String::from("A-"),
            3.0...3.3 => String::from("B+"),
            2.7...3.0 => String::from("B"),
            2.3...2.7 => String::from("B-"),
            2.0...2.3 => String::from("C+"),
            1.7...2.0 => String::from("C"),
            1.3...1.7 => String::from("C-"),
            1.0...1.3 => String::from("D+"),
            0.7...1.0 => String::from("D"),
            0.0...0.7 => String::from("D-"),
            _ => String::from("E"),
        })
        .collect()
}

fn main() {
    let candidate = numerical_letter_grade;
    assert_eq!(candidate(vec![4.0, 3.0, 1.7, 2.0, 3.5]), vec![String::from("A+"), String::from("B"), String::from("C-"), String::from("C"), String::from("A-")]);
    assert_eq!(candidate(vec![1.2]), vec![String::from("D+")]);
    assert_eq!(candidate(vec![0.5]), vec![String::from("D-")]);
    assert_eq!(candidate(vec![0.0]), vec![String::from("E")]);
    assert_eq!(candidate(vec![1.0, 0.3, 1.5, 2.8, 3.3]), vec![String::from("D"), String::from("D-"), String::from("C-"), String::from("B"), String::from("B+")]);
    assert_eq!(candidate(vec![0.0, 0.7]), vec![String::from("E"), String::from("D-")]);
}

-----------------------------
/// It is the last week of the semester and the teacher has to give the grades
/// to students. The teacher has been making her own algorithm for grading.
/// The only problem is, she has lost the code she used for grading.
/// She has given you a vector of GPAs for some students and you have to write 
/// a function that can output a vector of letter grades using the following table:
/// GPA       |    Letter grade
/// 4.0                A+
/// > 3.7                A 
/// > 3.3                A- 
/// > 3.0                B+
/// > 2.7                B 
/// > 2.3                B-
/// > 2.0                C+
/// > 1.7                C
/// > 1.3                C-
/// > 1.0                D+ 
/// > 0.7                D 
/// > 0.0                D-
/// 0.0                E
/// Example:
/// >>> grade_equation(vec![4.0, 3, 1.7, 2, 3.5])
/// vec![String::from("A+"), String::from("B"), String::from("C-"), String::from("C"), String::from("A-")]
fn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {

    let mut vec: Vec<String> = Vec::new();
    for grade in grades {
        if grade >= 4.0 {
            vec.push(String::from("A+"));
        } else if grade >= 3.7 {
            vec.push(String::from("A"));
        } else if grade >= 3.3 {
            vec.push(String::from("A-"));
        } else if grade >= 3.0 {
            vec.push(String::from("B+"));
        } else if grade >= 2.7 {
            vec.push(String::from("B"));
        } else if grade >= 2.3 {
            vec.push(String::from("B-"));
        } else if grade >= 2.0 {
            vec.push(String::from("C+"));
        } else if grade >= 1.7 {
            vec.push(String::from("C"));
        } else if grade >= 1.3 {
            vec.push(String::from("C-"));
        } else if grade >= 1.0 {
            vec.push(String::from("D+"));
        } else if grade >= 0.7 {
            vec.push(String::from("D"));
        } else if grade >= 0.0 {
            vec.push(String::from("D-"));
        } else {
            vec.push(String::from("E"));
        }
    }
    vec
}

fn main() {
    let candidate = numerical_letter_grade;
    assert_eq!(candidate(vec![4.0, 3.0, 1.7, 2.0, 3.5]), vec![String::from("A+"), String::from("B"), String::from("C-"), String::from("C"), String::from("A-")]);
    assert_eq!(candidate(vec![1.2]), vec![String::from("D+")]);
    assert_eq!(candidate(vec![0.5]), vec![String::from("D-")]);
    assert_eq!(candidate(vec![0.0]), vec![String::from("E")]);
    assert_eq!(candidate(vec![1.0, 0.3, 1.5, 2.8, 3.3]), vec![String::from("D"), String::from("D-"), String::from("C-"), String::from("B"), String::from("B+")]);
    assert_eq!(candidate(vec![0.0, 0.7]), vec![String::from("E"), String::from("D-")]);
}

-----------------------------
/// It is the last week of the semester and the teacher has to give the grades
/// to students. The teacher has been making her own algorithm for grading.
/// The only problem is, she has lost the code she used for grading.
/// She has given you a vector of GPAs for some students and you have to write 
/// a function that can output a vector of letter grades using the following table:
/// GPA       |    Letter grade
/// 4.0                A+
/// > 3.7                A 
/// > 3.3                A- 
/// > 3.0                B+
/// > 2.7                B 
/// > 2.3                B-
/// > 2.0                C+
/// > 1.7                C
/// > 1.3                C-
/// > 1.0                D+ 
/// > 0.7                D 
/// > 0.0                D-
/// 0.0                E
/// Example:
/// >>> grade_equation(vec![4.0, 3, 1.7, 2, 3.5])
/// vec![String::from("A+"), String::from("B"), String::from("C-"), String::from("C"), String::from("A-")]
fn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {

    let mut letters: Vec<String> = Vec::new();
    for grade in grades {
        if grade >= 4.0 {
            letters.push(String::from("A+"));
        } else if grade >= 3.7 {
            letters.push(String::from("A"));
        } else if grade >= 3.3 {
            letters.push(String::from("A-"));
        } else if grade >= 3.0 {
            letters.push(String::from("B+"));
        } else if grade >= 2.7 {
            letters.push(String::from("B"));
        } else if grade >= 2.3 {
            letters.push(String::from("B-"));
        } else if grade >= 2.0 {
            letters.push(String::from("C+"));
        } else if grade >= 1.7 {
            letters.push(String::from("C"));
        } else if grade >= 1.3 {
            letters.push(String::from("C-"));
        } else if grade >= 1.0 {
            letters.push(String::from("D+"));
        } else if grade >= 0.7 {
            letters.push(String::from("D"));
        } else if grade >= 0.0 {
            letters.push(String::from("D-"));
        } else {
            letters.push(String::from("E"));
        }
    }
    letters
}

fn main() {
    let candidate = numerical_letter_grade;
    assert_eq!(candidate(vec![4.0, 3.0, 1.7, 2.0, 3.5]), vec![String::from("A+"), String::from("B"), String::from("C-"), String::from("C"), String::from("A-")]);
    assert_eq!(candidate(vec![1.2]), vec![String::from("D+")]);
    assert_eq!(candidate(vec![0.5]), vec![String::from("D-")]);
    assert_eq!(candidate(vec![0.0]), vec![String::from("E")]);
    assert_eq!(candidate(vec![1.0, 0.3, 1.5, 2.8, 3.3]), vec![String::from("D"), String::from("D-"), String::from("C-"), String::from("B"), String::from("B+")]);
    assert_eq!(candidate(vec![0.0, 0.7]), vec![String::from("E"), String::from("D-")]);
}

-----------------------------
/// It is the last week of the semester and the teacher has to give the grades
/// to students. The teacher has been making her own algorithm for grading.
/// The only problem is, she has lost the code she used for grading.
/// She has given you a vector of GPAs for some students and you have to write 
/// a function that can output a vector of letter grades using the following table:
/// GPA       |    Letter grade
/// 4.0                A+
/// > 3.7                A 
/// > 3.3                A- 
/// > 3.0                B+
/// > 2.7                B 
/// > 2.3                B-
/// > 2.0                C+
/// > 1.7                C
/// > 1.3                C-
/// > 1.0                D+ 
/// > 0.7                D 
/// > 0.0                D-
/// 0.0                E
/// Example:
/// >>> grade_equation(vec![4.0, 3, 1.7, 2, 3.5])
/// vec![String::from("A+"), String::from("B"), String::from("C-"), String::from("C"), String::from("A-")]
fn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {

    let mut letter_grades: Vec<String> = vec![];
    for g in grades {
        match g {
            n if n >= 4.0 => letter_grades.push(String::from("A+")),
            n if n >= 3.7 => letter_grades.push(String::from("A")),
            n if n >= 3.3 => letter_grades.push(String::from("A-")),
            n if n >= 3.0 => letter_grades.push(String::from("B+")),
            n if n >= 2.7 => letter_grades.push(String::from("B")),
            n if n >= 2.3 => letter_grades.push(String::from("B-")),
            n if n >= 2.0 => letter_grades.push(String::from("C+")),
            n if n >= 1.7 => letter_grades.push(String::from("C")),
            n if n >= 1.3 => letter_grades.push(String::from("C-")),
            n if n >= 1.0 => letter_grades.push(String::from("D+")),
            n if n >= 0.7 => letter_grades.push(String::from("D")),
            _ => letter_grades.push(String::from("D-")),
        }
    }
    letter_grades
}

fn main() {
    let candidate = numerical_letter_grade;
    assert_eq!(candidate(vec![4.0, 3.0, 1.7, 2.0, 3.5]), vec![String::from("A+"), String::from("B"), String::from("C-"), String::from("C"), String::from("A-")]);
    assert_eq!(candidate(vec![1.2]), vec![String::from("D+")]);
    assert_eq!(candidate(vec![0.5]), vec![String::from("D-")]);
    assert_eq!(candidate(vec![0.0]), vec![String::from("E")]);
    assert_eq!(candidate(vec![1.0, 0.3, 1.5, 2.8, 3.3]), vec![String::from("D"), String::from("D-"), String::from("C-"), String::from("B"), String::from("B+")]);
    assert_eq!(candidate(vec![0.0, 0.7]), vec![String::from("E"), String::from("D-")]);
}

===============================
/// Write a function that takes a string and returns true if the string
/// length is a prime number or false otherwise
/// Examples
/// >>> prime_length(String::from("Hello"))
/// true
/// >>> prime_length(String::from("abcdcba"))
/// true
/// >>> prime_length(String::from("kittens"))
/// true
/// >>> prime_length(String::from("orange"))
/// false
fn prime_length(string: String) -> bool {

===============================
-----------------------------
/// Write a function that takes a string and returns true if the string
/// length is a prime number or false otherwise
/// Examples
/// >>> prime_length(String::from("Hello"))
/// true
/// >>> prime_length(String::from("abcdcba"))
/// true
/// >>> prime_length(String::from("kittens"))
/// true
/// >>> prime_length(String::from("orange"))
/// false
fn prime_length(string: String) -> bool {

    let mut is_prime = true;
    for i in 2..string.len() {
        if string.len() % i == 0 {
            is_prime = false;
        }
    }
    is_prime
}

fn main() {
    let candidate = prime_length;
    assert_eq!(candidate(String::from("Hello")), true);
    assert_eq!(candidate(String::from("abcdcba")), true);
    assert_eq!(candidate(String::from("kittens")), true);
    assert_eq!(candidate(String::from("orange")), false);
    assert_eq!(candidate(String::from("wow")), true);
    assert_eq!(candidate(String::from("world")), true);
    assert_eq!(candidate(String::from("MadaM")), true);
    assert_eq!(candidate(String::from("Wow")), true);
    assert_eq!(candidate(String::from("")), false);
    assert_eq!(candidate(String::from("HI")), true);
    assert_eq!(candidate(String::from("go")), true);
    assert_eq!(candidate(String::from("gogo")), false);
    assert_eq!(candidate(String::from("aaaaaaaaaaaaaaa")), false);
    assert_eq!(candidate(String::from("Madam")), true);
    assert_eq!(candidate(String::from("M")), false);
    assert_eq!(candidate(String::from("0")), false);
}

-----------------------------
/// Write a function that takes a string and returns true if the string
/// length is a prime number or false otherwise
/// Examples
/// >>> prime_length(String::from("Hello"))
/// true
/// >>> prime_length(String::from("abcdcba"))
/// true
/// >>> prime_length(String::from("kittens"))
/// true
/// >>> prime_length(String::from("orange"))
/// false
fn prime_length(string: String) -> bool {

    let length = string.len();
    let prime = is_prime(length);
    prime
}

fn main() {
    let candidate = prime_length;
    assert_eq!(candidate(String::from("Hello")), true);
    assert_eq!(candidate(String::from("abcdcba")), true);
    assert_eq!(candidate(String::from("kittens")), true);
    assert_eq!(candidate(String::from("orange")), false);
    assert_eq!(candidate(String::from("wow")), true);
    assert_eq!(candidate(String::from("world")), true);
    assert_eq!(candidate(String::from("MadaM")), true);
    assert_eq!(candidate(String::from("Wow")), true);
    assert_eq!(candidate(String::from("")), false);
    assert_eq!(candidate(String::from("HI")), true);
    assert_eq!(candidate(String::from("go")), true);
    assert_eq!(candidate(String::from("gogo")), false);
    assert_eq!(candidate(String::from("aaaaaaaaaaaaaaa")), false);
    assert_eq!(candidate(String::from("Madam")), true);
    assert_eq!(candidate(String::from("M")), false);
    assert_eq!(candidate(String::from("0")), false);
}

-----------------------------
/// Write a function that takes a string and returns true if the string
/// length is a prime number or false otherwise
/// Examples
/// >>> prime_length(String::from("Hello"))
/// true
/// >>> prime_length(String::from("abcdcba"))
/// true
/// >>> prime_length(String::from("kittens"))
/// true
/// >>> prime_length(String::from("orange"))
/// false
fn prime_length(string: String) -> bool {

    let len = string.len();
    let mut divisors: u32 = 0;

    for x in 2..len {
        if len % x == 0 {
            divisors += 1;
        }
    }

    if divisors == 0 {
        true
    } else {
        false
    }
}

fn main() {
    let candidate = prime_length;
    assert_eq!(candidate(String::from("Hello")), true);
    assert_eq!(candidate(String::from("abcdcba")), true);
    assert_eq!(candidate(String::from("kittens")), true);
    assert_eq!(candidate(String::from("orange")), false);
    assert_eq!(candidate(String::from("wow")), true);
    assert_eq!(candidate(String::from("world")), true);
    assert_eq!(candidate(String::from("MadaM")), true);
    assert_eq!(candidate(String::from("Wow")), true);
    assert_eq!(candidate(String::from("")), false);
    assert_eq!(candidate(String::from("HI")), true);
    assert_eq!(candidate(String::from("go")), true);
    assert_eq!(candidate(String::from("gogo")), false);
    assert_eq!(candidate(String::from("aaaaaaaaaaaaaaa")), false);
    assert_eq!(candidate(String::from("Madam")), true);
    assert_eq!(candidate(String::from("M")), false);
    assert_eq!(candidate(String::from("0")), false);
}

-----------------------------
/// Write a function that takes a string and returns true if the string
/// length is a prime number or false otherwise
/// Examples
/// >>> prime_length(String::from("Hello"))
/// true
/// >>> prime_length(String::from("abcdcba"))
/// true
/// >>> prime_length(String::from("kittens"))
/// true
/// >>> prime_length(String::from("orange"))
/// false
fn prime_length(string: String) -> bool {

    let prime_values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101];
    let length = string.len();
    if length < prime_values.len() {
        return prime_values[length];
    } else {
        for prime_value in prime_values {
            if prime_value > length {
                return false;
            } else if length % prime_value == 0 {
                return false;
            }
        }
        return true;
    }
}

fn main() {
    let candidate = prime_length;
    assert_eq!(candidate(String::from("Hello")), true);
    assert_eq!(candidate(String::from("abcdcba")), true);
    assert_eq!(candidate(String::from("kittens")), true);
    assert_eq!(candidate(String::from("orange")), false);
    assert_eq!(candidate(String::from("wow")), true);
    assert_eq!(candidate(String::from("world")), true);
    assert_eq!(candidate(String::from("MadaM")), true);
    assert_eq!(candidate(String::from("Wow")), true);
    assert_eq!(candidate(String::from("")), false);
    assert_eq!(candidate(String::from("HI")), true);
    assert_eq!(candidate(String::from("go")), true);
    assert_eq!(candidate(String::from("gogo")), false);
    assert_eq!(candidate(String::from("aaaaaaaaaaaaaaa")), false);
    assert_eq!(candidate(String::from("Madam")), true);
    assert_eq!(candidate(String::from("M")), false);
    assert_eq!(candidate(String::from("0")), false);
}

-----------------------------
/// Write a function that takes a string and returns true if the string
/// length is a prime number or false otherwise
/// Examples
/// >>> prime_length(String::from("Hello"))
/// true
/// >>> prime_length(String::from("abcdcba"))
/// true
/// >>> prime_length(String::from("kittens"))
/// true
/// >>> prime_length(String::from("orange"))
/// false
fn prime_length(string: String) -> bool {

    let mut i = 2;
    let mut is_prime = true;
    while i < string.len() && is_prime {
        if string.len() % i == 0 {
            is_prime = false;
        }
        i += 1;
    }
    is_prime
}

fn main() {
    let candidate = prime_length;
    assert_eq!(candidate(String::from("Hello")), true);
    assert_eq!(candidate(String::from("abcdcba")), true);
    assert_eq!(candidate(String::from("kittens")), true);
    assert_eq!(candidate(String::from("orange")), false);
    assert_eq!(candidate(String::from("wow")), true);
    assert_eq!(candidate(String::from("world")), true);
    assert_eq!(candidate(String::from("MadaM")), true);
    assert_eq!(candidate(String::from("Wow")), true);
    assert_eq!(candidate(String::from("")), false);
    assert_eq!(candidate(String::from("HI")), true);
    assert_eq!(candidate(String::from("go")), true);
    assert_eq!(candidate(String::from("gogo")), false);
    assert_eq!(candidate(String::from("aaaaaaaaaaaaaaa")), false);
    assert_eq!(candidate(String::from("Madam")), true);
    assert_eq!(candidate(String::from("M")), false);
    assert_eq!(candidate(String::from("0")), false);
}

===============================
/// Given a positive integer n, return the count of the numbers of n-digit
/// positive integers that start or end with 1.
fn starts_one_ends(n: isize) -> isize {

===============================
-----------------------------
/// Given a positive integer n, return the count of the numbers of n-digit
/// positive integers that start or end with 1.
fn starts_one_ends(n: isize) -> isize {

    // We want the number of integers with a leading 1 and a trailing 1.
    //
    // Since there are 10**n choices in each position, we're looking for:
    // (10**(n-1) * 10**n * 10**n) - (10**n - 1) - (10**(n-1) - 1)
    //
    // But this is the same as:
    // (10**(n-1) * 10**n * 10**n) - 10**n - 10**(n-1) + 1
    //
    // But 10**(n-1) * 10**n * 10**n is going to be a lot of numbers. We can
    // calculate it in a much faster way.
    //
    // If we have an n-digit number, then it's going to start with a 1, then it
    // can have (n-1) more digits, and then it's going to end with a 1.
    //
    // Let's consider each of the three parts in turn.
    //
    // We have 10**n digits available to start with, and then we have
    // (n-1) digits in the middle.
    //
    // If we have n digits, there are 10**(n-1) choices for the middle digits.
    //
    // The number of choices for the start and end digits is 10**n, but we
    // subtract 1 for the end digit, and we subtract 1 for the start digit.
    //
    // So we're going to start with:
    // 10**n - 1 - 10**(n-1)
    //
    // and then we're going to add back the number of choices for the middle
    // digits, which is:
    // (n-1) * 10**(n-1)
    //
    // so we're going to get:
    // 10**n - 1 - 10**(n-1) + (n-1) * 10**(n-1)
    //
    // But this is the same as:
    // 10**n * (n-1) - 1 - 10**(n-1)
    //
    // and that's going to be a lot faster to calculate.
    //
    // Since we're interested in the count of n-digit numbers, we're
    // interested in the number of n-digit numbers that start with 1, which
    // is (n-1) * 10**(n-1)
    let digit_count = 10_usize.pow(n as u32 - 1);

    let start_count = digit_count * (n as usize - 1);

    // The number of choices for the middle digits is:
    let end_count = digit_count - 1 - 10_usize.pow(n as u32 - 1);

    let mut count = start_count as isize;
    count += end_count as isize;

    count
}

fn main() {
    let candidate = starts_one_ends;
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(2), 18);
    assert_eq!(candidate(3), 180);
    assert_eq!(candidate(4), 1800);
    assert_eq!(candidate(5), 18000);
}

-----------------------------
/// Given a positive integer n, return the count of the numbers of n-digit
/// positive integers that start or end with 1.
fn starts_one_ends(n: isize) -> isize {

    let n = n as usize;
    let digits = count_digits(n as u64);

    if n < 10 {
        return n as isize;
    }

    let last_digit = n as isize % 10;

    match last_digit {
        1 => 10_usize.pow(digits - 1),
        9 => 9_usize.pow(digits - 1),
        _ => 0,
    }
}

fn main() {
    let candidate = starts_one_ends;
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(2), 18);
    assert_eq!(candidate(3), 180);
    assert_eq!(candidate(4), 1800);
    assert_eq!(candidate(5), 18000);
}

-----------------------------
/// Given a positive integer n, return the count of the numbers of n-digit
/// positive integers that start or end with 1.
fn starts_one_ends(n: isize) -> isize {

    let mut count: isize = 0;
    let max = 10u32.pow(n as u32) - 1;
    let min = max - (10u32.pow((n - 1) as u32) - 1);
    for i in min..max {
        let mut str_i = format!("{}", i);
        if str_i.starts_with('1') || str_i.ends_with('1') {
            count += 1;
        }
    }
    count
}

fn main() {
    let candidate = starts_one_ends;
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(2), 18);
    assert_eq!(candidate(3), 180);
    assert_eq!(candidate(4), 1800);
    assert_eq!(candidate(5), 18000);
}

-----------------------------
/// Given a positive integer n, return the count of the numbers of n-digit
/// positive integers that start or end with 1.
fn starts_one_ends(n: isize) -> isize {

    (n + 1) as isize * n as isize
}

fn main() {
    let candidate = starts_one_ends;
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(2), 18);
    assert_eq!(candidate(3), 180);
    assert_eq!(candidate(4), 1800);
    assert_eq!(candidate(5), 18000);
}

-----------------------------
/// Given a positive integer n, return the count of the numbers of n-digit
/// positive integers that start or end with 1.
fn starts_one_ends(n: isize) -> isize {

    (1..n + 1)
        .map(|n| format!("{:0>8}", n))
        .filter(|s| s.starts_with("1") || s.ends_with("1"))
        .count() as isize
}

fn main() {
    let candidate = starts_one_ends;
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(2), 18);
    assert_eq!(candidate(3), 180);
    assert_eq!(candidate(4), 1800);
    assert_eq!(candidate(5), 18000);
}

===============================
/// Given a positive integer N, return the total sum of its digits in binary.
/// Example
/// >>> solve(1000)
/// String::from("1")
/// >>> solve(150)
/// String::from("110")
/// >>> solve(147)
/// String::from("1100")
/// Variables:
/// @N integer
/// Constraints: 0  N  10000.
/// Output:
/// a string of binary number
fn solve(N: isize) -> String {

===============================
-----------------------------
/// Given a positive integer N, return the total sum of its digits in binary.
/// Example
/// >>> solve(1000)
/// String::from("1")
/// >>> solve(150)
/// String::from("110")
/// >>> solve(147)
/// String::from("1100")
/// Variables:
/// @N integer
/// Constraints: 0  N  10000.
/// Output:
/// a string of binary number
fn solve(N: isize) -> String {

    let mut num: usize = N as usize;
    let mut result: String = String::new();
    loop {
        let c = num & 1;
        result.insert(0, c as u8 as char);
        num = num >> 1;
        if num == 0 {
            break;
        }
    }
    result
}

fn main() {
    let candidate = solve;
    assert_eq!(candidate(1000), String::from("1"));
    assert_eq!(candidate(150), String::from("110"));
    assert_eq!(candidate(147), String::from("1100"));
    assert_eq!(candidate(333), String::from("1001"));
    assert_eq!(candidate(963), String::from("10010"));
}

-----------------------------
/// Given a positive integer N, return the total sum of its digits in binary.
/// Example
/// >>> solve(1000)
/// String::from("1")
/// >>> solve(150)
/// String::from("110")
/// >>> solve(147)
/// String::from("1100")
/// Variables:
/// @N integer
/// Constraints: 0  N  10000.
/// Output:
/// a string of binary number
fn solve(N: isize) -> String {

    let mut N = N as usize;
    let mut b = vec![];
    while N != 0 {
        b.push(N % 2);
        N = N / 2;
    }
    let mut res = vec![];
    for i in b.into_iter().rev() {
        res.push(i);
    }
    let mut res = res.into_iter();
    let mut res = res.collect::<Vec<&usize>>();
    res.reverse();
    res.iter().fold(String::new(), |mut acc, i| {
        acc.push_str(&i.to_string());
        acc
    })
}

fn main() {
    let candidate = solve;
    assert_eq!(candidate(1000), String::from("1"));
    assert_eq!(candidate(150), String::from("110"));
    assert_eq!(candidate(147), String::from("1100"));
    assert_eq!(candidate(333), String::from("1001"));
    assert_eq!(candidate(963), String::from("10010"));
}

-----------------------------
/// Given a positive integer N, return the total sum of its digits in binary.
/// Example
/// >>> solve(1000)
/// String::from("1")
/// >>> solve(150)
/// String::from("110")
/// >>> solve(147)
/// String::from("1100")
/// Variables:
/// @N integer
/// Constraints: 0  N  10000.
/// Output:
/// a string of binary number
fn solve(N: isize) -> String {

    let n = N as usize;
    let mut bin_string = String::new();
    let mut n = n;
    while n > 0 {
        let digit = n % 2;
        bin_string.push_str(&digit.to_string());
        n = n / 2;
    }
    if bin_string.len() == 0 {
        bin_string.push_str("0");
    }
    let mut rev_string = String::from(bin_string.chars().rev().collect::<String>());
    rev_string
}

fn main() {
    let candidate = solve;
    assert_eq!(candidate(1000), String::from("1"));
    assert_eq!(candidate(150), String::from("110"));
    assert_eq!(candidate(147), String::from("1100"));
    assert_eq!(candidate(333), String::from("1001"));
    assert_eq!(candidate(963), String::from("10010"));
}

-----------------------------
/// Given a positive integer N, return the total sum of its digits in binary.
/// Example
/// >>> solve(1000)
/// String::from("1")
/// >>> solve(150)
/// String::from("110")
/// >>> solve(147)
/// String::from("1100")
/// Variables:
/// @N integer
/// Constraints: 0  N  10000.
/// Output:
/// a string of binary number
fn solve(N: isize) -> String {

    let mut N = N as usize;
    let mut result = String::new();
    while N > 0 {
        let rem = N % 2;
        result.push_str(&format!("{}", rem));
        N = N / 2;
    }
    let mut result_string = String::new();
    for item in result.chars().rev() {
        result_string.push(item);
    }
    result_string
}

fn main() {
    let candidate = solve;
    assert_eq!(candidate(1000), String::from("1"));
    assert_eq!(candidate(150), String::from("110"));
    assert_eq!(candidate(147), String::from("1100"));
    assert_eq!(candidate(333), String::from("1001"));
    assert_eq!(candidate(963), String::from("10010"));
}

-----------------------------
/// Given a positive integer N, return the total sum of its digits in binary.
/// Example
/// >>> solve(1000)
/// String::from("1")
/// >>> solve(150)
/// String::from("110")
/// >>> solve(147)
/// String::from("1100")
/// Variables:
/// @N integer
/// Constraints: 0  N  10000.
/// Output:
/// a string of binary number
fn solve(N: isize) -> String {

    format!("{:016b}", N)
}

fn main() {
    let candidate = solve;
    assert_eq!(candidate(1000), String::from("1"));
    assert_eq!(candidate(150), String::from("110"));
    assert_eq!(candidate(147), String::from("1100"));
    assert_eq!(candidate(333), String::from("1001"));
    assert_eq!(candidate(963), String::from("10010"));
}

===============================
/// Given a non-empty vector of integers lst. add the even elements that are at odd indices..
/// Examples:
/// >>> add(vec![4, 2, 6, 7])
/// 2
fn add(lst: Vec<isize>) -> isize {

===============================
-----------------------------
/// Given a non-empty vector of integers lst. add the even elements that are at odd indices..
/// Examples:
/// >>> add(vec![4, 2, 6, 7])
/// 2
fn add(lst: Vec<isize>) -> isize {

    lst.iter().enumerate().filter(|&(x, _)| x % 2 != 0).map(|(_, x)| x).sum()
}

fn main() {
    let candidate = add;
    assert_eq!(candidate(vec![4, 88]), 88);
    assert_eq!(candidate(vec![4, 5, 6, 7, 2, 122]), 122);
    assert_eq!(candidate(vec![4, 0, 6, 7]), 0);
    assert_eq!(candidate(vec![4, 4, 6, 8]), 12);
}

-----------------------------
/// Given a non-empty vector of integers lst. add the even elements that are at odd indices..
/// Examples:
/// >>> add(vec![4, 2, 6, 7])
/// 2
fn add(lst: Vec<isize>) -> isize {

    let mut result = 0;
    for (index, value) in lst.iter().enumerate() {
        if index % 2 == 0 && value % 2 == 0 {
            result += value;
        }
    }
    result
}

fn main() {
    let candidate = add;
    assert_eq!(candidate(vec![4, 88]), 88);
    assert_eq!(candidate(vec![4, 5, 6, 7, 2, 122]), 122);
    assert_eq!(candidate(vec![4, 0, 6, 7]), 0);
    assert_eq!(candidate(vec![4, 4, 6, 8]), 12);
}

-----------------------------
/// Given a non-empty vector of integers lst. add the even elements that are at odd indices..
/// Examples:
/// >>> add(vec![4, 2, 6, 7])
/// 2
fn add(lst: Vec<isize>) -> isize {

    lst.iter()
        .filter_map(|v| if v % 2 == 0 && v as usize % 2 != 0 { Some(*v) } else { None })
        .sum()
}

fn main() {
    let candidate = add;
    assert_eq!(candidate(vec![4, 88]), 88);
    assert_eq!(candidate(vec![4, 5, 6, 7, 2, 122]), 122);
    assert_eq!(candidate(vec![4, 0, 6, 7]), 0);
    assert_eq!(candidate(vec![4, 4, 6, 8]), 12);
}

-----------------------------
/// Given a non-empty vector of integers lst. add the even elements that are at odd indices..
/// Examples:
/// >>> add(vec![4, 2, 6, 7])
/// 2
fn add(lst: Vec<isize>) -> isize {

    let mut res: isize = 0;
    for (index, value) in lst.iter().enumerate() {
        if index % 2 != 0 {
            res += value;
        }
    }
    res
}

fn main() {
    let candidate = add;
    assert_eq!(candidate(vec![4, 88]), 88);
    assert_eq!(candidate(vec![4, 5, 6, 7, 2, 122]), 122);
    assert_eq!(candidate(vec![4, 0, 6, 7]), 0);
    assert_eq!(candidate(vec![4, 4, 6, 8]), 12);
}

-----------------------------
/// Given a non-empty vector of integers lst. add the even elements that are at odd indices..
/// Examples:
/// >>> add(vec![4, 2, 6, 7])
/// 2
fn add(lst: Vec<isize>) -> isize {

    if lst.is_empty() {
        return 0;
    }
    let mut iter = lst.iter();
    let mut sum = 0;
    while let Some(&val) = iter.nth(1) {
        sum += val;
    }
    sum
}

fn main() {
    let candidate = add;
    assert_eq!(candidate(vec![4, 88]), 88);
    assert_eq!(candidate(vec![4, 5, 6, 7, 2, 122]), 122);
    assert_eq!(candidate(vec![4, 0, 6, 7]), 0);
    assert_eq!(candidate(vec![4, 4, 6, 8]), 12);
}

===============================
/// Write a function that takes a string and returns an ordered version of it.
/// Ordered version of string, is a string where all words (separated by space)
/// are replaced by a new word where all the characters arranged in
/// ascending order based on ascii value.
/// Note: You should keep the order of words and blank spaces in the sentence.
/// For example:
/// >>> anti_shuffle(String::from("Hi"))
/// String::from("Hi")
/// >>> anti_shuffle(String::from("hello"))
/// String::from("ehllo")
/// >>> anti_shuffle(String::from("Hello World!!!"))
/// String::from("Hello !!!Wdlor")
fn anti_shuffle(s: String) -> String {

===============================
-----------------------------
/// Write a function that takes a string and returns an ordered version of it.
/// Ordered version of string, is a string where all words (separated by space)
/// are replaced by a new word where all the characters arranged in
/// ascending order based on ascii value.
/// Note: You should keep the order of words and blank spaces in the sentence.
/// For example:
/// >>> anti_shuffle(String::from("Hi"))
/// String::from("Hi")
/// >>> anti_shuffle(String::from("hello"))
/// String::from("ehllo")
/// >>> anti_shuffle(String::from("Hello World!!!"))
/// String::from("Hello !!!Wdlor")
fn anti_shuffle(s: String) -> String {

    s.split(" ").map(|x| anti_shuffle_word(x)).collect()
}

fn main() {
    let candidate = anti_shuffle;
    assert_eq!(candidate(String::from("Hi")), String::from("Hi"));
    assert_eq!(candidate(String::from("hello")), String::from("ehllo"));
    assert_eq!(candidate(String::from("number")), String::from("bemnru"));
    assert_eq!(candidate(String::from("abcd")), String::from("abcd"));
    assert_eq!(candidate(String::from("Hello World!!!")), String::from("Hello !!!Wdlor"));
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("Hi. My name is Mister Robot. How are you?")), String::from(".Hi My aemn is Meirst .Rboot How aer ?ouy"));
}

-----------------------------
/// Write a function that takes a string and returns an ordered version of it.
/// Ordered version of string, is a string where all words (separated by space)
/// are replaced by a new word where all the characters arranged in
/// ascending order based on ascii value.
/// Note: You should keep the order of words and blank spaces in the sentence.
/// For example:
/// >>> anti_shuffle(String::from("Hi"))
/// String::from("Hi")
/// >>> anti_shuffle(String::from("hello"))
/// String::from("ehllo")
/// >>> anti_shuffle(String::from("Hello World!!!"))
/// String::from("Hello !!!Wdlor")
fn anti_shuffle(s: String) -> String {

    let mut words = Vec::new();
    let mut buffer = String::new();

    for letter in s.chars() {
        if letter == ' ' {
            words.push(buffer);
            buffer = String::new();
        } else {
            buffer.push(letter);
        }
    }

    if !buffer.is_empty() {
        words.push(buffer);
    }

    let mut result = String::new();

    for word in words.iter() {
        let mut chars = word.chars();

        let first_char = chars.next().unwrap();
        let mut chars_sorted = chars.collect::<Vec<_>>();
        chars_sorted.sort();
        result.push(first_char);
        result.extend(chars_sorted);
        result.push(' ');
    }

    result.pop();
    result
}

fn main() {
    let candidate = anti_shuffle;
    assert_eq!(candidate(String::from("Hi")), String::from("Hi"));
    assert_eq!(candidate(String::from("hello")), String::from("ehllo"));
    assert_eq!(candidate(String::from("number")), String::from("bemnru"));
    assert_eq!(candidate(String::from("abcd")), String::from("abcd"));
    assert_eq!(candidate(String::from("Hello World!!!")), String::from("Hello !!!Wdlor"));
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("Hi. My name is Mister Robot. How are you?")), String::from(".Hi My aemn is Meirst .Rboot How aer ?ouy"));
}

-----------------------------
/// Write a function that takes a string and returns an ordered version of it.
/// Ordered version of string, is a string where all words (separated by space)
/// are replaced by a new word where all the characters arranged in
/// ascending order based on ascii value.
/// Note: You should keep the order of words and blank spaces in the sentence.
/// For example:
/// >>> anti_shuffle(String::from("Hi"))
/// String::from("Hi")
/// >>> anti_shuffle(String::from("hello"))
/// String::from("ehllo")
/// >>> anti_shuffle(String::from("Hello World!!!"))
/// String::from("Hello !!!Wdlor")
fn anti_shuffle(s: String) -> String {

    let mut ordered_string = "".to_string();
    let mut string_vec: Vec<&str> = s.split(' ').collect();
    string_vec.sort();
    for word in string_vec {
        let mut word_vec: Vec<char> = word.chars().collect();
        word_vec.sort_by(|a, b| a.cmp(b));
        ordered_string.push_str(&word_vec.join(""));
        ordered_string.push(' ');
    }
    ordered_string.pop();
    ordered_string
}

fn main() {
    let candidate = anti_shuffle;
    assert_eq!(candidate(String::from("Hi")), String::from("Hi"));
    assert_eq!(candidate(String::from("hello")), String::from("ehllo"));
    assert_eq!(candidate(String::from("number")), String::from("bemnru"));
    assert_eq!(candidate(String::from("abcd")), String::from("abcd"));
    assert_eq!(candidate(String::from("Hello World!!!")), String::from("Hello !!!Wdlor"));
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("Hi. My name is Mister Robot. How are you?")), String::from(".Hi My aemn is Meirst .Rboot How aer ?ouy"));
}

-----------------------------
/// Write a function that takes a string and returns an ordered version of it.
/// Ordered version of string, is a string where all words (separated by space)
/// are replaced by a new word where all the characters arranged in
/// ascending order based on ascii value.
/// Note: You should keep the order of words and blank spaces in the sentence.
/// For example:
/// >>> anti_shuffle(String::from("Hi"))
/// String::from("Hi")
/// >>> anti_shuffle(String::from("hello"))
/// String::from("ehllo")
/// >>> anti_shuffle(String::from("Hello World!!!"))
/// String::from("Hello !!!Wdlor")
fn anti_shuffle(s: String) -> String {

    let mut result = String::from("");

    for x in s.split(" ").collect::<Vec<_>>() {
        result += &format!("{}", x.chars().sorted().collect::<String>());
        result += " ";
    }
    result
}

fn main() {
    let candidate = anti_shuffle;
    assert_eq!(candidate(String::from("Hi")), String::from("Hi"));
    assert_eq!(candidate(String::from("hello")), String::from("ehllo"));
    assert_eq!(candidate(String::from("number")), String::from("bemnru"));
    assert_eq!(candidate(String::from("abcd")), String::from("abcd"));
    assert_eq!(candidate(String::from("Hello World!!!")), String::from("Hello !!!Wdlor"));
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("Hi. My name is Mister Robot. How are you?")), String::from(".Hi My aemn is Meirst .Rboot How aer ?ouy"));
}

-----------------------------
/// Write a function that takes a string and returns an ordered version of it.
/// Ordered version of string, is a string where all words (separated by space)
/// are replaced by a new word where all the characters arranged in
/// ascending order based on ascii value.
/// Note: You should keep the order of words and blank spaces in the sentence.
/// For example:
/// >>> anti_shuffle(String::from("Hi"))
/// String::from("Hi")
/// >>> anti_shuffle(String::from("hello"))
/// String::from("ehllo")
/// >>> anti_shuffle(String::from("Hello World!!!"))
/// String::from("Hello !!!Wdlor")
fn anti_shuffle(s: String) -> String {

    let mut out = Vec::new();
    let mut words = s.split_whitespace();
    let word = words.next().unwrap();
    out.push(word.chars().sorted().collect::<String>());
    for w in words {
        out.push(" ".to_string());
        out.push(w.chars().sorted().collect::<String>());
    }
    out.join("")
}

fn main() {
    let candidate = anti_shuffle;
    assert_eq!(candidate(String::from("Hi")), String::from("Hi"));
    assert_eq!(candidate(String::from("hello")), String::from("ehllo"));
    assert_eq!(candidate(String::from("number")), String::from("bemnru"));
    assert_eq!(candidate(String::from("abcd")), String::from("abcd"));
    assert_eq!(candidate(String::from("Hello World!!!")), String::from("Hello !!!Wdlor"));
    assert_eq!(candidate(String::from("")), String::from(""));
    assert_eq!(candidate(String::from("Hi. My name is Mister Robot. How are you?")), String::from(".Hi My aemn is Meirst .Rboot How aer ?ouy"));
}

===============================
/// You are given a 2 dimensional data, as a nested vectors,
/// which is similar to matrix, however, unlike matrices,
/// each row may contain a different number of columns.
/// Given lst, and integer x, find integers x in the vector,
/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that
/// each tuple is a coordinate - (row, columns), starting with 0.
/// Sort coordinates initially by rows in ascending order.
/// Also, sort coordinates of the row by columns in descending order.
/// Examples:
/// >>> get_row(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)
/// vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
/// >>> get_row(vec![], 1)
/// Vec::<(isize, isize)>::new()
/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)
/// vec![(2, 2)]
fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {

===============================
-----------------------------
/// You are given a 2 dimensional data, as a nested vectors,
/// which is similar to matrix, however, unlike matrices,
/// each row may contain a different number of columns.
/// Given lst, and integer x, find integers x in the vector,
/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that
/// each tuple is a coordinate - (row, columns), starting with 0.
/// Sort coordinates initially by rows in ascending order.
/// Also, sort coordinates of the row by columns in descending order.
/// Examples:
/// >>> get_row(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)
/// vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
/// >>> get_row(vec![], 1)
/// Vec::<(isize, isize)>::new()
/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)
/// vec![(2, 2)]
fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {

    let mut vec_of_tuple: Vec<(isize, isize)> = vec![];
    for (i, vec) in lst.iter().enumerate() {
        for (j, y) in vec.iter().enumerate() {
            if *y == x {
                vec_of_tuple.push((i as isize, j as isize));
            }
        }
    }
    let mut vec_of_tuple_sorted = vec_of_tuple;
    let mut vec_sorted: Vec<isize> = vec![];
    for (i, x) in vec_of_tuple_sorted.iter().enumerate() {
        if !vec_sorted.contains(&x.0) {
            vec_sorted.push(x.0);
        }
    }
    let mut vec_sorted_y: Vec<isize> = vec![];
    for (i, x) in vec_sorted.iter().enumerate() {
        let mut y_sorted = vec_of_tuple_sorted.clone();
        let mut y_sorted_desc = vec![];
        for y in y_sorted.iter_mut() {
            if y.0 == *x {
                y_sorted_desc.push(y.1);
            }
        }
        let mut y_sorted_desc_sorted = y_sorted_desc;
        let mut y_sorted_desc_sorted_desc = vec![];
        for (i, x) in y_sorted_desc_sorted.iter().enumerate() {
            if !vec_sorted_y.contains(x) {
                vec_sorted_y.push(*x);
                y_sorted_desc_sorted_desc.push(*x);
            }
        }
        y_sorted_desc_sorted_desc.sort_by(|a, b| b.cmp(a));
        for y in y_sorted_desc_sorted_desc.iter() {
            vec_of_tuple_sorted.retain(|z| z.0 == *x && z.1 != *y);
        }
    }
    vec_of_tuple_sorted.sort_by(|a, b| a.0.cmp(&b.0));
    vec_of_tuple_sorted
}

fn main() {
    let candidate = get_row;
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);
    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize, isize)>::new());
    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize, isize)>::new());
    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2, 3]], 3), vec![(2, 2)]);
}

-----------------------------
/// You are given a 2 dimensional data, as a nested vectors,
/// which is similar to matrix, however, unlike matrices,
/// each row may contain a different number of columns.
/// Given lst, and integer x, find integers x in the vector,
/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that
/// each tuple is a coordinate - (row, columns), starting with 0.
/// Sort coordinates initially by rows in ascending order.
/// Also, sort coordinates of the row by columns in descending order.
/// Examples:
/// >>> get_row(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)
/// vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
/// >>> get_row(vec![], 1)
/// Vec::<(isize, isize)>::new()
/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)
/// vec![(2, 2)]
fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {

    let mut rows: Vec<(isize, isize)> = Vec::new();
    for (i, row) in lst.iter().enumerate() {
        for (j, item) in row.iter().enumerate() {
            if *item == x {
                rows.push((i as isize, j as isize));
            }
        }
    }
    rows.sort_by(|a, b| {
        if a.0 > b.0 {
            std::cmp::Ordering::Greater
        } else if a.0 < b.0 {
            std::cmp::Ordering::Less
        } else {
            std::cmp::Ordering::Equal
        }
    });
    let mut temp_rows = Vec::new();
    for row in rows {
        temp_rows.push((row.0, row.1));
    }
    temp_rows.sort_by(|a, b| {
        if a.1 > b.1 {
            std::cmp::Ordering::Greater
        } else if a.1 < b.1 {
            std::cmp::Ordering::Less
        } else {
            std::cmp::Ordering::Equal
        }
    });
    temp_rows
}

fn main() {
    let candidate = get_row;
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);
    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize, isize)>::new());
    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize, isize)>::new());
    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2, 3]], 3), vec![(2, 2)]);
}

-----------------------------
/// You are given a 2 dimensional data, as a nested vectors,
/// which is similar to matrix, however, unlike matrices,
/// each row may contain a different number of columns.
/// Given lst, and integer x, find integers x in the vector,
/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that
/// each tuple is a coordinate - (row, columns), starting with 0.
/// Sort coordinates initially by rows in ascending order.
/// Also, sort coordinates of the row by columns in descending order.
/// Examples:
/// >>> get_row(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)
/// vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
/// >>> get_row(vec![], 1)
/// Vec::<(isize, isize)>::new()
/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)
/// vec![(2, 2)]
fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {

    let mut ans = vec![];
    for i in 0..lst.len() {
        if lst[i].contains(&x) {
            ans.push((i, lst[i].iter().position(|&k| k == x).unwrap()));
        }
    }
    ans.sort_by(|a, b| a.0.cmp(&b.0).then(a.1.cmp(&b.1)));
    ans
}

fn main() {
    let candidate = get_row;
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);
    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize, isize)>::new());
    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize, isize)>::new());
    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2, 3]], 3), vec![(2, 2)]);
}

-----------------------------
/// You are given a 2 dimensional data, as a nested vectors,
/// which is similar to matrix, however, unlike matrices,
/// each row may contain a different number of columns.
/// Given lst, and integer x, find integers x in the vector,
/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that
/// each tuple is a coordinate - (row, columns), starting with 0.
/// Sort coordinates initially by rows in ascending order.
/// Also, sort coordinates of the row by columns in descending order.
/// Examples:
/// >>> get_row(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)
/// vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
/// >>> get_row(vec![], 1)
/// Vec::<(isize, isize)>::new()
/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)
/// vec![(2, 2)]
fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {

    let mut row_coordinates = vec![];
    let mut row_indexes = vec![];
    for (index, row) in lst.iter().enumerate() {
        if row.iter().any(|num| *num == x) {
            row_indexes.push(index);
            row_coordinates.push(
                row.iter()
                    .enumerate()
                    .filter(|(_, num)| **num == x)
                    .map(|(index, _)| index)
                    .collect::<Vec<_>>(),
            );
        }
    }

    row_coordinates.sort();
    row_indexes.sort();

    let mut result = vec![];
    for (i, row) in row_indexes.iter().zip(row_coordinates.iter()) {
        for col in row.iter().rev() {
            result.push((*i, *col));
        }
    }

    result
}

fn main() {
    let candidate = get_row;
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);
    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize, isize)>::new());
    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize, isize)>::new());
    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2, 3]], 3), vec![(2, 2)]);
}

-----------------------------
/// You are given a 2 dimensional data, as a nested vectors,
/// which is similar to matrix, however, unlike matrices,
/// each row may contain a different number of columns.
/// Given lst, and integer x, find integers x in the vector,
/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that
/// each tuple is a coordinate - (row, columns), starting with 0.
/// Sort coordinates initially by rows in ascending order.
/// Also, sort coordinates of the row by columns in descending order.
/// Examples:
/// >>> get_row(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)
/// vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
/// >>> get_row(vec![], 1)
/// Vec::<(isize, isize)>::new()
/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)
/// vec![(2, 2)]
fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {

    let mut result = Vec::new();
    if lst.is_empty() {
        return result;
    }
    let mut row = 0;
    for line in lst {
        for (i, el) in line.iter().enumerate() {
            if *el == x {
                result.push((row, i));
            }
        }
        row += 1;
    }
    result.sort_unstable_by(|a, b| {
        if a.0 == b.0 {
            b.1.cmp(&a.1)
        } else {
            a.0.cmp(&b.0)
        }
    });
    result
}

fn main() {
    let candidate = get_row;
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);
    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize, isize)>::new());
    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize, isize)>::new());
    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2, 3]], 3), vec![(2, 2)]);
}

===============================
/// Given a vector of non-negative integers, return a cors of the given vector after sorting,
/// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,
/// or sort it in descending order if the sum( first index value, last index value) is even.
/// Note:
/// * don't change the given vector.
/// Examples:
/// >>> sort_array(vec![])
/// Vec::<isize>::new()
/// >>> sort_array(vec![5])
/// vec![5]
/// >>> sort_array(vec![2, 4, 3, 0, 1, 5])
/// vec![0, 1, 2, 3, 4, 5]
/// >>> sort_array(vec![2, 4, 3, 0, 1, 5, 6])
/// vec![6, 5, 4, 3, 2, 1, 0]
fn sort_array(array: Vec<isize>) -> Vec<isize> {

===============================
-----------------------------
/// Given a vector of non-negative integers, return a cors of the given vector after sorting,
/// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,
/// or sort it in descending order if the sum( first index value, last index value) is even.
/// Note:
/// * don't change the given vector.
/// Examples:
/// >>> sort_array(vec![])
/// Vec::<isize>::new()
/// >>> sort_array(vec![5])
/// vec![5]
/// >>> sort_array(vec![2, 4, 3, 0, 1, 5])
/// vec![0, 1, 2, 3, 4, 5]
/// >>> sort_array(vec![2, 4, 3, 0, 1, 5, 6])
/// vec![6, 5, 4, 3, 2, 1, 0]
fn sort_array(array: Vec<isize>) -> Vec<isize> {

    if array.len() == 0 {
        return Vec::new();
    }
    let sum = array[0] + array[array.len() - 1];
    if sum % 2 == 0 {
        array.sort_by(|a, b| b.cmp(a));
    } else {
        array.sort_by(|a, b| a.cmp(b));
    }
    array
}

fn main() {
    let candidate = sort_array;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![5]), vec![5]);
    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);
    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);
    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);
    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);
    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23, 21, 14, 11]);
}

-----------------------------
/// Given a vector of non-negative integers, return a cors of the given vector after sorting,
/// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,
/// or sort it in descending order if the sum( first index value, last index value) is even.
/// Note:
/// * don't change the given vector.
/// Examples:
/// >>> sort_array(vec![])
/// Vec::<isize>::new()
/// >>> sort_array(vec![5])
/// vec![5]
/// >>> sort_array(vec![2, 4, 3, 0, 1, 5])
/// vec![0, 1, 2, 3, 4, 5]
/// >>> sort_array(vec![2, 4, 3, 0, 1, 5, 6])
/// vec![6, 5, 4, 3, 2, 1, 0]
fn sort_array(array: Vec<isize>) -> Vec<isize> {

    if array.len() <= 1 {
        return array;
    }
    let mut array = array;
    let sum = array.iter().fold(0, |sum, x| sum + x);
    if sum % 2 == 0 {
        array.sort_by(|a, b| b.cmp(a));
    } else {
        array.sort();
    }
    array
}

fn main() {
    let candidate = sort_array;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![5]), vec![5]);
    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);
    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);
    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);
    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);
    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23, 21, 14, 11]);
}

-----------------------------
/// Given a vector of non-negative integers, return a cors of the given vector after sorting,
/// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,
/// or sort it in descending order if the sum( first index value, last index value) is even.
/// Note:
/// * don't change the given vector.
/// Examples:
/// >>> sort_array(vec![])
/// Vec::<isize>::new()
/// >>> sort_array(vec![5])
/// vec![5]
/// >>> sort_array(vec![2, 4, 3, 0, 1, 5])
/// vec![0, 1, 2, 3, 4, 5]
/// >>> sort_array(vec![2, 4, 3, 0, 1, 5, 6])
/// vec![6, 5, 4, 3, 2, 1, 0]
fn sort_array(array: Vec<isize>) -> Vec<isize> {

    if array.is_empty() {
        return Vec::<isize>::new();
    }

    let mut array_sum = array[0];
    for i in array.iter().skip(1) {
        array_sum += i;
    }

    let mut sorted_array = array.clone();
    sorted_array.sort();
    if (array_sum % 2) == 0 {
        return sorted_array;
    }

    sorted_array.reverse();
    return sorted_array;
}

fn main() {
    let candidate = sort_array;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![5]), vec![5]);
    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);
    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);
    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);
    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);
    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23, 21, 14, 11]);
}

-----------------------------
/// Given a vector of non-negative integers, return a cors of the given vector after sorting,
/// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,
/// or sort it in descending order if the sum( first index value, last index value) is even.
/// Note:
/// * don't change the given vector.
/// Examples:
/// >>> sort_array(vec![])
/// Vec::<isize>::new()
/// >>> sort_array(vec![5])
/// vec![5]
/// >>> sort_array(vec![2, 4, 3, 0, 1, 5])
/// vec![0, 1, 2, 3, 4, 5]
/// >>> sort_array(vec![2, 4, 3, 0, 1, 5, 6])
/// vec![6, 5, 4, 3, 2, 1, 0]
fn sort_array(array: Vec<isize>) -> Vec<isize> {

    if array.is_empty() {
        return Vec::new();
    }

    let (first, last) = (array[0], array.last().unwrap().clone());

    let sum = first + last;

    if (sum & 1) == 0 {
        array.sort_by_key(|&x| -x);
    }

    array
}

fn main() {
    let candidate = sort_array;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![5]), vec![5]);
    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);
    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);
    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);
    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);
    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23, 21, 14, 11]);
}

-----------------------------
/// Given a vector of non-negative integers, return a cors of the given vector after sorting,
/// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,
/// or sort it in descending order if the sum( first index value, last index value) is even.
/// Note:
/// * don't change the given vector.
/// Examples:
/// >>> sort_array(vec![])
/// Vec::<isize>::new()
/// >>> sort_array(vec![5])
/// vec![5]
/// >>> sort_array(vec![2, 4, 3, 0, 1, 5])
/// vec![0, 1, 2, 3, 4, 5]
/// >>> sort_array(vec![2, 4, 3, 0, 1, 5, 6])
/// vec![6, 5, 4, 3, 2, 1, 0]
fn sort_array(array: Vec<isize>) -> Vec<isize> {

    let mut sum = 0;
    for i in &array {
        sum += i;
    }

    let mut new_array = array.clone();
    if sum % 2 == 1 {
        new_array.sort_by(|a, b| a.partial_cmp(b).unwrap());
    } else {
        new_array.sort_by(|a, b| b.partial_cmp(a).unwrap());
    }
    new_array
}

fn main() {
    let candidate = sort_array;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![5]), vec![5]);
    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);
    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);
    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);
    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);
    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23, 21, 14, 11]);
}

===============================
/// Create a function encrypt that takes a string as an argument and
/// returns a string encrypted with the alphabet being rotated. 
/// The alphabet should be rotated in a manner such that the letters 
/// shift down by two multiplied to two places.
/// For example:
/// >>> encrypt(String::from("hi"))
/// String::from("lm")
/// >>> encrypt(String::from("asdfghjkl"))
/// String::from("ewhjklnop")
/// >>> encrypt(String::from("gf"))
/// String::from("kj")
/// >>> encrypt(String::from("et"))
/// String::from("ix")
fn encrypt(s: String) -> String {

===============================
-----------------------------
/// Create a function encrypt that takes a string as an argument and
/// returns a string encrypted with the alphabet being rotated. 
/// The alphabet should be rotated in a manner such that the letters 
/// shift down by two multiplied to two places.
/// For example:
/// >>> encrypt(String::from("hi"))
/// String::from("lm")
/// >>> encrypt(String::from("asdfghjkl"))
/// String::from("ewhjklnop")
/// >>> encrypt(String::from("gf"))
/// String::from("kj")
/// >>> encrypt(String::from("et"))
/// String::from("ix")
fn encrypt(s: String) -> String {

    let mut encrypted: String = "".to_string();
    let mut ch: Vec<char> = s.chars().collect();

    for c in &ch {
        match c {
            'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' => {
                encrypted.push('l');
            }
            'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' => {
                encrypted.push('k');
            }
            _ => {
                encrypted.push(c.clone());
            }
        }
    }
    encrypted
}

fn main() {
    let candidate = encrypt;
    assert_eq!(candidate(String::from("hi")), String::from("lm"));
    assert_eq!(candidate(String::from("asdfghjkl")), String::from("ewhjklnop"));
    assert_eq!(candidate(String::from("gf")), String::from("kj"));
    assert_eq!(candidate(String::from("et")), String::from("ix"));
    assert_eq!(candidate(String::from("faewfawefaewg")), String::from("jeiajeaijeiak"));
    assert_eq!(candidate(String::from("hellomyfriend")), String::from("lippsqcjvmirh"));
    assert_eq!(candidate(String::from("dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh")), String::from("hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"));
    assert_eq!(candidate(String::from("a")), String::from("e"));
}

-----------------------------
/// Create a function encrypt that takes a string as an argument and
/// returns a string encrypted with the alphabet being rotated. 
/// The alphabet should be rotated in a manner such that the letters 
/// shift down by two multiplied to two places.
/// For example:
/// >>> encrypt(String::from("hi"))
/// String::from("lm")
/// >>> encrypt(String::from("asdfghjkl"))
/// String::from("ewhjklnop")
/// >>> encrypt(String::from("gf"))
/// String::from("kj")
/// >>> encrypt(String::from("et"))
/// String::from("ix")
fn encrypt(s: String) -> String {

    let mut a = Vec::new();
    for i in s.chars(){
        let c = (i as u8 + 2*2) as char;
        a.push(c);
    }
    let e: String = a.iter().collect();
    return e;
}

fn main() {
    let candidate = encrypt;
    assert_eq!(candidate(String::from("hi")), String::from("lm"));
    assert_eq!(candidate(String::from("asdfghjkl")), String::from("ewhjklnop"));
    assert_eq!(candidate(String::from("gf")), String::from("kj"));
    assert_eq!(candidate(String::from("et")), String::from("ix"));
    assert_eq!(candidate(String::from("faewfawefaewg")), String::from("jeiajeaijeiak"));
    assert_eq!(candidate(String::from("hellomyfriend")), String::from("lippsqcjvmirh"));
    assert_eq!(candidate(String::from("dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh")), String::from("hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"));
    assert_eq!(candidate(String::from("a")), String::from("e"));
}

-----------------------------
/// Create a function encrypt that takes a string as an argument and
/// returns a string encrypted with the alphabet being rotated. 
/// The alphabet should be rotated in a manner such that the letters 
/// shift down by two multiplied to two places.
/// For example:
/// >>> encrypt(String::from("hi"))
/// String::from("lm")
/// >>> encrypt(String::from("asdfghjkl"))
/// String::from("ewhjklnop")
/// >>> encrypt(String::from("gf"))
/// String::from("kj")
/// >>> encrypt(String::from("et"))
/// String::from("ix")
fn encrypt(s: String) -> String {

    // IMPLEMENT ME
    s
}

fn main() {
    let candidate = encrypt;
    assert_eq!(candidate(String::from("hi")), String::from("lm"));
    assert_eq!(candidate(String::from("asdfghjkl")), String::from("ewhjklnop"));
    assert_eq!(candidate(String::from("gf")), String::from("kj"));
    assert_eq!(candidate(String::from("et")), String::from("ix"));
    assert_eq!(candidate(String::from("faewfawefaewg")), String::from("jeiajeaijeiak"));
    assert_eq!(candidate(String::from("hellomyfriend")), String::from("lippsqcjvmirh"));
    assert_eq!(candidate(String::from("dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh")), String::from("hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"));
    assert_eq!(candidate(String::from("a")), String::from("e"));
}

-----------------------------
/// Create a function encrypt that takes a string as an argument and
/// returns a string encrypted with the alphabet being rotated. 
/// The alphabet should be rotated in a manner such that the letters 
/// shift down by two multiplied to two places.
/// For example:
/// >>> encrypt(String::from("hi"))
/// String::from("lm")
/// >>> encrypt(String::from("asdfghjkl"))
/// String::from("ewhjklnop")
/// >>> encrypt(String::from("gf"))
/// String::from("kj")
/// >>> encrypt(String::from("et"))
/// String::from("ix")
fn encrypt(s: String) -> String {

    let mut rot = String::new();

    for character in s.chars() {
        let ascii_value: u8 = character as u8;
        if ascii_value.is_ascii_alphabetic() {
            let rotated_value = (ascii_value + 2 * 2) % 26 + 65;
            rot.push(rotated_value as char);
        } else {
            rot.push(character);
        }
    }

    rot
}

fn main() {
    let candidate = encrypt;
    assert_eq!(candidate(String::from("hi")), String::from("lm"));
    assert_eq!(candidate(String::from("asdfghjkl")), String::from("ewhjklnop"));
    assert_eq!(candidate(String::from("gf")), String::from("kj"));
    assert_eq!(candidate(String::from("et")), String::from("ix"));
    assert_eq!(candidate(String::from("faewfawefaewg")), String::from("jeiajeaijeiak"));
    assert_eq!(candidate(String::from("hellomyfriend")), String::from("lippsqcjvmirh"));
    assert_eq!(candidate(String::from("dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh")), String::from("hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"));
    assert_eq!(candidate(String::from("a")), String::from("e"));
}

-----------------------------
/// Create a function encrypt that takes a string as an argument and
/// returns a string encrypted with the alphabet being rotated. 
/// The alphabet should be rotated in a manner such that the letters 
/// shift down by two multiplied to two places.
/// For example:
/// >>> encrypt(String::from("hi"))
/// String::from("lm")
/// >>> encrypt(String::from("asdfghjkl"))
/// String::from("ewhjklnop")
/// >>> encrypt(String::from("gf"))
/// String::from("kj")
/// >>> encrypt(String::from("et"))
/// String::from("ix")
fn encrypt(s: String) -> String {

    let mut new_string = String::from("");

    for character in s.chars() {
        let mut shift_character = character;

        if character.is_alphabetic() {
            shift_character = character.to_ascii_lowercase();

            if character.is_ascii_lowercase() && character.to_ascii_lowercase().is_alphabetic() {
                shift_character = shift_character + 2 * 2;

                if shift_character > 'z' as u8 {
                    shift_character = shift_character - ('z' - 'a') + 1;
                }

                new_string.push(shift_character as char);
            }

            if character.is_ascii_uppercase() && character.to_ascii_uppercase().is_alphabetic() {
                shift_character = shift_character + 2 * 2;

                if shift_character > 'Z' as u8 {
                    shift_character = shift_character - ('Z' - 'A') + 1;
                }

                new_string.push(shift_character as char);
            }
        }

        if character.is_alphanumeric() {
            new_string.push(character);
        }
    }

    new_string
}

fn main() {
    let candidate = encrypt;
    assert_eq!(candidate(String::from("hi")), String::from("lm"));
    assert_eq!(candidate(String::from("asdfghjkl")), String::from("ewhjklnop"));
    assert_eq!(candidate(String::from("gf")), String::from("kj"));
    assert_eq!(candidate(String::from("et")), String::from("ix"));
    assert_eq!(candidate(String::from("faewfawefaewg")), String::from("jeiajeaijeiak"));
    assert_eq!(candidate(String::from("hellomyfriend")), String::from("lippsqcjvmirh"));
    assert_eq!(candidate(String::from("dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh")), String::from("hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"));
    assert_eq!(candidate(String::from("a")), String::from("e"));
}

===============================
/// You are given a vector of integers.
/// Write a function next_smallest() that returns the 2nd smallest element of the vector.
/// Return None if there is no such element.
/// >>> next_smallest(vec![1, 2, 3, 4, 5])
/// Some(2)
/// >>> next_smallest(vec![5, 1, 4, 3, 2])
/// Some(2)
/// >>> next_smallest(vec![])
/// None
/// >>> next_smallest(vec![1, 1])
/// None
fn next_smallest(lst: Vec<isize>) -> Option<isize> {

===============================
-----------------------------
/// You are given a vector of integers.
/// Write a function next_smallest() that returns the 2nd smallest element of the vector.
/// Return None if there is no such element.
/// >>> next_smallest(vec![1, 2, 3, 4, 5])
/// Some(2)
/// >>> next_smallest(vec![5, 1, 4, 3, 2])
/// Some(2)
/// >>> next_smallest(vec![])
/// None
/// >>> next_smallest(vec![1, 1])
/// None
fn next_smallest(lst: Vec<isize>) -> Option<isize> {

    let mut lst = lst;

    // First check if the vector has at least two elements
    if lst.len() < 2 {
        return None;
    }

    // Sort the vector so that the smallest element is at the beginning
    lst.sort();

    // Then, check if the smallest element has a smaller element
    if lst.len() > 1 && lst[1] > lst[0] {
        return Some(lst[1]);
    } else {
        return None;
    }
}

fn main() {
    let candidate = next_smallest;
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));
    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));
    assert_eq!(candidate(Vec::<isize>::new()), None);
    assert_eq!(candidate(vec![1, 1]), None);
    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));
    assert_eq!(candidate(vec![1, 1]), None);
    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));
}

-----------------------------
/// You are given a vector of integers.
/// Write a function next_smallest() that returns the 2nd smallest element of the vector.
/// Return None if there is no such element.
/// >>> next_smallest(vec![1, 2, 3, 4, 5])
/// Some(2)
/// >>> next_smallest(vec![5, 1, 4, 3, 2])
/// Some(2)
/// >>> next_smallest(vec![])
/// None
/// >>> next_smallest(vec![1, 1])
/// None
fn next_smallest(lst: Vec<isize>) -> Option<isize> {

    if lst.len() == 0 {
        None
    } else if lst.len() == 1 {
        None
    } else {
        let mut lst = lst;
        lst.sort();
        let mut min = lst.get(0).unwrap();
        let mut index = 0;
        for i in 1..lst.len() {
            let element = lst.get(i).unwrap();
            if element < min {
                min = element;
                index = i;
            }
        }
        if index + 1 >= lst.len() {
            None
        } else {
            Some(lst.get(index + 1).unwrap().to_owned())
        }
    }
}

fn main() {
    let candidate = next_smallest;
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));
    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));
    assert_eq!(candidate(Vec::<isize>::new()), None);
    assert_eq!(candidate(vec![1, 1]), None);
    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));
    assert_eq!(candidate(vec![1, 1]), None);
    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));
}

-----------------------------
/// You are given a vector of integers.
/// Write a function next_smallest() that returns the 2nd smallest element of the vector.
/// Return None if there is no such element.
/// >>> next_smallest(vec![1, 2, 3, 4, 5])
/// Some(2)
/// >>> next_smallest(vec![5, 1, 4, 3, 2])
/// Some(2)
/// >>> next_smallest(vec![])
/// None
/// >>> next_smallest(vec![1, 1])
/// None
fn next_smallest(lst: Vec<isize>) -> Option<isize> {

    if lst.len() < 2 {
        return None;
    }

    let mut mx = 0;
    let mut mx_idx = 0;
    for (i, &v) in lst.iter().enumerate() {
        if v > mx {
            mx = v;
            mx_idx = i;
        }
    }

    let mut min = mx;
    let mut min_idx = mx_idx;

    for (i, &v) in lst.iter().enumerate() {
        if i == mx_idx {
            continue;
        }

        if v < min {
            min = v;
            min_idx = i;
        }
    }

    if lst.len() == 2 && lst[0] == lst[1] {
        return None;
    }

    return Some(lst[min_idx]);
}

fn main() {
    let candidate = next_smallest;
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));
    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));
    assert_eq!(candidate(Vec::<isize>::new()), None);
    assert_eq!(candidate(vec![1, 1]), None);
    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));
    assert_eq!(candidate(vec![1, 1]), None);
    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));
}

-----------------------------
/// You are given a vector of integers.
/// Write a function next_smallest() that returns the 2nd smallest element of the vector.
/// Return None if there is no such element.
/// >>> next_smallest(vec![1, 2, 3, 4, 5])
/// Some(2)
/// >>> next_smallest(vec![5, 1, 4, 3, 2])
/// Some(2)
/// >>> next_smallest(vec![])
/// None
/// >>> next_smallest(vec![1, 1])
/// None
fn next_smallest(lst: Vec<isize>) -> Option<isize> {

    let mut lst = lst.into_iter().collect::<BTreeSet<isize>>();
    if lst.len() < 2 {
        return None;
    }
    let mut prev = lst.iter().next().unwrap().clone();
    lst.remove(&prev);
    Some(*lst.iter().next().unwrap() - prev)
}

fn main() {
    let candidate = next_smallest;
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));
    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));
    assert_eq!(candidate(Vec::<isize>::new()), None);
    assert_eq!(candidate(vec![1, 1]), None);
    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));
    assert_eq!(candidate(vec![1, 1]), None);
    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));
}

-----------------------------
/// You are given a vector of integers.
/// Write a function next_smallest() that returns the 2nd smallest element of the vector.
/// Return None if there is no such element.
/// >>> next_smallest(vec![1, 2, 3, 4, 5])
/// Some(2)
/// >>> next_smallest(vec![5, 1, 4, 3, 2])
/// Some(2)
/// >>> next_smallest(vec![])
/// None
/// >>> next_smallest(vec![1, 1])
/// None
fn next_smallest(lst: Vec<isize>) -> Option<isize> {

    let len = lst.len();
    if len == 0 {
        return None;
    }
    let mut min = lst[0];
    for i in 0..len {
        if lst[i] < min {
            min = lst[i];
        }
    }
    for i in 0..len {
        if lst[i] > min && lst[i] < lst[0] {
            return Some(lst[i]);
        }
    }
    return None;
}

fn main() {
    let candidate = next_smallest;
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));
    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));
    assert_eq!(candidate(Vec::<isize>::new()), None);
    assert_eq!(candidate(vec![1, 1]), None);
    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));
    assert_eq!(candidate(vec![1, 1]), None);
    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));
}

===============================
/// You'll be given a string of words, and your task is to count the number
/// of boredoms. A boredom is a sentence that starts with the word "I".
/// Sentences are delimited by '.', '?' or '!'.
/// For example:
/// >>> is_bored(String::from("Hello world"))
/// 0
/// >>> is_bored(String::from("The sky is blue. The sun is shining. I love this weather"))
/// 1
fn is_bored(S: String) -> isize {

===============================
-----------------------------
/// You'll be given a string of words, and your task is to count the number
/// of boredoms. A boredom is a sentence that starts with the word "I".
/// Sentences are delimited by '.', '?' or '!'.
/// For example:
/// >>> is_bored(String::from("Hello world"))
/// 0
/// >>> is_bored(String::from("The sky is blue. The sun is shining. I love this weather"))
/// 1
fn is_bored(S: String) -> isize {

    let mut res: isize = 0;
    let mut is_bored: bool = false;
    for i in S.split('.') {
        for j in i.split('?') {
            for k in j.split('!') {
                if k.starts_with("I") {
                    is_bored = true;
                }
            }
        }
        if is_bored {
            res += 1;
            is_bored = false;
        }
    }
    res
}

fn main() {
    let candidate = is_bored;
    assert_eq!(candidate(String::from("Hello world")), 0);
    assert_eq!(candidate(String::from("Is the sky blue?")), 0);
    assert_eq!(candidate(String::from("I love It !")), 1);
    assert_eq!(candidate(String::from("bIt")), 0);
    assert_eq!(candidate(String::from("I feel good today. I will be productive. will kill It")), 2);
    assert_eq!(candidate(String::from("You and I are going for a walk")), 0);
}

-----------------------------
/// You'll be given a string of words, and your task is to count the number
/// of boredoms. A boredom is a sentence that starts with the word "I".
/// Sentences are delimited by '.', '?' or '!'.
/// For example:
/// >>> is_bored(String::from("Hello world"))
/// 0
/// >>> is_bored(String::from("The sky is blue. The sun is shining. I love this weather"))
/// 1
fn is_bored(S: String) -> isize {

    let words = S.split(|c: char| c == '.' || c == '!' || c == '?' || c == ' ').filter(|x| !x.is_empty()).collect::<Vec<&str>>();
    let mut bored: isize = 0;
    for i in words {
        if i.starts_with("I") {
            bored += 1;
        }
    }
    bored
}

fn main() {
    let candidate = is_bored;
    assert_eq!(candidate(String::from("Hello world")), 0);
    assert_eq!(candidate(String::from("Is the sky blue?")), 0);
    assert_eq!(candidate(String::from("I love It !")), 1);
    assert_eq!(candidate(String::from("bIt")), 0);
    assert_eq!(candidate(String::from("I feel good today. I will be productive. will kill It")), 2);
    assert_eq!(candidate(String::from("You and I are going for a walk")), 0);
}

-----------------------------
/// You'll be given a string of words, and your task is to count the number
/// of boredoms. A boredom is a sentence that starts with the word "I".
/// Sentences are delimited by '.', '?' or '!'.
/// For example:
/// >>> is_bored(String::from("Hello world"))
/// 0
/// >>> is_bored(String::from("The sky is blue. The sun is shining. I love this weather"))
/// 1
fn is_bored(S: String) -> isize {

    let sentence_split: Vec<_> = S
        .split(|c| c == '.' || c == '?' || c == '!')
        .map(String::from)
        .collect();
    let mut boredoms = 0;
    for sentence in sentence_split {
        if sentence.starts_with("I") {
            boredoms += 1;
        }
    }
    return boredoms;
}

fn main() {
    let candidate = is_bored;
    assert_eq!(candidate(String::from("Hello world")), 0);
    assert_eq!(candidate(String::from("Is the sky blue?")), 0);
    assert_eq!(candidate(String::from("I love It !")), 1);
    assert_eq!(candidate(String::from("bIt")), 0);
    assert_eq!(candidate(String::from("I feel good today. I will be productive. will kill It")), 2);
    assert_eq!(candidate(String::from("You and I are going for a walk")), 0);
}

-----------------------------
/// You'll be given a string of words, and your task is to count the number
/// of boredoms. A boredom is a sentence that starts with the word "I".
/// Sentences are delimited by '.', '?' or '!'.
/// For example:
/// >>> is_bored(String::from("Hello world"))
/// 0
/// >>> is_bored(String::from("The sky is blue. The sun is shining. I love this weather"))
/// 1
fn is_bored(S: String) -> isize {

    let mut count: isize = 0;
    let words = S.split_whitespace().collect::<Vec<&str>>();
    for (i, word) in words.iter().enumerate() {
        if i == 0 {
            if *word == "I" {
                count += 1;
            }
        }
        if *word == "." || *word == "?" || *word == "!" {
            if i > 0 && words[i - 1] == "I" {
                count += 1;
            }
        }
    }
    count
}

fn main() {
    let candidate = is_bored;
    assert_eq!(candidate(String::from("Hello world")), 0);
    assert_eq!(candidate(String::from("Is the sky blue?")), 0);
    assert_eq!(candidate(String::from("I love It !")), 1);
    assert_eq!(candidate(String::from("bIt")), 0);
    assert_eq!(candidate(String::from("I feel good today. I will be productive. will kill It")), 2);
    assert_eq!(candidate(String::from("You and I are going for a walk")), 0);
}

-----------------------------
/// You'll be given a string of words, and your task is to count the number
/// of boredoms. A boredom is a sentence that starts with the word "I".
/// Sentences are delimited by '.', '?' or '!'.
/// For example:
/// >>> is_bored(String::from("Hello world"))
/// 0
/// >>> is_bored(String::from("The sky is blue. The sun is shining. I love this weather"))
/// 1
fn is_bored(S: String) -> isize {

    let mut boredoms: isize = 0;
    let mut sentence_is_boredom: bool = false;
    let mut sentence: String = String::from("");
    for (i, c) in S.chars().enumerate() {
        match c {
            '.' | '!' | '?' => {
                if sentence_is_boredom {
                    boredoms += 1;
                    sentence_is_boredom = false;
                }
                if i < S.len() - 1 {
                    sentence = String::from(&S[i + 1..]);
                } else {
                    sentence = String::from("");
                }
            }
            _ => {
                if sentence == "I" {
                    sentence_is_boredom = true;
                }
                sentence.push(c);
            }
        }
    }
    boredoms
}

fn main() {
    let candidate = is_bored;
    assert_eq!(candidate(String::from("Hello world")), 0);
    assert_eq!(candidate(String::from("Is the sky blue?")), 0);
    assert_eq!(candidate(String::from("I love It !")), 1);
    assert_eq!(candidate(String::from("bIt")), 0);
    assert_eq!(candidate(String::from("I feel good today. I will be productive. will kill It")), 2);
    assert_eq!(candidate(String::from("You and I are going for a walk")), 0);
}

===============================
/// Create a function that takes 3 numbers.
/// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.
/// Returns false in any other cases.
/// Examples
/// >>> any_int(5, 2, 7)
/// true
/// >>> any_int(3, 2, 2)
/// false
/// >>> any_int(3, -2, 1)
/// true
/// >>> any_int(3.6, -2.2, 2)
/// false
fn any_int(x: f64, y: f64, z: f64) -> bool {

===============================
-----------------------------
/// Create a function that takes 3 numbers.
/// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.
/// Returns false in any other cases.
/// Examples
/// >>> any_int(5, 2, 7)
/// true
/// >>> any_int(3, 2, 2)
/// false
/// >>> any_int(3, -2, 1)
/// true
/// >>> any_int(3.6, -2.2, 2)
/// false
fn any_int(x: f64, y: f64, z: f64) -> bool {

    let integers = [x, y, z].iter().all(|n| n.fract() == 0.0);
    let sum = x + y + z;
    let integers_and_sum = x == sum || y == sum || z == sum;
    return integers && integers_and_sum;
}

fn main() {
    let candidate = any_int;
    assert_eq!(candidate(2.0, 3.0, 1.0), true);
    assert_eq!(candidate(2.5, 2.0, 3.0), false);
    assert_eq!(candidate(1.5, 5.0, 3.5), false);
    assert_eq!(candidate(2.0, 6.0, 2.0), false);
    assert_eq!(candidate(4.0, 2.0, 2.0), true);
    assert_eq!(candidate(2.2, 2.2, 2.2), false);
    assert_eq!(candidate(-4.0, 6.0, 2.0), true);
    assert_eq!(candidate(2.0, 1.0, 1.0), true);
    assert_eq!(candidate(3.0, 4.0, 7.0), true);
    assert_eq!(candidate(3.0, 4.0, 7.0), false);
}

-----------------------------
/// Create a function that takes 3 numbers.
/// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.
/// Returns false in any other cases.
/// Examples
/// >>> any_int(5, 2, 7)
/// true
/// >>> any_int(3, 2, 2)
/// false
/// >>> any_int(3, -2, 1)
/// true
/// >>> any_int(3.6, -2.2, 2)
/// false
fn any_int(x: f64, y: f64, z: f64) -> bool {

    let x = x as i32;
    let y = y as i32;
    let z = z as i32;

    if x + y == z && x as f64 == x && y as f64 == y && z as f64 == z {
        true
    } else {
        false
    }
}

fn main() {
    let candidate = any_int;
    assert_eq!(candidate(2.0, 3.0, 1.0), true);
    assert_eq!(candidate(2.5, 2.0, 3.0), false);
    assert_eq!(candidate(1.5, 5.0, 3.5), false);
    assert_eq!(candidate(2.0, 6.0, 2.0), false);
    assert_eq!(candidate(4.0, 2.0, 2.0), true);
    assert_eq!(candidate(2.2, 2.2, 2.2), false);
    assert_eq!(candidate(-4.0, 6.0, 2.0), true);
    assert_eq!(candidate(2.0, 1.0, 1.0), true);
    assert_eq!(candidate(3.0, 4.0, 7.0), true);
    assert_eq!(candidate(3.0, 4.0, 7.0), false);
}

-----------------------------
/// Create a function that takes 3 numbers.
/// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.
/// Returns false in any other cases.
/// Examples
/// >>> any_int(5, 2, 7)
/// true
/// >>> any_int(3, 2, 2)
/// false
/// >>> any_int(3, -2, 1)
/// true
/// >>> any_int(3.6, -2.2, 2)
/// false
fn any_int(x: f64, y: f64, z: f64) -> bool {

    if x.is_integer() && y.is_integer() && z.is_integer() {
        if (x == y + z) || (y == x + z) || (z == x + y) {
            return true;
        } else {
            return false;
        }
    } else {
        return false;
    }
}

fn main() {
    let candidate = any_int;
    assert_eq!(candidate(2.0, 3.0, 1.0), true);
    assert_eq!(candidate(2.5, 2.0, 3.0), false);
    assert_eq!(candidate(1.5, 5.0, 3.5), false);
    assert_eq!(candidate(2.0, 6.0, 2.0), false);
    assert_eq!(candidate(4.0, 2.0, 2.0), true);
    assert_eq!(candidate(2.2, 2.2, 2.2), false);
    assert_eq!(candidate(-4.0, 6.0, 2.0), true);
    assert_eq!(candidate(2.0, 1.0, 1.0), true);
    assert_eq!(candidate(3.0, 4.0, 7.0), true);
    assert_eq!(candidate(3.0, 4.0, 7.0), false);
}

-----------------------------
/// Create a function that takes 3 numbers.
/// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.
/// Returns false in any other cases.
/// Examples
/// >>> any_int(5, 2, 7)
/// true
/// >>> any_int(3, 2, 2)
/// false
/// >>> any_int(3, -2, 1)
/// true
/// >>> any_int(3.6, -2.2, 2)
/// false
fn any_int(x: f64, y: f64, z: f64) -> bool {

    let x = x as i64;
    let y = y as i64;
    let z = z as i64;
    if (x == y+z) || (y == x+z) || (z == x+y) {
        true
    } else {
        false
    }
}

fn main() {
    let candidate = any_int;
    assert_eq!(candidate(2.0, 3.0, 1.0), true);
    assert_eq!(candidate(2.5, 2.0, 3.0), false);
    assert_eq!(candidate(1.5, 5.0, 3.5), false);
    assert_eq!(candidate(2.0, 6.0, 2.0), false);
    assert_eq!(candidate(4.0, 2.0, 2.0), true);
    assert_eq!(candidate(2.2, 2.2, 2.2), false);
    assert_eq!(candidate(-4.0, 6.0, 2.0), true);
    assert_eq!(candidate(2.0, 1.0, 1.0), true);
    assert_eq!(candidate(3.0, 4.0, 7.0), true);
    assert_eq!(candidate(3.0, 4.0, 7.0), false);
}

-----------------------------
/// Create a function that takes 3 numbers.
/// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.
/// Returns false in any other cases.
/// Examples
/// >>> any_int(5, 2, 7)
/// true
/// >>> any_int(3, 2, 2)
/// false
/// >>> any_int(3, -2, 1)
/// true
/// >>> any_int(3.6, -2.2, 2)
/// false
fn any_int(x: f64, y: f64, z: f64) -> bool {

    let a = (x == (y + z)) && (x.fract() == 0.0) && (y.fract() == 0.0) && (z.fract() == 0.0);
    a
}

fn main() {
    let candidate = any_int;
    assert_eq!(candidate(2.0, 3.0, 1.0), true);
    assert_eq!(candidate(2.5, 2.0, 3.0), false);
    assert_eq!(candidate(1.5, 5.0, 3.5), false);
    assert_eq!(candidate(2.0, 6.0, 2.0), false);
    assert_eq!(candidate(4.0, 2.0, 2.0), true);
    assert_eq!(candidate(2.2, 2.2, 2.2), false);
    assert_eq!(candidate(-4.0, 6.0, 2.0), true);
    assert_eq!(candidate(2.0, 1.0, 1.0), true);
    assert_eq!(candidate(3.0, 4.0, 7.0), true);
    assert_eq!(candidate(3.0, 4.0, 7.0), false);
}

===============================
/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(String::from("test"))
/// String::from("TGST")
/// >>> encode(String::from("This is a message"))
/// String::from("tHKS KS C MGSSCGG")
fn encode(message: String) -> String {

===============================
-----------------------------
/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(String::from("test"))
/// String::from("TGST")
/// >>> encode(String::from("This is a message"))
/// String::from("tHKS KS C MGSSCGG")
fn encode(message: String) -> String {

    let mut ret_str = String::new();
    let mut i = 0;
    for c in message.chars() {
        let mut str = String::from(c);
        let mut found_vowel = false;
        match c {
            'a' | 'A' | 'e' | 'E' | 'i' | 'I' | 'o' | 'O' | 'u' | 'U' => {
                if i < message.len() - 2 {
                    found_vowel = true;
                    str = message[(i + 2)..i + 3].to_string();
                }
                if c.is_lowercase() {
                    str = str.to_uppercase();
                } else {
                    str = str.to_lowercase();
                }
            },
            _ => {
                if c.is_lowercase() {
                    str = str.to_uppercase();
                } else {
                    str = str.to_lowercase();
                }
            },
        }
        ret_str.push_str(str.as_str());
        i += 1;
    }
    ret_str
}

fn main() {
    let candidate = encode;
    assert_eq!(candidate(String::from("TEST")), String::from("tgst"));
    assert_eq!(candidate(String::from("Mudasir")), String::from("mWDCSKR"));
    assert_eq!(candidate(String::from("YES")), String::from("ygs"));
    assert_eq!(candidate(String::from("This is a message")), String::from("tHKS KS C MGSSCGG"));
    assert_eq!(candidate(String::from("I DoNt KnOw WhAt tO WrItE")), String::from("k dQnT kNqW wHcT Tq wRkTg"));
}

-----------------------------
/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(String::from("test"))
/// String::from("TGST")
/// >>> encode(String::from("This is a message"))
/// String::from("tHKS KS C MGSSCGG")
fn encode(message: String) -> String {

    let mut output = String::from("");
    for c in message.chars() {
        if is_letter(c) {
            output.push(translate(c));
        } else {
            output.push(c);
        }
    }
    output
}

fn main() {
    let candidate = encode;
    assert_eq!(candidate(String::from("TEST")), String::from("tgst"));
    assert_eq!(candidate(String::from("Mudasir")), String::from("mWDCSKR"));
    assert_eq!(candidate(String::from("YES")), String::from("ygs"));
    assert_eq!(candidate(String::from("This is a message")), String::from("tHKS KS C MGSSCGG"));
    assert_eq!(candidate(String::from("I DoNt KnOw WhAt tO WrItE")), String::from("k dQnT kNqW wHcT Tq wRkTg"));
}

-----------------------------
/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(String::from("test"))
/// String::from("TGST")
/// >>> encode(String::from("This is a message"))
/// String::from("tHKS KS C MGSSCGG")
fn encode(message: String) -> String {

    let mut encoded = String::new();
    let mut chars = message.chars();
    let mut vowel = 'a';
    while let Some(char) = chars.next() {
        if char.is_ascii_alphabetic() {
            let upper = char.is_uppercase();
            let lower = char.to_ascii_lowercase();
            if lower == vowel {
                vowel = match vowel {
                    'a' => 'c',
                    'e' => 'g',
                    'i' => 'k',
                    'o' => 's',
                    'u' => 't',
                    _ => 'a',
                };
            }
            if upper {
                encoded.push(vowel.to_ascii_uppercase());
            } else {
                encoded.push(vowel);
            }
        } else {
            encoded.push(char);
        }
    }
    encoded
}

fn main() {
    let candidate = encode;
    assert_eq!(candidate(String::from("TEST")), String::from("tgst"));
    assert_eq!(candidate(String::from("Mudasir")), String::from("mWDCSKR"));
    assert_eq!(candidate(String::from("YES")), String::from("ygs"));
    assert_eq!(candidate(String::from("This is a message")), String::from("tHKS KS C MGSSCGG"));
    assert_eq!(candidate(String::from("I DoNt KnOw WhAt tO WrItE")), String::from("k dQnT kNqW wHcT Tq wRkTg"));
}

-----------------------------
/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(String::from("test"))
/// String::from("TGST")
/// >>> encode(String::from("This is a message"))
/// String::from("tHKS KS C MGSSCGG")
fn encode(message: String) -> String {

    let mut encoded = String::new();
    for c in message.chars() {
        if c.is_uppercase() {
            encoded.push(c.to_lowercase().next().unwrap());
        } else if c.is_lowercase() {
            encoded.push(c.to_uppercase().next().unwrap());
        } else {
            encoded.push(c);
        }
    }
    encoded
}

fn main() {
    let candidate = encode;
    assert_eq!(candidate(String::from("TEST")), String::from("tgst"));
    assert_eq!(candidate(String::from("Mudasir")), String::from("mWDCSKR"));
    assert_eq!(candidate(String::from("YES")), String::from("ygs"));
    assert_eq!(candidate(String::from("This is a message")), String::from("tHKS KS C MGSSCGG"));
    assert_eq!(candidate(String::from("I DoNt KnOw WhAt tO WrItE")), String::from("k dQnT kNqW wHcT Tq wRkTg"));
}

-----------------------------
/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(String::from("test"))
/// String::from("TGST")
/// >>> encode(String::from("This is a message"))
/// String::from("tHKS KS C MGSSCGG")
fn encode(message: String) -> String {

    // We can take advantage of Rusts Vec<T> type to store the characters in the message.
    // We also need a way to know what position we are at in the message string.
    let mut message_vec: Vec<char> = Vec::new();
    let mut message_index = 0;

    // The algorithm is as follows:
    // 1. Iterate over the string and convert to a vector of chars.
    // 2. Iterate over the vector of chars and check if it's a vowel.
    // 3. If it's a vowel, check if the next char is a vowel.
    // 4. If it's a vowel, check if the next char is a consonant.
    // 5. If it's a consonant, return the consonant.
    // 6. If it's a vowel, return the consonant that is 2 places ahead of it in the alphabet.
    for char in message.chars() {
        message_vec.push(char);
    }

    // The result string.
    let mut result_string = String::new();

    // Iterate over the message vector of chars.
    for char in message_vec {
        if char == 'a' || char == 'A' {
            // We found an a, now check if the next character is a vowel.
            if message_vec[message_index + 1] == 'e' || message_vec[message_index + 1] == 'E' {
                // We have a vowel after the a, check if the next character is a consonant.
                if message_vec[message_index + 2] == 'i' || message_vec[message_index + 2] == 'I' {
                    // We have a vowel after the a, which is followed by a consonant.
                    // Add the char to the result string.
                    result_string.push(char);
                    result_string.push(message_vec[message_index + 2]);
                } else {
                    // Add the consonant to the result string.
                    result_string.push(char);
                    result_string.push(message_vec[message_index + 2]);
                }
            } else {
                // We have a vowel after the a, but not followed by a consonant.
                // Add the consonant to the result string.
                result_string.push(char);
                result_string.push(message_vec[message_index + 1]);
            }
        } else if char == 'e' || char == 'E' {
            // We found an e, now check if the next character is a consonant.
            if message_vec[message_index + 1] == 'i' || message_vec[message_index + 1] == 'I' {
                // We have a vowel after the e, check if the next character is a consonant.
                if message_vec[message_index + 2] == 'o' || message_vec[message_index + 2] == 'O' {
                    // We have a vowel after the e, which is followed by a consonant.
                    // Add the char to the result string.
                    result_string.push(char);
                    result_string.push(message_vec[message_index + 2]);
                } else {
                    // Add the consonant to the result string.
                    result_string.push(char);
                    result_string.push(message_vec[message_index + 2]);
                }
            } else {
                // We have a vowel after the e, but not followed by a consonant.
                //
}

fn main() {
    let candidate = encode;
    assert_eq!(candidate(String::from("TEST")), String::from("tgst"));
    assert_eq!(candidate(String::from("Mudasir")), String::from("mWDCSKR"));
    assert_eq!(candidate(String::from("YES")), String::from("ygs"));
    assert_eq!(candidate(String::from("This is a message")), String::from("tHKS KS C MGSSCGG"));
    assert_eq!(candidate(String::from("I DoNt KnOw WhAt tO WrItE")), String::from("k dQnT kNqW wHcT Tq wRkTg"));
}

===============================
/// You are given a vector of integers.
/// You need to find the largest prime value and return the sum of its digits.
/// Examples:
/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
/// 10
/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
/// 25
/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
/// 13
/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
/// 11
/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])
/// 3
/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])
/// 7
fn skjkasdkd(lst: Vec<isize>) -> isize {

===============================
-----------------------------
/// You are given a vector of integers.
/// You need to find the largest prime value and return the sum of its digits.
/// Examples:
/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
/// 10
/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
/// 25
/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
/// 13
/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
/// 11
/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])
/// 3
/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])
/// 7
fn skjkasdkd(lst: Vec<isize>) -> isize {

    let mut n = 0;
    let mut lp = 0;
    let mut c = 0;
    for nn in lst {
        if nn != 0 {
            n = nn;
            break;
        }
    }

    while n > 0 {
        let mut i = 2;
        while i * i <= n {
            if n % i == 0 {
                c += i;
                n /= i;
                break;
            }
            i += 1;
        }
    }
    c
}

fn main() {
    let candidate = skjkasdkd;
    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);
    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);
    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);
    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);
    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);
    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);
    assert_eq!(candidate(vec![8191]), 19);
    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);
    assert_eq!(candidate(vec![127, 97, 8192]), 10);
}

-----------------------------
/// You are given a vector of integers.
/// You need to find the largest prime value and return the sum of its digits.
/// Examples:
/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
/// 10
/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
/// 25
/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
/// 13
/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
/// 11
/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])
/// 3
/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])
/// 7
fn skjkasdkd(lst: Vec<isize>) -> isize {

    if lst.is_empty() {
        return 0;
    }

    let mut prime_sum = 0;
    let mut p = 2;

    while p <= lst.iter().max().unwrap() {
        let mut is_prime = true;
        for v in lst.iter() {
            if v % p == 0 && v != p {
                is_prime = false;
                break;
            }
        }

        if is_prime {
            let mut digit_sum = 0;
            for v in p.to_string().chars() {
                digit_sum += v as usize - '0' as usize;
            }
            prime_sum += digit_sum as isize;
        }

        p += 1;
    }

    prime_sum
}

fn main() {
    let candidate = skjkasdkd;
    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);
    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);
    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);
    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);
    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);
    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);
    assert_eq!(candidate(vec![8191]), 19);
    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);
    assert_eq!(candidate(vec![127, 97, 8192]), 10);
}

-----------------------------
/// You are given a vector of integers.
/// You need to find the largest prime value and return the sum of its digits.
/// Examples:
/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
/// 10
/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
/// 25
/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
/// 13
/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
/// 11
/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])
/// 3
/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])
/// 7
fn skjkasdkd(lst: Vec<isize>) -> isize {

    let mut sum = 0;
    for item in lst.iter().filter(|&x| {
        for i in 2..=(x/2).sqrt() as isize {
            if x % i == 0 {
                return false;
            }
        }
        true
    }) {
        sum += digit_sum(item);
    }
    sum
}

fn main() {
    let candidate = skjkasdkd;
    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);
    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);
    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);
    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);
    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);
    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);
    assert_eq!(candidate(vec![8191]), 19);
    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);
    assert_eq!(candidate(vec![127, 97, 8192]), 10);
}

-----------------------------
/// You are given a vector of integers.
/// You need to find the largest prime value and return the sum of its digits.
/// Examples:
/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
/// 10
/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
/// 25
/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
/// 13
/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
/// 11
/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])
/// 3
/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])
/// 7
fn skjkasdkd(lst: Vec<isize>) -> isize {

    let mut largest_prime = 0;
    let mut max = 0;
    for i in 0..lst.len() {
        if lst[i] > max {
            max = lst[i];
        }
    }

    for i in 0..max {
        if is_prime(i) {
            largest_prime = i;
        }
    }

    let mut sum = 0;
    for i in largest_prime.to_string().chars() {
        sum += i as isize - 48;
    }
    sum
}

fn main() {
    let candidate = skjkasdkd;
    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);
    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);
    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);
    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);
    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);
    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);
    assert_eq!(candidate(vec![8191]), 19);
    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);
    assert_eq!(candidate(vec![127, 97, 8192]), 10);
}

-----------------------------
/// You are given a vector of integers.
/// You need to find the largest prime value and return the sum of its digits.
/// Examples:
/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
/// 10
/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
/// 25
/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
/// 13
/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
/// 11
/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])
/// 3
/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])
/// 7
fn skjkasdkd(lst: Vec<isize>) -> isize {

    let primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101];
    let mut biggest_prime = 0;
    for n in lst {
        let mut prime = 0;
        for p in primes {
            if p > n {
                break;
            }
            if n % p == 0 {
                prime = p;
                break;
            }
        }
        if prime > biggest_prime {
            biggest_prime = prime;
        }
    }
    let mut sum = 0;
    for c in biggest_prime.to_string().chars() {
        sum += c.to_digit(10).unwrap();
    }
    sum
}

fn main() {
    let candidate = skjkasdkd;
    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);
    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);
    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);
    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);
    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);
    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);
    assert_eq!(candidate(vec![8191]), 19);
    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);
    assert_eq!(candidate(vec![127, 97, 8192]), 10);
}

===============================
use std::collections::HashMap;

/// Given a HashMap, return true if all keys are strings in lower 
/// case or all keys are strings in upper case, else return false.
/// The function should return false is the given HashMap is empty.
/// Examples:
/// >>> check_dict_case(HashMap::from([(String::from("a"), String::from("apple")), (String::from("b"), String::from("banana"))]))
/// true
/// >>> check_dict_case(HashMap::from([(String::from("a"), String::from("apple")), (String::from("A"), String::from("banana")), (String::from("B"), String::from("banana"))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from("a"), String::from("apple")), (8, String::from("banana")), (String::from("a"), String::from("apple"))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from("Name"), String::from("John")), (String::from("Age"), String::from("36")), (String::from("City"), String::from("Houston"))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from("STATE"), String::from("NC")), (String::from("ZIP"), String::from("12345"))]))
/// true
fn check_dict_case(dict: HashMap<String, String>) -> bool {

===============================
-----------------------------
use std::collections::HashMap;

/// Given a HashMap, return true if all keys are strings in lower 
/// case or all keys are strings in upper case, else return false.
/// The function should return false is the given HashMap is empty.
/// Examples:
/// >>> check_dict_case(HashMap::from([(String::from("a"), String::from("apple")), (String::from("b"), String::from("banana"))]))
/// true
/// >>> check_dict_case(HashMap::from([(String::from("a"), String::from("apple")), (String::from("A"), String::from("banana")), (String::from("B"), String::from("banana"))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from("a"), String::from("apple")), (8, String::from("banana")), (String::from("a"), String::from("apple"))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from("Name"), String::from("John")), (String::from("Age"), String::from("36")), (String::from("City"), String::from("Houston"))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from("STATE"), String::from("NC")), (String::from("ZIP"), String::from("12345"))]))
/// true
fn check_dict_case(dict: HashMap<String, String>) -> bool {

    if dict.is_empty() {
        return false;
    }
    let mut is_lower = true;
    let mut is_upper = true;
    for key in dict.keys() {
        if !key.chars().all(|c| c.is_alphabetic()) {
            return false;
        }
        if is_lower {
            if !key.chars().all(|c| c.is_ascii_lowercase()) {
                is_lower = false;
            }
        }
        if is_upper {
            if !key.chars().all(|c| c.is_ascii_uppercase()) {
                is_upper = false;
            }
        }
    }
    if is_upper && is_lower {
        return false;
    }
    return true;
}

fn main() {
    let candidate = check_dict_case;
    assert_eq!(candidate(HashMap::from([(String::from("p"), String::from("pineapple")), (String::from("b"), String::from("banana"))])), true);
    assert_eq!(candidate(HashMap::from([(String::from("p"), String::from("pineapple")), (String::from("A"), String::from("banana")), (String::from("B"), String::from("banana"))])), false);
    assert_eq!(candidate(HashMap::from([(String::from("p"), String::from("pineapple")), (String::from("5"), String::from("banana")), (String::from("a"), String::from("apple"))])), false);
    assert_eq!(candidate(HashMap::from([(String::from("Name"), String::from("John")), (String::from("Age"), String::from("36")), (String::from("City"), String::from("Houston"))])), false);
    assert_eq!(candidate(HashMap::from([(String::from("STATE"), String::from("NC")), (String::from("ZIP"), String::from("12345"))])), true);
    assert_eq!(candidate(HashMap::from([(String::from("fruit"), String::from("Orange")), (String::from("taste"), String::from("Sweet"))])), true);
    assert_eq!(candidate(HashMap::from([])), false);
}

-----------------------------
use std::collections::HashMap;

/// Given a HashMap, return true if all keys are strings in lower 
/// case or all keys are strings in upper case, else return false.
/// The function should return false is the given HashMap is empty.
/// Examples:
/// >>> check_dict_case(HashMap::from([(String::from("a"), String::from("apple")), (String::from("b"), String::from("banana"))]))
/// true
/// >>> check_dict_case(HashMap::from([(String::from("a"), String::from("apple")), (String::from("A"), String::from("banana")), (String::from("B"), String::from("banana"))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from("a"), String::from("apple")), (8, String::from("banana")), (String::from("a"), String::from("apple"))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from("Name"), String::from("John")), (String::from("Age"), String::from("36")), (String::from("City"), String::from("Houston"))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from("STATE"), String::from("NC")), (String::from("ZIP"), String::from("12345"))]))
/// true
fn check_dict_case(dict: HashMap<String, String>) -> bool {

    // Check if the HashMap is empty
    if dict.is_empty() {
        return false;
    }

    let mut count_lowercase = 0;
    let mut count_uppercase = 0;

    for (key, value) in &dict {
        if key.to_lowercase() == key {
            count_lowercase += 1;
        } else if key.to_uppercase() == key {
            count_uppercase += 1;
        } else {
            // Return false if a key is not a string in lower or upper case
            return false;
        }

        if value.to_lowercase() != value && value.to_uppercase() != value {
            return false;
        }
    }

    // Return false if some keys are in lower case and some in upper case
    count_lowercase == dict.len() || count_uppercase == dict.len()
}

fn main() {
    let candidate = check_dict_case;
    assert_eq!(candidate(HashMap::from([(String::from("p"), String::from("pineapple")), (String::from("b"), String::from("banana"))])), true);
    assert_eq!(candidate(HashMap::from([(String::from("p"), String::from("pineapple")), (String::from("A"), String::from("banana")), (String::from("B"), String::from("banana"))])), false);
    assert_eq!(candidate(HashMap::from([(String::from("p"), String::from("pineapple")), (String::from("5"), String::from("banana")), (String::from("a"), String::from("apple"))])), false);
    assert_eq!(candidate(HashMap::from([(String::from("Name"), String::from("John")), (String::from("Age"), String::from("36")), (String::from("City"), String::from("Houston"))])), false);
    assert_eq!(candidate(HashMap::from([(String::from("STATE"), String::from("NC")), (String::from("ZIP"), String::from("12345"))])), true);
    assert_eq!(candidate(HashMap::from([(String::from("fruit"), String::from("Orange")), (String::from("taste"), String::from("Sweet"))])), true);
    assert_eq!(candidate(HashMap::from([])), false);
}

-----------------------------
use std::collections::HashMap;

/// Given a HashMap, return true if all keys are strings in lower 
/// case or all keys are strings in upper case, else return false.
/// The function should return false is the given HashMap is empty.
/// Examples:
/// >>> check_dict_case(HashMap::from([(String::from("a"), String::from("apple")), (String::from("b"), String::from("banana"))]))
/// true
/// >>> check_dict_case(HashMap::from([(String::from("a"), String::from("apple")), (String::from("A"), String::from("banana")), (String::from("B"), String::from("banana"))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from("a"), String::from("apple")), (8, String::from("banana")), (String::from("a"), String::from("apple"))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from("Name"), String::from("John")), (String::from("Age"), String::from("36")), (String::from("City"), String::from("Houston"))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from("STATE"), String::from("NC")), (String::from("ZIP"), String::from("12345"))]))
/// true
fn check_dict_case(dict: HashMap<String, String>) -> bool {

    if dict.is_empty() {
        return false;
    }
    let mut all_lower = true;
    let mut all_upper = true;
    for (key, _) in dict.iter() {
        if key.chars().nth(0).unwrap().is_lowercase() {
            all_upper = false;
        }
        if key.chars().nth(0).unwrap().is_uppercase() {
            all_lower = false;
        }
    }
    all_lower || all_upper
}

fn main() {
    let candidate = check_dict_case;
    assert_eq!(candidate(HashMap::from([(String::from("p"), String::from("pineapple")), (String::from("b"), String::from("banana"))])), true);
    assert_eq!(candidate(HashMap::from([(String::from("p"), String::from("pineapple")), (String::from("A"), String::from("banana")), (String::from("B"), String::from("banana"))])), false);
    assert_eq!(candidate(HashMap::from([(String::from("p"), String::from("pineapple")), (String::from("5"), String::from("banana")), (String::from("a"), String::from("apple"))])), false);
    assert_eq!(candidate(HashMap::from([(String::from("Name"), String::from("John")), (String::from("Age"), String::from("36")), (String::from("City"), String::from("Houston"))])), false);
    assert_eq!(candidate(HashMap::from([(String::from("STATE"), String::from("NC")), (String::from("ZIP"), String::from("12345"))])), true);
    assert_eq!(candidate(HashMap::from([(String::from("fruit"), String::from("Orange")), (String::from("taste"), String::from("Sweet"))])), true);
    assert_eq!(candidate(HashMap::from([])), false);
}

-----------------------------
use std::collections::HashMap;

/// Given a HashMap, return true if all keys are strings in lower 
/// case or all keys are strings in upper case, else return false.
/// The function should return false is the given HashMap is empty.
/// Examples:
/// >>> check_dict_case(HashMap::from([(String::from("a"), String::from("apple")), (String::from("b"), String::from("banana"))]))
/// true
/// >>> check_dict_case(HashMap::from([(String::from("a"), String::from("apple")), (String::from("A"), String::from("banana")), (String::from("B"), String::from("banana"))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from("a"), String::from("apple")), (8, String::from("banana")), (String::from("a"), String::from("apple"))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from("Name"), String::from("John")), (String::from("Age"), String::from("36")), (String::from("City"), String::from("Houston"))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from("STATE"), String::from("NC")), (String::from("ZIP"), String::from("12345"))]))
/// true
fn check_dict_case(dict: HashMap<String, String>) -> bool {

    let mut flag = true;
    let mut case = false;

    if !dict.is_empty() {
        for (key, _) in dict.iter() {
            if key.to_lowercase() == key && case == false {
                case = true;
            } else if key.to_uppercase() == key && case == true {
                case = false;
            } else {
                flag = false;
                break;
            }
        }
    }

    flag
}

fn main() {
    let candidate = check_dict_case;
    assert_eq!(candidate(HashMap::from([(String::from("p"), String::from("pineapple")), (String::from("b"), String::from("banana"))])), true);
    assert_eq!(candidate(HashMap::from([(String::from("p"), String::from("pineapple")), (String::from("A"), String::from("banana")), (String::from("B"), String::from("banana"))])), false);
    assert_eq!(candidate(HashMap::from([(String::from("p"), String::from("pineapple")), (String::from("5"), String::from("banana")), (String::from("a"), String::from("apple"))])), false);
    assert_eq!(candidate(HashMap::from([(String::from("Name"), String::from("John")), (String::from("Age"), String::from("36")), (String::from("City"), String::from("Houston"))])), false);
    assert_eq!(candidate(HashMap::from([(String::from("STATE"), String::from("NC")), (String::from("ZIP"), String::from("12345"))])), true);
    assert_eq!(candidate(HashMap::from([(String::from("fruit"), String::from("Orange")), (String::from("taste"), String::from("Sweet"))])), true);
    assert_eq!(candidate(HashMap::from([])), false);
}

-----------------------------
use std::collections::HashMap;

/// Given a HashMap, return true if all keys are strings in lower 
/// case or all keys are strings in upper case, else return false.
/// The function should return false is the given HashMap is empty.
/// Examples:
/// >>> check_dict_case(HashMap::from([(String::from("a"), String::from("apple")), (String::from("b"), String::from("banana"))]))
/// true
/// >>> check_dict_case(HashMap::from([(String::from("a"), String::from("apple")), (String::from("A"), String::from("banana")), (String::from("B"), String::from("banana"))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from("a"), String::from("apple")), (8, String::from("banana")), (String::from("a"), String::from("apple"))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from("Name"), String::from("John")), (String::from("Age"), String::from("36")), (String::from("City"), String::from("Houston"))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from("STATE"), String::from("NC")), (String::from("ZIP"), String::from("12345"))]))
/// true
fn check_dict_case(dict: HashMap<String, String>) -> bool {

    let mut case_count = 0;
    if dict.is_empty() {
        return false;
    }

    for (k, _) in dict.iter() {
        if k.chars().all(|c| c.is_uppercase()) {
            case_count += 1;
        } else if k.chars().all(|c| c.is_lowercase()) {
            case_count += 1;
        }
    }
    if case_count == 0 {
        return false;
    }
    if case_count == 2 {
        return true;
    }
    false
}

fn main() {
    let candidate = check_dict_case;
    assert_eq!(candidate(HashMap::from([(String::from("p"), String::from("pineapple")), (String::from("b"), String::from("banana"))])), true);
    assert_eq!(candidate(HashMap::from([(String::from("p"), String::from("pineapple")), (String::from("A"), String::from("banana")), (String::from("B"), String::from("banana"))])), false);
    assert_eq!(candidate(HashMap::from([(String::from("p"), String::from("pineapple")), (String::from("5"), String::from("banana")), (String::from("a"), String::from("apple"))])), false);
    assert_eq!(candidate(HashMap::from([(String::from("Name"), String::from("John")), (String::from("Age"), String::from("36")), (String::from("City"), String::from("Houston"))])), false);
    assert_eq!(candidate(HashMap::from([(String::from("STATE"), String::from("NC")), (String::from("ZIP"), String::from("12345"))])), true);
    assert_eq!(candidate(HashMap::from([(String::from("fruit"), String::from("Orange")), (String::from("taste"), String::from("Sweet"))])), true);
    assert_eq!(candidate(HashMap::from([])), false);
}

===============================
/// Implement a function that takes an non-negative integer and returns a vector of the first n
/// integers that are prime numbers and less than n.
/// for example:
/// >>> count_up_to(5)
/// vec![2, 3]
/// >>> count_up_to(11)
/// vec![2, 3, 5, 7]
/// >>> count_up_to(0)
/// Vec::<isize>::new()
/// >>> count_up_to(20)
/// vec![2, 3, 5, 7, 11, 13, 17, 19]
/// >>> count_up_to(1)
/// Vec::<isize>::new()
/// >>> count_up_to(18)
/// vec![2, 3, 5, 7, 11, 13, 17]
fn count_up_to(n: isize) -> Vec<isize> {

===============================
-----------------------------
/// Implement a function that takes an non-negative integer and returns a vector of the first n
/// integers that are prime numbers and less than n.
/// for example:
/// >>> count_up_to(5)
/// vec![2, 3]
/// >>> count_up_to(11)
/// vec![2, 3, 5, 7]
/// >>> count_up_to(0)
/// Vec::<isize>::new()
/// >>> count_up_to(20)
/// vec![2, 3, 5, 7, 11, 13, 17, 19]
/// >>> count_up_to(1)
/// Vec::<isize>::new()
/// >>> count_up_to(18)
/// vec![2, 3, 5, 7, 11, 13, 17]
fn count_up_to(n: isize) -> Vec<isize> {

    let mut vec: Vec<isize> = Vec::new();
    if n > 0 {
        for i in 2..n {
            if n % i == 0 {
                break;
            }
            vec.push(i);
        }
    }
    vec
}

fn main() {
    let candidate = count_up_to;
    assert_eq!(candidate(5), vec![2, 3]);
    assert_eq!(candidate(6), vec![2, 3, 5]);
    assert_eq!(candidate(7), vec![2, 3, 5]);
    assert_eq!(candidate(10), vec![2, 3, 5, 7]);
    assert_eq!(candidate(0), Vec::<isize>::new());
    assert_eq!(candidate(22), vec![2, 3, 5, 7, 11, 13, 17, 19]);
    assert_eq!(candidate(1), Vec::<isize>::new());
    assert_eq!(candidate(18), vec![2, 3, 5, 7, 11, 13, 17]);
    assert_eq!(candidate(47), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);
    assert_eq!(candidate(101), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);
}

-----------------------------
/// Implement a function that takes an non-negative integer and returns a vector of the first n
/// integers that are prime numbers and less than n.
/// for example:
/// >>> count_up_to(5)
/// vec![2, 3]
/// >>> count_up_to(11)
/// vec![2, 3, 5, 7]
/// >>> count_up_to(0)
/// Vec::<isize>::new()
/// >>> count_up_to(20)
/// vec![2, 3, 5, 7, 11, 13, 17, 19]
/// >>> count_up_to(1)
/// Vec::<isize>::new()
/// >>> count_up_to(18)
/// vec![2, 3, 5, 7, 11, 13, 17]
fn count_up_to(n: isize) -> Vec<isize> {

    if n < 0 {
        return vec![];
    }

    // Find the factors of n
    let factors = factors(n);

    // Remove the factor of one
    let mut result = vec![];
    let mut count = 0;
    for i in 0..n {
        if i == 1 {
            continue;
        }
        if !factors.contains(&i) {
            result.push(i);
            count += 1;
        }
        if count == n as usize {
            break;
        }
    }
    result
}

fn main() {
    let candidate = count_up_to;
    assert_eq!(candidate(5), vec![2, 3]);
    assert_eq!(candidate(6), vec![2, 3, 5]);
    assert_eq!(candidate(7), vec![2, 3, 5]);
    assert_eq!(candidate(10), vec![2, 3, 5, 7]);
    assert_eq!(candidate(0), Vec::<isize>::new());
    assert_eq!(candidate(22), vec![2, 3, 5, 7, 11, 13, 17, 19]);
    assert_eq!(candidate(1), Vec::<isize>::new());
    assert_eq!(candidate(18), vec![2, 3, 5, 7, 11, 13, 17]);
    assert_eq!(candidate(47), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);
    assert_eq!(candidate(101), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);
}

-----------------------------
/// Implement a function that takes an non-negative integer and returns a vector of the first n
/// integers that are prime numbers and less than n.
/// for example:
/// >>> count_up_to(5)
/// vec![2, 3]
/// >>> count_up_to(11)
/// vec![2, 3, 5, 7]
/// >>> count_up_to(0)
/// Vec::<isize>::new()
/// >>> count_up_to(20)
/// vec![2, 3, 5, 7, 11, 13, 17, 19]
/// >>> count_up_to(1)
/// Vec::<isize>::new()
/// >>> count_up_to(18)
/// vec![2, 3, 5, 7, 11, 13, 17]
fn count_up_to(n: isize) -> Vec<isize> {

    let mut primes: Vec<isize> = Vec::new();
    if n < 2 {
        return primes;
    }
    if n < 3 {
        primes.push(2);
        return primes;
    }
    let mut count = 2;
    let mut i = 3;
    while count < n {
        if is_prime(i) {
            count += 1;
            primes.push(i);
        }
        i += 2;
    }
    return primes;
}

fn main() {
    let candidate = count_up_to;
    assert_eq!(candidate(5), vec![2, 3]);
    assert_eq!(candidate(6), vec![2, 3, 5]);
    assert_eq!(candidate(7), vec![2, 3, 5]);
    assert_eq!(candidate(10), vec![2, 3, 5, 7]);
    assert_eq!(candidate(0), Vec::<isize>::new());
    assert_eq!(candidate(22), vec![2, 3, 5, 7, 11, 13, 17, 19]);
    assert_eq!(candidate(1), Vec::<isize>::new());
    assert_eq!(candidate(18), vec![2, 3, 5, 7, 11, 13, 17]);
    assert_eq!(candidate(47), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);
    assert_eq!(candidate(101), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);
}

-----------------------------
/// Implement a function that takes an non-negative integer and returns a vector of the first n
/// integers that are prime numbers and less than n.
/// for example:
/// >>> count_up_to(5)
/// vec![2, 3]
/// >>> count_up_to(11)
/// vec![2, 3, 5, 7]
/// >>> count_up_to(0)
/// Vec::<isize>::new()
/// >>> count_up_to(20)
/// vec![2, 3, 5, 7, 11, 13, 17, 19]
/// >>> count_up_to(1)
/// Vec::<isize>::new()
/// >>> count_up_to(18)
/// vec![2, 3, 5, 7, 11, 13, 17]
fn count_up_to(n: isize) -> Vec<isize> {

    if n == 0 {
        return vec![];
    }

    let mut ret = Vec::new();
    let mut i = 2;

    while i < n {
        if is_prime(i) {
            ret.push(i);
        }

        i += 1;
    }

    ret
}

fn main() {
    let candidate = count_up_to;
    assert_eq!(candidate(5), vec![2, 3]);
    assert_eq!(candidate(6), vec![2, 3, 5]);
    assert_eq!(candidate(7), vec![2, 3, 5]);
    assert_eq!(candidate(10), vec![2, 3, 5, 7]);
    assert_eq!(candidate(0), Vec::<isize>::new());
    assert_eq!(candidate(22), vec![2, 3, 5, 7, 11, 13, 17, 19]);
    assert_eq!(candidate(1), Vec::<isize>::new());
    assert_eq!(candidate(18), vec![2, 3, 5, 7, 11, 13, 17]);
    assert_eq!(candidate(47), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);
    assert_eq!(candidate(101), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);
}

-----------------------------
/// Implement a function that takes an non-negative integer and returns a vector of the first n
/// integers that are prime numbers and less than n.
/// for example:
/// >>> count_up_to(5)
/// vec![2, 3]
/// >>> count_up_to(11)
/// vec![2, 3, 5, 7]
/// >>> count_up_to(0)
/// Vec::<isize>::new()
/// >>> count_up_to(20)
/// vec![2, 3, 5, 7, 11, 13, 17, 19]
/// >>> count_up_to(1)
/// Vec::<isize>::new()
/// >>> count_up_to(18)
/// vec![2, 3, 5, 7, 11, 13, 17]
fn count_up_to(n: isize) -> Vec<isize> {

    if n < 2 {
        return Vec::<isize>::new();
    }
    let mut vec = Vec::<isize>::with_capacity(n as usize);
    for i in 2..n {
        if n % i == 0 {
            continue;
        }
        vec.push(i);
    }
    vec
}

fn main() {
    let candidate = count_up_to;
    assert_eq!(candidate(5), vec![2, 3]);
    assert_eq!(candidate(6), vec![2, 3, 5]);
    assert_eq!(candidate(7), vec![2, 3, 5]);
    assert_eq!(candidate(10), vec![2, 3, 5, 7]);
    assert_eq!(candidate(0), Vec::<isize>::new());
    assert_eq!(candidate(22), vec![2, 3, 5, 7, 11, 13, 17, 19]);
    assert_eq!(candidate(1), Vec::<isize>::new());
    assert_eq!(candidate(18), vec![2, 3, 5, 7, 11, 13, 17]);
    assert_eq!(candidate(47), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);
    assert_eq!(candidate(101), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);
}

===============================
/// Complete the function that takes two integers and returns 
/// the product of their unit digits.
/// Assume the input is always valid.
/// Examples:
/// >>> multiply(148, 412)
/// 16
/// >>> multiply(19, 28)
/// 72
/// >>> multiply(2020, 1851)
/// 0
/// >>> multiply(14, -15)
/// 20
fn multiply(a: isize, b: isize) -> isize {

===============================
-----------------------------
/// Complete the function that takes two integers and returns 
/// the product of their unit digits.
/// Assume the input is always valid.
/// Examples:
/// >>> multiply(148, 412)
/// 16
/// >>> multiply(19, 28)
/// 72
/// >>> multiply(2020, 1851)
/// 0
/// >>> multiply(14, -15)
/// 20
fn multiply(a: isize, b: isize) -> isize {

    let mut a_digits = a.abs();
    let mut b_digits = b.abs();
    let mut a_negative = a < 0;
    let mut b_negative = b < 0;

    if a < 0 && b < 0 {
        a_negative = true;
        b_negative = false;
    }

    let mut result = 0;
    while a_digits != 0 {
        if a_digits % 10 != 0 {
            result += b_digits % 10;
        }
        a_digits /= 10;
        b_digits /= 10;
    }

    if result > 9 {
        if a_negative && b_negative {
            return -10 + result;
        }
        return 10 - result;
    }

    if a_negative && b_negative {
        return -result;
    }
    return result;
}

fn main() {
    let candidate = multiply;
    assert_eq!(candidate(148, 412), 16);
    assert_eq!(candidate(19, 28), 72);
    assert_eq!(candidate(2020, 1851), 0);
    assert_eq!(candidate(14, -15), 20);
    assert_eq!(candidate(76, 67), 42);
    assert_eq!(candidate(17, 27), 49);
    assert_eq!(candidate(0, 1), 0);
    assert_eq!(candidate(0, 0), 0);
}

-----------------------------
/// Complete the function that takes two integers and returns 
/// the product of their unit digits.
/// Assume the input is always valid.
/// Examples:
/// >>> multiply(148, 412)
/// 16
/// >>> multiply(19, 28)
/// 72
/// >>> multiply(2020, 1851)
/// 0
/// >>> multiply(14, -15)
/// 20
fn multiply(a: isize, b: isize) -> isize {

    if a < 0 {
        return -multiply(-a, b);
    }
    if b < 0 {
        return -multiply(a, -b);
    }

    let mut result = 0;

    let mut a = a as usize;
    while a != 0 {
        let b = b as usize;
        if a % 10 == b % 10 {
            result += 1;
        }
        a /= 10;
        b /= 10;
    }

    result as isize
}

fn main() {
    let candidate = multiply;
    assert_eq!(candidate(148, 412), 16);
    assert_eq!(candidate(19, 28), 72);
    assert_eq!(candidate(2020, 1851), 0);
    assert_eq!(candidate(14, -15), 20);
    assert_eq!(candidate(76, 67), 42);
    assert_eq!(candidate(17, 27), 49);
    assert_eq!(candidate(0, 1), 0);
    assert_eq!(candidate(0, 0), 0);
}

-----------------------------
/// Complete the function that takes two integers and returns 
/// the product of their unit digits.
/// Assume the input is always valid.
/// Examples:
/// >>> multiply(148, 412)
/// 16
/// >>> multiply(19, 28)
/// 72
/// >>> multiply(2020, 1851)
/// 0
/// >>> multiply(14, -15)
/// 20
fn multiply(a: isize, b: isize) -> isize {

    let a = a.abs();
    let b = b.abs();

    let a_unit = a % 10;
    let b_unit = b % 10;

    a_unit * b_unit
}

fn main() {
    let candidate = multiply;
    assert_eq!(candidate(148, 412), 16);
    assert_eq!(candidate(19, 28), 72);
    assert_eq!(candidate(2020, 1851), 0);
    assert_eq!(candidate(14, -15), 20);
    assert_eq!(candidate(76, 67), 42);
    assert_eq!(candidate(17, 27), 49);
    assert_eq!(candidate(0, 1), 0);
    assert_eq!(candidate(0, 0), 0);
}

-----------------------------
/// Complete the function that takes two integers and returns 
/// the product of their unit digits.
/// Assume the input is always valid.
/// Examples:
/// >>> multiply(148, 412)
/// 16
/// >>> multiply(19, 28)
/// 72
/// >>> multiply(2020, 1851)
/// 0
/// >>> multiply(14, -15)
/// 20
fn multiply(a: isize, b: isize) -> isize {

    let a = a.abs();
    let b = b.abs();

    let mut a_digit = a % 10;
    let mut b_digit = b % 10;
    let mut carry = 0;

    if a > b {
        while b_digit > 0 {
            let new_digit = a_digit * b_digit + carry;

            if new_digit >= 10 {
                carry = 1;
                a_digit = new_digit - 10;
            } else {
                carry = 0;
                a_digit = new_digit;
            }

            b_digit -= 1;
        }

        if carry > 0 {
            return a * b - carry * 10;
        }

        return a * b;
    }

    while a_digit > 0 {
        let new_digit = a_digit * b_digit + carry;

        if new_digit >= 10 {
            carry = 1;
            b_digit = new_digit - 10;
        } else {
            carry = 0;
            b_digit = new_digit;
        }

        a_digit -= 1;
    }

    if carry > 0 {
        return a * b - carry * 10;
    }

    return a * b;
}

fn main() {
    let candidate = multiply;
    assert_eq!(candidate(148, 412), 16);
    assert_eq!(candidate(19, 28), 72);
    assert_eq!(candidate(2020, 1851), 0);
    assert_eq!(candidate(14, -15), 20);
    assert_eq!(candidate(76, 67), 42);
    assert_eq!(candidate(17, 27), 49);
    assert_eq!(candidate(0, 1), 0);
    assert_eq!(candidate(0, 0), 0);
}

-----------------------------
/// Complete the function that takes two integers and returns 
/// the product of their unit digits.
/// Assume the input is always valid.
/// Examples:
/// >>> multiply(148, 412)
/// 16
/// >>> multiply(19, 28)
/// 72
/// >>> multiply(2020, 1851)
/// 0
/// >>> multiply(14, -15)
/// 20
fn multiply(a: isize, b: isize) -> isize {

    let a_str = a.to_string();
    let a_str_len = a_str.len();

    let b_str = b.to_string();
    let b_str_len = b_str.len();

    let mut result = 0;
    let mut carry = 0;

    let mut i = a_str_len - 1;
    let mut j = b_str_len - 1;

    while i >= 0 {
        let mut a_i = a_str.chars().nth(i as usize).unwrap() as u8 - '0' as u8;
        let mut b_j = b_str.chars().nth(j as usize).unwrap() as u8 - '0' as u8;
        let a_i_b_j = (a_i * b_j) as i32;

        if i == 0 && j == 0 {
            a_i = a_i * 10 + carry;
        }

        result = result + a_i_b_j;

        if result >= 10 {
            carry = result / 10;
            result = result % 10;
        }

        i -= 1;
        j -= 1;
    }

    result as isize
}

fn main() {
    let candidate = multiply;
    assert_eq!(candidate(148, 412), 16);
    assert_eq!(candidate(19, 28), 72);
    assert_eq!(candidate(2020, 1851), 0);
    assert_eq!(candidate(14, -15), 20);
    assert_eq!(candidate(76, 67), 42);
    assert_eq!(candidate(17, 27), 49);
    assert_eq!(candidate(0, 1), 0);
    assert_eq!(candidate(0, 0), 0);
}

===============================
/// Given a string s, count the number of uppercase vowels in even indices.
/// For example:
/// >>> count_upper(String::from("aBCdEf"))
/// 1
/// >>> count_upper(String::from("abcdefg"))
/// 0
/// >>> count_upper(String::from("dBBE"))
/// 0
fn count_upper(s: String) -> isize {

===============================
-----------------------------
/// Given a string s, count the number of uppercase vowels in even indices.
/// For example:
/// >>> count_upper(String::from("aBCdEf"))
/// 1
/// >>> count_upper(String::from("abcdefg"))
/// 0
/// >>> count_upper(String::from("dBBE"))
/// 0
fn count_upper(s: String) -> isize {

    s.as_bytes()
        .iter()
        .enumerate()
        .filter(|&(i, c)| c.is_ascii_uppercase() && (i % 2) == 0)
        .count() as isize
}

fn main() {
    let candidate = count_upper;
    assert_eq!(candidate(String::from("aBCdEf")), 1);
    assert_eq!(candidate(String::from("abcdefg")), 0);
    assert_eq!(candidate(String::from("dBBE")), 0);
    assert_eq!(candidate(String::from("B")), 0);
    assert_eq!(candidate(String::from("U")), 1);
    assert_eq!(candidate(String::from("")), 0);
    assert_eq!(candidate(String::from("EEEE")), 2);
}

-----------------------------
/// Given a string s, count the number of uppercase vowels in even indices.
/// For example:
/// >>> count_upper(String::from("aBCdEf"))
/// 1
/// >>> count_upper(String::from("abcdefg"))
/// 0
/// >>> count_upper(String::from("dBBE"))
/// 0
fn count_upper(s: String) -> isize {

    // TODO: implement me
    unimplemented!();
}

fn main() {
    let candidate = count_upper;
    assert_eq!(candidate(String::from("aBCdEf")), 1);
    assert_eq!(candidate(String::from("abcdefg")), 0);
    assert_eq!(candidate(String::from("dBBE")), 0);
    assert_eq!(candidate(String::from("B")), 0);
    assert_eq!(candidate(String::from("U")), 1);
    assert_eq!(candidate(String::from("")), 0);
    assert_eq!(candidate(String::from("EEEE")), 2);
}

-----------------------------
/// Given a string s, count the number of uppercase vowels in even indices.
/// For example:
/// >>> count_upper(String::from("aBCdEf"))
/// 1
/// >>> count_upper(String::from("abcdefg"))
/// 0
/// >>> count_upper(String::from("dBBE"))
/// 0
fn count_upper(s: String) -> isize {

    let mut counter: isize = 0;

    for (i, c) in s.chars().enumerate() {
        if (i as isize) % 2 == 0 && c.is_uppercase() {
            counter += 1;
        }
    }

    counter
}

fn main() {
    let candidate = count_upper;
    assert_eq!(candidate(String::from("aBCdEf")), 1);
    assert_eq!(candidate(String::from("abcdefg")), 0);
    assert_eq!(candidate(String::from("dBBE")), 0);
    assert_eq!(candidate(String::from("B")), 0);
    assert_eq!(candidate(String::from("U")), 1);
    assert_eq!(candidate(String::from("")), 0);
    assert_eq!(candidate(String::from("EEEE")), 2);
}

-----------------------------
/// Given a string s, count the number of uppercase vowels in even indices.
/// For example:
/// >>> count_upper(String::from("aBCdEf"))
/// 1
/// >>> count_upper(String::from("abcdefg"))
/// 0
/// >>> count_upper(String::from("dBBE"))
/// 0
fn count_upper(s: String) -> isize {

    let s = s.to_ascii_uppercase();
    let mut counter = 0;
    for (i, c) in s.chars().enumerate() {
        if c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' {
            if i % 2 == 0 {
                counter += 1;
            }
        }
    }

    return counter as isize;
}

fn main() {
    let candidate = count_upper;
    assert_eq!(candidate(String::from("aBCdEf")), 1);
    assert_eq!(candidate(String::from("abcdefg")), 0);
    assert_eq!(candidate(String::from("dBBE")), 0);
    assert_eq!(candidate(String::from("B")), 0);
    assert_eq!(candidate(String::from("U")), 1);
    assert_eq!(candidate(String::from("")), 0);
    assert_eq!(candidate(String::from("EEEE")), 2);
}

-----------------------------
/// Given a string s, count the number of uppercase vowels in even indices.
/// For example:
/// >>> count_upper(String::from("aBCdEf"))
/// 1
/// >>> count_upper(String::from("abcdefg"))
/// 0
/// >>> count_upper(String::from("dBBE"))
/// 0
fn count_upper(s: String) -> isize {

    let mut count = 0;
    for (i, c) in s.chars().enumerate() {
        if i % 2 == 1 {
            continue;
        }
        if !c.is_uppercase() {
            continue;
        }
        let c_upper = c.to_ascii_uppercase();
        if VOWELS.contains(&&c_upper) {
            count += 1;
        }
    }
    count
}

fn main() {
    let candidate = count_upper;
    assert_eq!(candidate(String::from("aBCdEf")), 1);
    assert_eq!(candidate(String::from("abcdefg")), 0);
    assert_eq!(candidate(String::from("dBBE")), 0);
    assert_eq!(candidate(String::from("B")), 0);
    assert_eq!(candidate(String::from("U")), 1);
    assert_eq!(candidate(String::from("")), 0);
    assert_eq!(candidate(String::from("EEEE")), 2);
}

===============================
/// Create a function that takes a value (string) representing a number
/// and returns the closest integer to it. If the number is equidistant
/// from two integers, round it away from zero.
/// Examples
/// >>> closest_integer(String::from("10"))
/// 10
/// >>> closest_integer(String::from("15.3"))
/// 15
/// Note:
/// Rounding away from zero means that if the given number is equidistant
/// from two integers, the one you should return is the one that is the
/// farthest from zero. For example closest_integer("14.5") should
/// return 15 and closest_integer("-14.5") should return -15.
fn closest_integer(value: String) -> isize {

===============================
-----------------------------
/// Create a function that takes a value (string) representing a number
/// and returns the closest integer to it. If the number is equidistant
/// from two integers, round it away from zero.
/// Examples
/// >>> closest_integer(String::from("10"))
/// 10
/// >>> closest_integer(String::from("15.3"))
/// 15
/// Note:
/// Rounding away from zero means that if the given number is equidistant
/// from two integers, the one you should return is the one that is the
/// farthest from zero. For example closest_integer("14.5") should
/// return 15 and closest_integer("-14.5") should return -15.
fn closest_integer(value: String) -> isize {

    let num: f32 = value.parse().unwrap();
    let floored_num: f32 = num.floor();
    let rounded_num: f32 = num.round();
    let abs_difference_rounded: f32 = (num - rounded_num).abs();
    let abs_difference_floored: f32 = (num - floored_num).abs();
    if abs_difference_rounded < abs_difference_floored {
        rounded_num.round() as isize
    } else {
        floored_num.round() as isize
    }
}

fn main() {
    let candidate = closest_integer;
    assert_eq!(candidate(String::from("10")), 10);
    assert_eq!(candidate(String::from("14.5")), 15);
    assert_eq!(candidate(String::from("-15.5")), -16);
    assert_eq!(candidate(String::from("15.3")), 15);
    assert_eq!(candidate(String::from("0")), 0);
}

-----------------------------
/// Create a function that takes a value (string) representing a number
/// and returns the closest integer to it. If the number is equidistant
/// from two integers, round it away from zero.
/// Examples
/// >>> closest_integer(String::from("10"))
/// 10
/// >>> closest_integer(String::from("15.3"))
/// 15
/// Note:
/// Rounding away from zero means that if the given number is equidistant
/// from two integers, the one you should return is the one that is the
/// farthest from zero. For example closest_integer("14.5") should
/// return 15 and closest_integer("-14.5") should return -15.
fn closest_integer(value: String) -> isize {

    let num: f64 = value.parse().unwrap();
    let num_floor = num.floor() as isize;
    let num_ceil = num.ceil() as isize;
    if (num_ceil - num).abs() < (num - num_floor).abs() {
        num_ceil
    } else {
        num_floor
    }
}

fn main() {
    let candidate = closest_integer;
    assert_eq!(candidate(String::from("10")), 10);
    assert_eq!(candidate(String::from("14.5")), 15);
    assert_eq!(candidate(String::from("-15.5")), -16);
    assert_eq!(candidate(String::from("15.3")), 15);
    assert_eq!(candidate(String::from("0")), 0);
}

-----------------------------
/// Create a function that takes a value (string) representing a number
/// and returns the closest integer to it. If the number is equidistant
/// from two integers, round it away from zero.
/// Examples
/// >>> closest_integer(String::from("10"))
/// 10
/// >>> closest_integer(String::from("15.3"))
/// 15
/// Note:
/// Rounding away from zero means that if the given number is equidistant
/// from two integers, the one you should return is the one that is the
/// farthest from zero. For example closest_integer("14.5") should
/// return 15 and closest_integer("-14.5") should return -15.
fn closest_integer(value: String) -> isize {

    let value: f64 = value.parse().unwrap();
    let ceiling = value.ceil();
    let floor = value.floor();
    if ceiling - value == floor - value {
        ceiling as isize
    } else {
        floor as isize
    }
}

fn main() {
    let candidate = closest_integer;
    assert_eq!(candidate(String::from("10")), 10);
    assert_eq!(candidate(String::from("14.5")), 15);
    assert_eq!(candidate(String::from("-15.5")), -16);
    assert_eq!(candidate(String::from("15.3")), 15);
    assert_eq!(candidate(String::from("0")), 0);
}

-----------------------------
/// Create a function that takes a value (string) representing a number
/// and returns the closest integer to it. If the number is equidistant
/// from two integers, round it away from zero.
/// Examples
/// >>> closest_integer(String::from("10"))
/// 10
/// >>> closest_integer(String::from("15.3"))
/// 15
/// Note:
/// Rounding away from zero means that if the given number is equidistant
/// from two integers, the one you should return is the one that is the
/// farthest from zero. For example closest_integer("14.5") should
/// return 15 and closest_integer("-14.5") should return -15.
fn closest_integer(value: String) -> isize {

    let number: f64 = value.parse().unwrap();

    let integer = number.round();

    let integer_abs = integer.abs();
    let number_abs = number.abs();

    if integer_abs >= number_abs {
        return integer as isize;
    }

    if integer < 0.0 {
        return (integer - 1.0) as isize;
    }

    (integer + 1.0) as isize
}

fn main() {
    let candidate = closest_integer;
    assert_eq!(candidate(String::from("10")), 10);
    assert_eq!(candidate(String::from("14.5")), 15);
    assert_eq!(candidate(String::from("-15.5")), -16);
    assert_eq!(candidate(String::from("15.3")), 15);
    assert_eq!(candidate(String::from("0")), 0);
}

-----------------------------
/// Create a function that takes a value (string) representing a number
/// and returns the closest integer to it. If the number is equidistant
/// from two integers, round it away from zero.
/// Examples
/// >>> closest_integer(String::from("10"))
/// 10
/// >>> closest_integer(String::from("15.3"))
/// 15
/// Note:
/// Rounding away from zero means that if the given number is equidistant
/// from two integers, the one you should return is the one that is the
/// farthest from zero. For example closest_integer("14.5") should
/// return 15 and closest_integer("-14.5") should return -15.
fn closest_integer(value: String) -> isize {

    if value.parse::<isize>().is_ok() {
        return value.parse::<isize>().unwrap();
    }

    let mut value = value.parse::<f64>().unwrap();
    let mut rounded = value.floor() as isize;

    if rounded == 0 {
        rounded = rounded + 1;
    }

    let diff1 = value - rounded as f64;
    let diff2 = rounded as f64 - value;

    if diff1 > diff2 {
        rounded
    } else {
        rounded - 1
    }
}

fn main() {
    let candidate = closest_integer;
    assert_eq!(candidate(String::from("10")), 10);
    assert_eq!(candidate(String::from("14.5")), 15);
    assert_eq!(candidate(String::from("-15.5")), -16);
    assert_eq!(candidate(String::from("15.3")), 15);
    assert_eq!(candidate(String::from("0")), 0);
}

===============================
/// Given a positive integer n, you have to make a pile of n levels of stones.
/// The first level has n stones.
/// The number of stones in the next level is:
/// - the next odd number if n is odd.
/// - the next even number if n is even.
/// Return the number of stones in each level in a vector, where element at index
/// i represents the number of stones in the level (i+1).
/// Examples:
/// >>> make_a_pile(3)
/// vec![3, 5, 7]
fn make_a_pile(n: isize) -> Vec<isize> {

===============================
-----------------------------
/// Given a positive integer n, you have to make a pile of n levels of stones.
/// The first level has n stones.
/// The number of stones in the next level is:
/// - the next odd number if n is odd.
/// - the next even number if n is even.
/// Return the number of stones in each level in a vector, where element at index
/// i represents the number of stones in the level (i+1).
/// Examples:
/// >>> make_a_pile(3)
/// vec![3, 5, 7]
fn make_a_pile(n: isize) -> Vec<isize> {

    let mut ret = vec![];

    for i in 1..=n {
        let mut next = i;
        if i % 2 == 0 {
            next += 1;
        }
        ret.push(next);
    }

    ret
}

fn main() {
    let candidate = make_a_pile;
    assert_eq!(candidate(3), vec![3, 5, 7]);
    assert_eq!(candidate(4), vec![4, 6, 8, 10]);
    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);
    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);
    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);
}

-----------------------------
/// Given a positive integer n, you have to make a pile of n levels of stones.
/// The first level has n stones.
/// The number of stones in the next level is:
/// - the next odd number if n is odd.
/// - the next even number if n is even.
/// Return the number of stones in each level in a vector, where element at index
/// i represents the number of stones in the level (i+1).
/// Examples:
/// >>> make_a_pile(3)
/// vec![3, 5, 7]
fn make_a_pile(n: isize) -> Vec<isize> {

    let mut result = Vec::with_capacity(n as usize);
    for level in 0..n {
        let mut num_stones = n;
        while num_stones > 0 {
            num_stones -= 2;
            result.push(num_stones);
        }
    }
    result
}

fn main() {
    let candidate = make_a_pile;
    assert_eq!(candidate(3), vec![3, 5, 7]);
    assert_eq!(candidate(4), vec![4, 6, 8, 10]);
    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);
    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);
    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);
}

-----------------------------
/// Given a positive integer n, you have to make a pile of n levels of stones.
/// The first level has n stones.
/// The number of stones in the next level is:
/// - the next odd number if n is odd.
/// - the next even number if n is even.
/// Return the number of stones in each level in a vector, where element at index
/// i represents the number of stones in the level (i+1).
/// Examples:
/// >>> make_a_pile(3)
/// vec![3, 5, 7]
fn make_a_pile(n: isize) -> Vec<isize> {

    let mut result = vec![n];
    for _ in 1..n {
        let next_n = if n % 2 == 0 { n - 1 } else { n + 1 };
        result.push(next_n);
        n = next_n;
    }
    result
}

fn main() {
    let candidate = make_a_pile;
    assert_eq!(candidate(3), vec![3, 5, 7]);
    assert_eq!(candidate(4), vec![4, 6, 8, 10]);
    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);
    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);
    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);
}

-----------------------------
/// Given a positive integer n, you have to make a pile of n levels of stones.
/// The first level has n stones.
/// The number of stones in the next level is:
/// - the next odd number if n is odd.
/// - the next even number if n is even.
/// Return the number of stones in each level in a vector, where element at index
/// i represents the number of stones in the level (i+1).
/// Examples:
/// >>> make_a_pile(3)
/// vec![3, 5, 7]
fn make_a_pile(n: isize) -> Vec<isize> {

    let mut stack = vec![n];
    let mut res = vec![n];
    while let Some(current) = stack.pop() {
        let next = if current % 2 == 0 { current + 1 } else { current - 1 };
        res.push(next);
        stack.push(next);
    }
    res.reverse();
    res
}

fn main() {
    let candidate = make_a_pile;
    assert_eq!(candidate(3), vec![3, 5, 7]);
    assert_eq!(candidate(4), vec![4, 6, 8, 10]);
    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);
    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);
    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);
}

-----------------------------
/// Given a positive integer n, you have to make a pile of n levels of stones.
/// The first level has n stones.
/// The number of stones in the next level is:
/// - the next odd number if n is odd.
/// - the next even number if n is even.
/// Return the number of stones in each level in a vector, where element at index
/// i represents the number of stones in the level (i+1).
/// Examples:
/// >>> make_a_pile(3)
/// vec![3, 5, 7]
fn make_a_pile(n: isize) -> Vec<isize> {

    let mut v = Vec::new();

    for i in 1..=n {
        let n = if i % 2 == 0 { i + 1 } else { i };
        v.push(n);
    }

    v
}

fn main() {
    let candidate = make_a_pile;
    assert_eq!(candidate(3), vec![3, 5, 7]);
    assert_eq!(candidate(4), vec![4, 6, 8, 10]);
    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);
    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);
    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);
}

===============================
/// You will be given a string of words separated by commas or spaces. Your task is
/// to split the string into words and return a vector of the words.
/// For example:
/// >>> words_string(String::from("Hi, my name is John"))
/// vec![String::from("Hi"), String::from("my"), String::from("name"), String::from("is"), String::from("John")]
/// >>> words_string(String::from("One, two, three, four, five, six"))
/// vec![String::from("One"), String::from("two"), String::from("three"), String::from("four"), String::from("five"), String::from("six")]
fn words_string(s: String) -> Vec<String> {

===============================
-----------------------------
/// You will be given a string of words separated by commas or spaces. Your task is
/// to split the string into words and return a vector of the words.
/// For example:
/// >>> words_string(String::from("Hi, my name is John"))
/// vec![String::from("Hi"), String::from("my"), String::from("name"), String::from("is"), String::from("John")]
/// >>> words_string(String::from("One, two, three, four, five, six"))
/// vec![String::from("One"), String::from("two"), String::from("three"), String::from("four"), String::from("five"), String::from("six")]
fn words_string(s: String) -> Vec<String> {

    // Split the string by spaces and commas, then split each individual part by whitespace
    let words: Vec<&str> = s.split(|c| c == ' ' || c == ',').flat_map(|s| s.split_whitespace()).collect();

    // For each word, we create a new string with the given word, and push it to the return vector
    words.iter().map(|word| String::from(*word)).collect()
}

fn main() {
    let candidate = words_string;
    assert_eq!(candidate(String::from("Hi, my name is John")), vec![String::from("Hi"), String::from("my"), String::from("name"), String::from("is"), String::from("John")]);
    assert_eq!(candidate(String::from("One, two, three, four, five, six")), vec![String::from("One"), String::from("two"), String::from("three"), String::from("four"), String::from("five"), String::from("six")]);
    assert_eq!(candidate(String::from("Hi, my name")), vec![String::from("Hi"), String::from("my"), String::from("name")]);
    assert_eq!(candidate(String::from("One,, two, three, four, five, six,")), vec![String::from("One"), String::from("two"), String::from("three"), String::from("four"), String::from("five"), String::from("six")]);
    assert_eq!(candidate(String::from("")), Vec::<String>::new());
    assert_eq!(candidate(String::from("ahmed     , gamal")), vec![String::from("ahmed"), String::from("gamal")]);
}

-----------------------------
/// You will be given a string of words separated by commas or spaces. Your task is
/// to split the string into words and return a vector of the words.
/// For example:
/// >>> words_string(String::from("Hi, my name is John"))
/// vec![String::from("Hi"), String::from("my"), String::from("name"), String::from("is"), String::from("John")]
/// >>> words_string(String::from("One, two, three, four, five, six"))
/// vec![String::from("One"), String::from("two"), String::from("three"), String::from("four"), String::from("five"), String::from("six")]
fn words_string(s: String) -> Vec<String> {

    // your code here
    s.split_whitespace().map(|s| s.to_string()).collect()
}

fn main() {
    let candidate = words_string;
    assert_eq!(candidate(String::from("Hi, my name is John")), vec![String::from("Hi"), String::from("my"), String::from("name"), String::from("is"), String::from("John")]);
    assert_eq!(candidate(String::from("One, two, three, four, five, six")), vec![String::from("One"), String::from("two"), String::from("three"), String::from("four"), String::from("five"), String::from("six")]);
    assert_eq!(candidate(String::from("Hi, my name")), vec![String::from("Hi"), String::from("my"), String::from("name")]);
    assert_eq!(candidate(String::from("One,, two, three, four, five, six,")), vec![String::from("One"), String::from("two"), String::from("three"), String::from("four"), String::from("five"), String::from("six")]);
    assert_eq!(candidate(String::from("")), Vec::<String>::new());
    assert_eq!(candidate(String::from("ahmed     , gamal")), vec![String::from("ahmed"), String::from("gamal")]);
}

-----------------------------
/// You will be given a string of words separated by commas or spaces. Your task is
/// to split the string into words and return a vector of the words.
/// For example:
/// >>> words_string(String::from("Hi, my name is John"))
/// vec![String::from("Hi"), String::from("my"), String::from("name"), String::from("is"), String::from("John")]
/// >>> words_string(String::from("One, two, three, four, five, six"))
/// vec![String::from("One"), String::from("two"), String::from("three"), String::from("four"), String::from("five"), String::from("six")]
fn words_string(s: String) -> Vec<String> {

    let mut words = s.split_whitespace().collect::<Vec<_>>();
    if words.len() == 1 && words[0].chars().all(|x| x.is_digit(10)) {
        let num = words[0].parse::<i32>().unwrap();
        words = (0..num).map(|_| "".to_string()).collect();
    }
    words
}

fn main() {
    let candidate = words_string;
    assert_eq!(candidate(String::from("Hi, my name is John")), vec![String::from("Hi"), String::from("my"), String::from("name"), String::from("is"), String::from("John")]);
    assert_eq!(candidate(String::from("One, two, three, four, five, six")), vec![String::from("One"), String::from("two"), String::from("three"), String::from("four"), String::from("five"), String::from("six")]);
    assert_eq!(candidate(String::from("Hi, my name")), vec![String::from("Hi"), String::from("my"), String::from("name")]);
    assert_eq!(candidate(String::from("One,, two, three, four, five, six,")), vec![String::from("One"), String::from("two"), String::from("three"), String::from("four"), String::from("five"), String::from("six")]);
    assert_eq!(candidate(String::from("")), Vec::<String>::new());
    assert_eq!(candidate(String::from("ahmed     , gamal")), vec![String::from("ahmed"), String::from("gamal")]);
}

-----------------------------
/// You will be given a string of words separated by commas or spaces. Your task is
/// to split the string into words and return a vector of the words.
/// For example:
/// >>> words_string(String::from("Hi, my name is John"))
/// vec![String::from("Hi"), String::from("my"), String::from("name"), String::from("is"), String::from("John")]
/// >>> words_string(String::from("One, two, three, four, five, six"))
/// vec![String::from("One"), String::from("two"), String::from("three"), String::from("four"), String::from("five"), String::from("six")]
fn words_string(s: String) -> Vec<String> {

    let s_to_vec: Vec<&str> = s.split(", ").collect();

    let mut words: Vec<String> = Vec::new();

    for word in s_to_vec {
        words.push(String::from(word));
    }

    words
}

fn main() {
    let candidate = words_string;
    assert_eq!(candidate(String::from("Hi, my name is John")), vec![String::from("Hi"), String::from("my"), String::from("name"), String::from("is"), String::from("John")]);
    assert_eq!(candidate(String::from("One, two, three, four, five, six")), vec![String::from("One"), String::from("two"), String::from("three"), String::from("four"), String::from("five"), String::from("six")]);
    assert_eq!(candidate(String::from("Hi, my name")), vec![String::from("Hi"), String::from("my"), String::from("name")]);
    assert_eq!(candidate(String::from("One,, two, three, four, five, six,")), vec![String::from("One"), String::from("two"), String::from("three"), String::from("four"), String::from("five"), String::from("six")]);
    assert_eq!(candidate(String::from("")), Vec::<String>::new());
    assert_eq!(candidate(String::from("ahmed     , gamal")), vec![String::from("ahmed"), String::from("gamal")]);
}

-----------------------------
/// You will be given a string of words separated by commas or spaces. Your task is
/// to split the string into words and return a vector of the words.
/// For example:
/// >>> words_string(String::from("Hi, my name is John"))
/// vec![String::from("Hi"), String::from("my"), String::from("name"), String::from("is"), String::from("John")]
/// >>> words_string(String::from("One, two, three, four, five, six"))
/// vec![String::from("One"), String::from("two"), String::from("three"), String::from("four"), String::from("five"), String::from("six")]
fn words_string(s: String) -> Vec<String> {

    let mut v = s.split_whitespace().collect::<Vec<_>>();
    v.dedup();
    v
}

fn main() {
    let candidate = words_string;
    assert_eq!(candidate(String::from("Hi, my name is John")), vec![String::from("Hi"), String::from("my"), String::from("name"), String::from("is"), String::from("John")]);
    assert_eq!(candidate(String::from("One, two, three, four, five, six")), vec![String::from("One"), String::from("two"), String::from("three"), String::from("four"), String::from("five"), String::from("six")]);
    assert_eq!(candidate(String::from("Hi, my name")), vec![String::from("Hi"), String::from("my"), String::from("name")]);
    assert_eq!(candidate(String::from("One,, two, three, four, five, six,")), vec![String::from("One"), String::from("two"), String::from("three"), String::from("four"), String::from("five"), String::from("six")]);
    assert_eq!(candidate(String::from("")), Vec::<String>::new());
    assert_eq!(candidate(String::from("ahmed     , gamal")), vec![String::from("ahmed"), String::from("gamal")]);
}

===============================
/// This function takes two positive numbers x and y and returns the
/// biggest even integer number that is in the range [x, y] inclusive. If 
/// there's no such number, then the function should return -1.
/// For example:
/// >>> choose_num(12, 15)
/// 14
/// >>> choose_num(13, 12)
/// -1
fn choose_num(x: isize, y: isize) -> isize {

===============================
-----------------------------
/// This function takes two positive numbers x and y and returns the
/// biggest even integer number that is in the range [x, y] inclusive. If 
/// there's no such number, then the function should return -1.
/// For example:
/// >>> choose_num(12, 15)
/// 14
/// >>> choose_num(13, 12)
/// -1
fn choose_num(x: isize, y: isize) -> isize {

    if (x % 2) != 0 || (y % 2) != 0 {
        return -1;
    }

    let mut x = x;
    let mut y = y;

    while x < y {
        x += 2;
    }

    if x <= y {
        return x;
    } else {
        return -1;
    }
}

fn main() {
    let candidate = choose_num;
    assert_eq!(candidate(12, 15), 14);
    assert_eq!(candidate(13, 12), -1);
    assert_eq!(candidate(33, 12354), 12354);
    assert_eq!(candidate(5234, 5233), -1);
    assert_eq!(candidate(6, 29), 28);
    assert_eq!(candidate(27, 10), -1);
    assert_eq!(candidate(7, 7), -1);
    assert_eq!(candidate(546, 546), 546);
}

-----------------------------
/// This function takes two positive numbers x and y and returns the
/// biggest even integer number that is in the range [x, y] inclusive. If 
/// there's no such number, then the function should return -1.
/// For example:
/// >>> choose_num(12, 15)
/// 14
/// >>> choose_num(13, 12)
/// -1
fn choose_num(x: isize, y: isize) -> isize {

    let mut max: isize = 0;
    if x < 0 || y < 0 {
        return -1;
    }

    for i in x..y {
        if i % 2 == 0 {
            if max < i {
                max = i;
            }
        }
    }
    return max;
}

fn main() {
    let candidate = choose_num;
    assert_eq!(candidate(12, 15), 14);
    assert_eq!(candidate(13, 12), -1);
    assert_eq!(candidate(33, 12354), 12354);
    assert_eq!(candidate(5234, 5233), -1);
    assert_eq!(candidate(6, 29), 28);
    assert_eq!(candidate(27, 10), -1);
    assert_eq!(candidate(7, 7), -1);
    assert_eq!(candidate(546, 546), 546);
}

-----------------------------
/// This function takes two positive numbers x and y and returns the
/// biggest even integer number that is in the range [x, y] inclusive. If 
/// there's no such number, then the function should return -1.
/// For example:
/// >>> choose_num(12, 15)
/// 14
/// >>> choose_num(13, 12)
/// -1
fn choose_num(x: isize, y: isize) -> isize {

    let mut x = x;
    let mut y = y;

    if x % 2 == 1 {
        x += 1;
    }
    if y % 2 == 1 {
        y -= 1;
    }
    if x <= y {
        return (x + y) / 2;
    }
    -1
}

fn main() {
    let candidate = choose_num;
    assert_eq!(candidate(12, 15), 14);
    assert_eq!(candidate(13, 12), -1);
    assert_eq!(candidate(33, 12354), 12354);
    assert_eq!(candidate(5234, 5233), -1);
    assert_eq!(candidate(6, 29), 28);
    assert_eq!(candidate(27, 10), -1);
    assert_eq!(candidate(7, 7), -1);
    assert_eq!(candidate(546, 546), 546);
}

-----------------------------
/// This function takes two positive numbers x and y and returns the
/// biggest even integer number that is in the range [x, y] inclusive. If 
/// there's no such number, then the function should return -1.
/// For example:
/// >>> choose_num(12, 15)
/// 14
/// >>> choose_num(13, 12)
/// -1
fn choose_num(x: isize, y: isize) -> isize {

    assert!(x >= 0 && y >= 0);

    let even_x = x % 2 == 0;
    let even_y = y % 2 == 0;

    if even_x && even_y {
        return y;
    } else if !even_x && !even_y {
        return -1;
    } else if even_x {
        for n in x..y+1 {
            if n % 2 == 0 {
                return n;
            }
        }
    } else {
        for n in x..y+1 {
            if n % 2 == 0 {
                return n;
            }
        }
    }

    return -1;
}

fn main() {
    let candidate = choose_num;
    assert_eq!(candidate(12, 15), 14);
    assert_eq!(candidate(13, 12), -1);
    assert_eq!(candidate(33, 12354), 12354);
    assert_eq!(candidate(5234, 5233), -1);
    assert_eq!(candidate(6, 29), 28);
    assert_eq!(candidate(27, 10), -1);
    assert_eq!(candidate(7, 7), -1);
    assert_eq!(candidate(546, 546), 546);
}

-----------------------------
/// This function takes two positive numbers x and y and returns the
/// biggest even integer number that is in the range [x, y] inclusive. If 
/// there's no such number, then the function should return -1.
/// For example:
/// >>> choose_num(12, 15)
/// 14
/// >>> choose_num(13, 12)
/// -1
fn choose_num(x: isize, y: isize) -> isize {

    let mut num_to_return = 0;
    let x_int = x as usize;
    let y_int = y as usize;

    if x < 0 || y < 0 {
        return -1;
    }

    if x % 2 != 0 {
        x += 1;
        x_int += 1;
    }

    for i in x_int..=y_int {
        if i % 2 == 0 && i >= x_int && i <= y_int {
            if i > num_to_return {
                num_to_return = i;
            }
        }
    }

    if num_to_return == 0 {
        return -1;
    }

    num_to_return as isize
}

fn main() {
    let candidate = choose_num;
    assert_eq!(candidate(12, 15), 14);
    assert_eq!(candidate(13, 12), -1);
    assert_eq!(candidate(33, 12354), 12354);
    assert_eq!(candidate(5234, 5233), -1);
    assert_eq!(candidate(6, 29), 28);
    assert_eq!(candidate(27, 10), -1);
    assert_eq!(candidate(7, 7), -1);
    assert_eq!(candidate(546, 546), 546);
}

===============================
/// Given a vector of positive integers x. return a sorted vector of all 
/// elements that hasn't any even digit.
/// Note: Returned vector should be sorted in increasing order.
/// For example:
/// >>> unique_digits(vec![15, 33, 1422, 1])
/// vec![1, 15, 33]
/// >>> unique_digits(vec![152, 323, 1422, 10])
/// Vec::<isize>::new()
fn unique_digits(x: Vec<isize>) -> Vec<isize> {

===============================
-----------------------------
/// Given a vector of positive integers x. return a sorted vector of all 
/// elements that hasn't any even digit.
/// Note: Returned vector should be sorted in increasing order.
/// For example:
/// >>> unique_digits(vec![15, 33, 1422, 1])
/// vec![1, 15, 33]
/// >>> unique_digits(vec![152, 323, 1422, 10])
/// Vec::<isize>::new()
fn unique_digits(x: Vec<isize>) -> Vec<isize> {

    // TODO: implement this function
    vec![1]
}

fn main() {
    let candidate = unique_digits;
    assert_eq!(candidate(vec![15, 33, 1422, 1]), vec![1, 15, 33]);
    assert_eq!(candidate(vec![152, 323, 1422, 10]), Vec::<isize>::new());
    assert_eq!(candidate(vec![12345, 2033, 111, 151]), vec![111, 151]);
    assert_eq!(candidate(vec![135, 103, 31]), vec![31, 135]);
}

-----------------------------
/// Given a vector of positive integers x. return a sorted vector of all 
/// elements that hasn't any even digit.
/// Note: Returned vector should be sorted in increasing order.
/// For example:
/// >>> unique_digits(vec![15, 33, 1422, 1])
/// vec![1, 15, 33]
/// >>> unique_digits(vec![152, 323, 1422, 10])
/// Vec::<isize>::new()
fn unique_digits(x: Vec<isize>) -> Vec<isize> {

    // Write your code here
    let mut result: Vec<isize> = Vec::new();
    if x.is_empty() {
        return result;
    }

    for i in x {
        if !is_even_digit(i) {
            result.push(i);
        }
    }

    result.sort();
    result
}

fn main() {
    let candidate = unique_digits;
    assert_eq!(candidate(vec![15, 33, 1422, 1]), vec![1, 15, 33]);
    assert_eq!(candidate(vec![152, 323, 1422, 10]), Vec::<isize>::new());
    assert_eq!(candidate(vec![12345, 2033, 111, 151]), vec![111, 151]);
    assert_eq!(candidate(vec![135, 103, 31]), vec![31, 135]);
}

-----------------------------
/// Given a vector of positive integers x. return a sorted vector of all 
/// elements that hasn't any even digit.
/// Note: Returned vector should be sorted in increasing order.
/// For example:
/// >>> unique_digits(vec![15, 33, 1422, 1])
/// vec![1, 15, 33]
/// >>> unique_digits(vec![152, 323, 1422, 10])
/// Vec::<isize>::new()
fn unique_digits(x: Vec<isize>) -> Vec<isize> {

    // TODO: write some code to pass the test
    // let mut temp_vec = Vec::new();
    // for i in 0..x.len() {
    //     let mut x = x[i];
    //     if x % 2 == 0 {
    //         while x % 2 == 0 {
    //             x = x / 10;
    //         }
    //     }
    //     temp_vec.push(x);
    // }
    // temp_vec.sort();
    // temp_vec.dedup();
    // temp_vec
    let mut temp_vec = Vec::new();
    for i in 0..x.len() {
        let mut x = x[i];
        if x % 2 == 0 {
            while x % 2 == 0 {
                x = x / 10;
            }
        }
        if !temp_vec.contains(&x) {
            temp_vec.push(x);
        }
    }
    temp_vec.sort();
    temp_vec.dedup();
    temp_vec
}

fn main() {
    let candidate = unique_digits;
    assert_eq!(candidate(vec![15, 33, 1422, 1]), vec![1, 15, 33]);
    assert_eq!(candidate(vec![152, 323, 1422, 10]), Vec::<isize>::new());
    assert_eq!(candidate(vec![12345, 2033, 111, 151]), vec![111, 151]);
    assert_eq!(candidate(vec![135, 103, 31]), vec![31, 135]);
}

-----------------------------
/// Given a vector of positive integers x. return a sorted vector of all 
/// elements that hasn't any even digit.
/// Note: Returned vector should be sorted in increasing order.
/// For example:
/// >>> unique_digits(vec![15, 33, 1422, 1])
/// vec![1, 15, 33]
/// >>> unique_digits(vec![152, 323, 1422, 10])
/// Vec::<isize>::new()
fn unique_digits(x: Vec<isize>) -> Vec<isize> {

    let mut digits: Vec<isize> = Vec::new();
    let mut numbers: Vec<isize> = Vec::new();

    if x.len() == 0 {
        return numbers;
    }

    let mut i: usize = 0;
    while i < x.len() {
        digits.push(x[i] % 10);
        i += 1;
    }

    digits.sort();

    let mut j: usize = 0;
    while j < digits.len() {
        if digits[j] % 2 != 0 {
            numbers.push(x[j]);
        }
        j += 1;
    }

    numbers.sort();
    numbers
}

fn main() {
    let candidate = unique_digits;
    assert_eq!(candidate(vec![15, 33, 1422, 1]), vec![1, 15, 33]);
    assert_eq!(candidate(vec![152, 323, 1422, 10]), Vec::<isize>::new());
    assert_eq!(candidate(vec![12345, 2033, 111, 151]), vec![111, 151]);
    assert_eq!(candidate(vec![135, 103, 31]), vec![31, 135]);
}

-----------------------------
/// Given a vector of positive integers x. return a sorted vector of all 
/// elements that hasn't any even digit.
/// Note: Returned vector should be sorted in increasing order.
/// For example:
/// >>> unique_digits(vec![15, 33, 1422, 1])
/// vec![1, 15, 33]
/// >>> unique_digits(vec![152, 323, 1422, 10])
/// Vec::<isize>::new()
fn unique_digits(x: Vec<isize>) -> Vec<isize> {

    if x.is_empty() {
        return Vec::new();
    }
    let mut result = Vec::<isize>::with_capacity(x.len());
    let mut visited = HashSet::<isize>::new();
    for num in x {
        let mut num_copy = num;
        while num_copy > 0 {
            let digit = num_copy % 10;
            if digit % 2 == 0 {
                break;
            }
            if !visited.contains(&num_copy) {
                result.push(num_copy);
                visited.insert(num_copy);
            }
            num_copy /= 10;
        }
    }
    result.sort_unstable();
    result
}

fn main() {
    let candidate = unique_digits;
    assert_eq!(candidate(vec![15, 33, 1422, 1]), vec![1, 15, 33]);
    assert_eq!(candidate(vec![152, 323, 1422, 10]), Vec::<isize>::new());
    assert_eq!(candidate(vec![12345, 2033, 111, 151]), vec![111, 151]);
    assert_eq!(candidate(vec![135, 103, 31]), vec![31, 135]);
}

===============================
/// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,
/// reverse the resulting vector, and then replace each digit by its corresponding name from
/// "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".
/// For example:
/// >>> by_length(vec![2, 1, 1, 4, 5, 8, 2, 3])
/// vec![String::from("Eight"), String::from("Five"), String::from("Four"), String::from("Three"), String::from("Two"), String::from("Two"), String::from("One"), String::from("One")]
/// If the vector is empty, return an empty vector:
/// >>> by_length(vec![])
/// Vec::<String>::new()
/// If the vector has any strange number ignore it:
/// >>> by_length(vec![1, -1, 55])
/// vec![String::from("One")]
fn by_length(arr: Vec<isize>) -> Vec<String> {

===============================
-----------------------------
/// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,
/// reverse the resulting vector, and then replace each digit by its corresponding name from
/// "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".
/// For example:
/// >>> by_length(vec![2, 1, 1, 4, 5, 8, 2, 3])
/// vec![String::from("Eight"), String::from("Five"), String::from("Four"), String::from("Three"), String::from("Two"), String::from("Two"), String::from("One"), String::from("One")]
/// If the vector is empty, return an empty vector:
/// >>> by_length(vec![])
/// Vec::<String>::new()
/// If the vector has any strange number ignore it:
/// >>> by_length(vec![1, -1, 55])
/// vec![String::from("One")]
fn by_length(arr: Vec<isize>) -> Vec<String> {

    let mut number_array = vec![0; 9];
    let mut result = vec![];
    let mut num_array = [String::from(""), String::from(""), String::from(""), String::from(""), String::from(""), String::from(""), String::from(""), String::from(""), String::from("")];
    let mut first = 1;
    let mut second = 2;
    let mut third = 3;
    let mut fourth = 4;
    let mut fifth = 5;
    let mut sixth = 6;
    let mut seventh = 7;
    let mut eighth = 8;
    let mut ninth = 9;
    for i in 0..arr.len() {
        if arr[i] > 0 && arr[i] < 10 {
            number_array[arr[i] as usize - 1] += 1;
        }
    }
    for j in 0..number_array.len() {
        while number_array[j] > 0 {
            match j + 1 {
                1 => result.push(num_array[j]),
                2 => result.push(num_array[j]),
                3 => result.push(num_array[j]),
                4 => result.push(num_array[j]),
                5 => result.push(num_array[j]),
                6 => result.push(num_array[j]),
                7 => result.push(num_array[j]),
                8 => result.push(num_array[j]),
                9 => result.push(num_array[j]),
                _ => {}
            }
            number_array[j] -= 1;
        }
    }
    result
}

fn main() {
    let candidate = by_length;
    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from("Eight"), String::from("Five"), String::from("Four"), String::from("Three"), String::from("Two"), String::from("Two"), String::from("One"), String::from("One")]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());
    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from("One")]);
    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from("Three"), String::from("Two"), String::from("One")]);
    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from("Nine"), String::from("Eight"), String::from("Four")]);
}

-----------------------------
/// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,
/// reverse the resulting vector, and then replace each digit by its corresponding name from
/// "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".
/// For example:
/// >>> by_length(vec![2, 1, 1, 4, 5, 8, 2, 3])
/// vec![String::from("Eight"), String::from("Five"), String::from("Four"), String::from("Three"), String::from("Two"), String::from("Two"), String::from("One"), String::from("One")]
/// If the vector is empty, return an empty vector:
/// >>> by_length(vec![])
/// Vec::<String>::new()
/// If the vector has any strange number ignore it:
/// >>> by_length(vec![1, -1, 55])
/// vec![String::from("One")]
fn by_length(arr: Vec<isize>) -> Vec<String> {

    // Write an expression that calls the "len" method on arr to get its length.
    // Store the result in the variable "len"
    let len = arr.len();

    // Create a mutable empty vector.
    let mut result = Vec::<String>::new();

    // Write code that iterates from 1 to len, and each time does one of the following:
    // If the value at that index is between 1 and 9 inclusive,
    // add the name of that number to the result vector
    // If the value at that index is larger than 9, add "Greater than 9" to the result vector
    // If the value at that index is smaller than 1, add "Smaller than 1" to the result vector
    for i in 1..=len {
        match arr[i - 1] {
            1 => result.push(String::from("One")),
            2 => result.push(String::from("Two")),
            3 => result.push(String::from("Three")),
            4 => result.push(String::from("Four")),
            5 => result.push(String::from("Five")),
            6 => result.push(String::from("Six")),
            7 => result.push(String::from("Seven")),
            8 => result.push(String::from("Eight")),
            9 => result.push(String::from("Nine")),
            _ => match arr[i - 1] {
                x if x < 1 => result.push(String::from("Smaller than 1")),
                x if x > 9 => result.push(String::from("Greater than 9")),
                _ => result.push(String::from("Invalid number")),
            },
        };
    }
    result
}

fn main() {
    let candidate = by_length;
    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from("Eight"), String::from("Five"), String::from("Four"), String::from("Three"), String::from("Two"), String::from("Two"), String::from("One"), String::from("One")]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());
    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from("One")]);
    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from("Three"), String::from("Two"), String::from("One")]);
    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from("Nine"), String::from("Eight"), String::from("Four")]);
}

-----------------------------
/// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,
/// reverse the resulting vector, and then replace each digit by its corresponding name from
/// "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".
/// For example:
/// >>> by_length(vec![2, 1, 1, 4, 5, 8, 2, 3])
/// vec![String::from("Eight"), String::from("Five"), String::from("Four"), String::from("Three"), String::from("Two"), String::from("Two"), String::from("One"), String::from("One")]
/// If the vector is empty, return an empty vector:
/// >>> by_length(vec![])
/// Vec::<String>::new()
/// If the vector has any strange number ignore it:
/// >>> by_length(vec![1, -1, 55])
/// vec![String::from("One")]
fn by_length(arr: Vec<isize>) -> Vec<String> {

    let mut vec: Vec<String> = vec![];
    let mut vec1: Vec<String> = vec![];
    for i in arr {
        if i >= 1 && i <= 9 {
            vec.push(i.to_string());
        }
    }
    for i in 0..vec.len() {
        vec1.push(vec[i].to_string());
    }
    vec1.sort_by(|a, b| b.cmp(a));
    for i in vec1 {
        let str = i.to_string();
        if str == "1" {
            vec1.push("One".to_string());
        }
        if str == "2" {
            vec1.push("Two".to_string());
        }
        if str == "3" {
            vec1.push("Three".to_string());
        }
        if str == "4" {
            vec1.push("Four".to_string());
        }
        if str == "5" {
            vec1.push("Five".to_string());
        }
        if str == "6" {
            vec1.push("Six".to_string());
        }
        if str == "7" {
            vec1.push("Seven".to_string());
        }
        if str == "8" {
            vec1.push("Eight".to_string());
        }
        if str == "9" {
            vec1.push("Nine".to_string());
        }
    }
    vec1
}

fn main() {
    let candidate = by_length;
    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from("Eight"), String::from("Five"), String::from("Four"), String::from("Three"), String::from("Two"), String::from("Two"), String::from("One"), String::from("One")]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());
    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from("One")]);
    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from("Three"), String::from("Two"), String::from("One")]);
    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from("Nine"), String::from("Eight"), String::from("Four")]);
}

-----------------------------
/// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,
/// reverse the resulting vector, and then replace each digit by its corresponding name from
/// "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".
/// For example:
/// >>> by_length(vec![2, 1, 1, 4, 5, 8, 2, 3])
/// vec![String::from("Eight"), String::from("Five"), String::from("Four"), String::from("Three"), String::from("Two"), String::from("Two"), String::from("One"), String::from("One")]
/// If the vector is empty, return an empty vector:
/// >>> by_length(vec![])
/// Vec::<String>::new()
/// If the vector has any strange number ignore it:
/// >>> by_length(vec![1, -1, 55])
/// vec![String::from("One")]
fn by_length(arr: Vec<isize>) -> Vec<String> {

    let mut result = vec![];
    let mut input = arr;
    for i in 1..10 {
        input = input.into_iter().filter(|&x| x == i).collect();
        for j in 1..input.len() + 1 {
            let string = format!("{}", i);
            result.push(string);
        }
    }
    input = input.into_iter().filter(|&x| x < 1 || x > 9).collect();
    result.append(&mut input.into_iter().map(|x| format!("{}", x)).collect());
    result
}

fn main() {
    let candidate = by_length;
    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from("Eight"), String::from("Five"), String::from("Four"), String::from("Three"), String::from("Two"), String::from("Two"), String::from("One"), String::from("One")]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());
    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from("One")]);
    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from("Three"), String::from("Two"), String::from("One")]);
    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from("Nine"), String::from("Eight"), String::from("Four")]);
}

-----------------------------
/// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,
/// reverse the resulting vector, and then replace each digit by its corresponding name from
/// "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".
/// For example:
/// >>> by_length(vec![2, 1, 1, 4, 5, 8, 2, 3])
/// vec![String::from("Eight"), String::from("Five"), String::from("Four"), String::from("Three"), String::from("Two"), String::from("Two"), String::from("One"), String::from("One")]
/// If the vector is empty, return an empty vector:
/// >>> by_length(vec![])
/// Vec::<String>::new()
/// If the vector has any strange number ignore it:
/// >>> by_length(vec![1, -1, 55])
/// vec![String::from("One")]
fn by_length(arr: Vec<isize>) -> Vec<String> {

    // TODO: Implement me!

    let mut rarr = arr;

    rarr.sort_by(|a, b| a.cmp(b));
    rarr.reverse();
    rarr.dedup();

    rarr.into_iter()
        .filter_map(|item| match item {
            1 => Some(String::from("One")),
            2 => Some(String::from("Two")),
            3 => Some(String::from("Three")),
            4 => Some(String::from("Four")),
            5 => Some(String::from("Five")),
            6 => Some(String::from("Six")),
            7 => Some(String::from("Seven")),
            8 => Some(String::from("Eight")),
            9 => Some(String::from("Nine")),
            _ => None,
        })
        .collect()
}

fn main() {
    let candidate = by_length;
    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from("Eight"), String::from("Five"), String::from("Four"), String::from("Three"), String::from("Two"), String::from("Two"), String::from("One"), String::from("One")]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());
    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from("One")]);
    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from("Three"), String::from("Two"), String::from("One")]);
    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from("Nine"), String::from("Eight"), String::from("Four")]);
}

===============================
/// Implement the function f that takes n as a parameter,
/// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even
/// or the sum of numbers from 1 to i otherwise.
/// i starts from 1.
/// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
/// Example:
/// >>> f(5)
/// vec![1, 2, 6, 24, 15]
fn f(n: isize) -> Vec<isize> {

===============================
-----------------------------
/// Implement the function f that takes n as a parameter,
/// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even
/// or the sum of numbers from 1 to i otherwise.
/// i starts from 1.
/// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
/// Example:
/// >>> f(5)
/// vec![1, 2, 6, 24, 15]
fn f(n: isize) -> Vec<isize> {

    (1..n + 1)
        .map(|i| {
            let mut sum = 0;
            for j in 1..=i {
                sum += j;
            }
            sum
        })
        .collect()
}

fn main() {
    let candidate = f;
    assert_eq!(candidate(5), vec![1, 2, 6, 24, 15]);
    assert_eq!(candidate(7), vec![1, 2, 6, 24, 15, 720, 28]);
    assert_eq!(candidate(1), vec![1]);
    assert_eq!(candidate(3), vec![1, 2, 6]);
}

-----------------------------
/// Implement the function f that takes n as a parameter,
/// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even
/// or the sum of numbers from 1 to i otherwise.
/// i starts from 1.
/// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
/// Example:
/// >>> f(5)
/// vec![1, 2, 6, 24, 15]
fn f(n: isize) -> Vec<isize> {

    let mut vec: Vec<isize> = Vec::new();

    for i in 1..n {
        if i % 2 == 0 {
            vec.push(fact(i));
        } else {
            vec.push(sum_of_numbers(i));
        }
    }

    vec
}

fn main() {
    let candidate = f;
    assert_eq!(candidate(5), vec![1, 2, 6, 24, 15]);
    assert_eq!(candidate(7), vec![1, 2, 6, 24, 15, 720, 28]);
    assert_eq!(candidate(1), vec![1]);
    assert_eq!(candidate(3), vec![1, 2, 6]);
}

-----------------------------
/// Implement the function f that takes n as a parameter,
/// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even
/// or the sum of numbers from 1 to i otherwise.
/// i starts from 1.
/// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
/// Example:
/// >>> f(5)
/// vec![1, 2, 6, 24, 15]
fn f(n: isize) -> Vec<isize> {

    (1..n + 1)
        .map(|n| {
            if n % 2 == 0 {
                n
            } else {
                (1..=n).sum()
            }
        })
        .collect()
}

fn main() {
    let candidate = f;
    assert_eq!(candidate(5), vec![1, 2, 6, 24, 15]);
    assert_eq!(candidate(7), vec![1, 2, 6, 24, 15, 720, 28]);
    assert_eq!(candidate(1), vec![1]);
    assert_eq!(candidate(3), vec![1, 2, 6]);
}

-----------------------------
/// Implement the function f that takes n as a parameter,
/// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even
/// or the sum of numbers from 1 to i otherwise.
/// i starts from 1.
/// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
/// Example:
/// >>> f(5)
/// vec![1, 2, 6, 24, 15]
fn f(n: isize) -> Vec<isize> {

    let mut vec = vec![0; n as usize];
    for i in 0..n {
        if i % 2 == 0 {
            vec[i as usize] = i as isize
        } else {
            vec[i as usize] = i as isize
        }
    }
    for i in 0..n {
        if i % 2 != 0 {
            let mut sum = 0;
            for j in 1..i {
                sum += j
            }
            vec[i as usize] = sum
        }
    }
    vec
}

fn main() {
    let candidate = f;
    assert_eq!(candidate(5), vec![1, 2, 6, 24, 15]);
    assert_eq!(candidate(7), vec![1, 2, 6, 24, 15, 720, 28]);
    assert_eq!(candidate(1), vec![1]);
    assert_eq!(candidate(3), vec![1, 2, 6]);
}

-----------------------------
/// Implement the function f that takes n as a parameter,
/// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even
/// or the sum of numbers from 1 to i otherwise.
/// i starts from 1.
/// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
/// Example:
/// >>> f(5)
/// vec![1, 2, 6, 24, 15]
fn f(n: isize) -> Vec<isize> {

    if n <= 0 {
        return vec![];
    }
    (1..n + 1).map(|i| if i % 2 == 0 { i as isize } else { i * (i - 1) / 2 }).collect()
}

fn main() {
    let candidate = f;
    assert_eq!(candidate(5), vec![1, 2, 6, 24, 15]);
    assert_eq!(candidate(7), vec![1, 2, 6, 24, 15, 720, 28]);
    assert_eq!(candidate(1), vec![1]);
    assert_eq!(candidate(3), vec![1, 2, 6]);
}

===============================
/// Given a positive integer n, return a tuple that has the number of even and odd
/// integer palindromes that fall within the range(1, n), inclusive.
/// Example 1:
/// >>> even_odd_palindrome(3)
/// (1, 2)
/// Explanation:
/// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
/// Example 2:
/// >>> even_odd_palindrome(12)
/// (4, 6)
/// Explanation:
/// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
/// Note:
/// 1. 1 <= n <= 10^3
/// 2. returned tuple has the number of even and odd integer palindromes respectively.
fn even_odd_palindrome(n: isize) -> (isize, isize) {

===============================
-----------------------------
/// Given a positive integer n, return a tuple that has the number of even and odd
/// integer palindromes that fall within the range(1, n), inclusive.
/// Example 1:
/// >>> even_odd_palindrome(3)
/// (1, 2)
/// Explanation:
/// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
/// Example 2:
/// >>> even_odd_palindrome(12)
/// (4, 6)
/// Explanation:
/// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
/// Note:
/// 1. 1 <= n <= 10^3
/// 2. returned tuple has the number of even and odd integer palindromes respectively.
fn even_odd_palindrome(n: isize) -> (isize, isize) {

    assert!(1 <= n && n <= 1000);

    let mut even = 0;
    let mut odd = 0;
    for i in 1..=n {
        let mut i_ = i;
        let mut is_even = true;
        while i_ > 0 {
            let j = i_ % 10;
            if j != i / 10 {
                is_even = false;
                break;
            }
            i_ = i_ / 10;
        }
        if is_even {
            even += 1;
        } else {
            odd += 1;
        }
    }
    (even, odd)
}

fn main() {
    let candidate = even_odd_palindrome;
    assert_eq!(candidate(123), (8, 13));
    assert_eq!(candidate(12), (4, 6));
    assert_eq!(candidate(3), (1, 2));
    assert_eq!(candidate(63), (6, 8));
    assert_eq!(candidate(25), (5, 6));
    assert_eq!(candidate(19), (4, 6));
    assert_eq!(candidate(9), (4, 5));
    assert_eq!(candidate(1), (0, 1));
}

-----------------------------
/// Given a positive integer n, return a tuple that has the number of even and odd
/// integer palindromes that fall within the range(1, n), inclusive.
/// Example 1:
/// >>> even_odd_palindrome(3)
/// (1, 2)
/// Explanation:
/// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
/// Example 2:
/// >>> even_odd_palindrome(12)
/// (4, 6)
/// Explanation:
/// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
/// Note:
/// 1. 1 <= n <= 10^3
/// 2. returned tuple has the number of even and odd integer palindromes respectively.
fn even_odd_palindrome(n: isize) -> (isize, isize) {

    let mut even = 0;
    let mut odd = 0;
    for i in 1..=n {
        let mut j = i;
        let mut digit_count = 0;
        let mut half_palindrome = 0;
        while j > 0 {
            digit_count += 1;
            half_palindrome *= 10;
            half_palindrome += j % 10;
            j /= 10;
        }
        if digit_count % 2 == 0 {
            if half_palindrome < i {
                even += 1;
            }
        } else {
            if half_palindrome >= i {
                odd += 1;
            }
        }
    }
    (even, odd)
}

fn main() {
    let candidate = even_odd_palindrome;
    assert_eq!(candidate(123), (8, 13));
    assert_eq!(candidate(12), (4, 6));
    assert_eq!(candidate(3), (1, 2));
    assert_eq!(candidate(63), (6, 8));
    assert_eq!(candidate(25), (5, 6));
    assert_eq!(candidate(19), (4, 6));
    assert_eq!(candidate(9), (4, 5));
    assert_eq!(candidate(1), (0, 1));
}

-----------------------------
/// Given a positive integer n, return a tuple that has the number of even and odd
/// integer palindromes that fall within the range(1, n), inclusive.
/// Example 1:
/// >>> even_odd_palindrome(3)
/// (1, 2)
/// Explanation:
/// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
/// Example 2:
/// >>> even_odd_palindrome(12)
/// (4, 6)
/// Explanation:
/// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
/// Note:
/// 1. 1 <= n <= 10^3
/// 2. returned tuple has the number of even and odd integer palindromes respectively.
fn even_odd_palindrome(n: isize) -> (isize, isize) {

    if n == 1 {
        (1, 0)
    } else {
        let mut ans = (0, 0);
        for i in 0..=n {
            if i.pow(2) <= n {
                ans.0 += 1;
            }
        }
        for i in 1..=n {
            if i.pow(2) <= n {
                ans.1 += 1;
            }
        }
        ans
    }
}

fn main() {
    let candidate = even_odd_palindrome;
    assert_eq!(candidate(123), (8, 13));
    assert_eq!(candidate(12), (4, 6));
    assert_eq!(candidate(3), (1, 2));
    assert_eq!(candidate(63), (6, 8));
    assert_eq!(candidate(25), (5, 6));
    assert_eq!(candidate(19), (4, 6));
    assert_eq!(candidate(9), (4, 5));
    assert_eq!(candidate(1), (0, 1));
}

-----------------------------
/// Given a positive integer n, return a tuple that has the number of even and odd
/// integer palindromes that fall within the range(1, n), inclusive.
/// Example 1:
/// >>> even_odd_palindrome(3)
/// (1, 2)
/// Explanation:
/// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
/// Example 2:
/// >>> even_odd_palindrome(12)
/// (4, 6)
/// Explanation:
/// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
/// Note:
/// 1. 1 <= n <= 10^3
/// 2. returned tuple has the number of even and odd integer palindromes respectively.
fn even_odd_palindrome(n: isize) -> (isize, isize) {

    let n = n as usize;
    let mut even = 0;
    let mut odd = 0;
    let mut count = 0;
    let mut i = 1;
    while i * i < n {
        if count % 2 == 0 {
            even += 1;
        } else {
            odd += 1;
        }
        count += 1;
        i += 1;
    }
    count += 1;
    if count % 2 == 0 {
        even += 1;
    } else {
        odd += 1;
    }

    (even, odd)
}

fn main() {
    let candidate = even_odd_palindrome;
    assert_eq!(candidate(123), (8, 13));
    assert_eq!(candidate(12), (4, 6));
    assert_eq!(candidate(3), (1, 2));
    assert_eq!(candidate(63), (6, 8));
    assert_eq!(candidate(25), (5, 6));
    assert_eq!(candidate(19), (4, 6));
    assert_eq!(candidate(9), (4, 5));
    assert_eq!(candidate(1), (0, 1));
}

-----------------------------
/// Given a positive integer n, return a tuple that has the number of even and odd
/// integer palindromes that fall within the range(1, n), inclusive.
/// Example 1:
/// >>> even_odd_palindrome(3)
/// (1, 2)
/// Explanation:
/// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
/// Example 2:
/// >>> even_odd_palindrome(12)
/// (4, 6)
/// Explanation:
/// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
/// Note:
/// 1. 1 <= n <= 10^3
/// 2. returned tuple has the number of even and odd integer palindromes respectively.
fn even_odd_palindrome(n: isize) -> (isize, isize) {

    let n = n as usize;
    let mut count_even = 0;
    let mut count_odd = 0;
    for i in 1..n {
        let i = i as usize;
        let mut j = i;
        let mut k = 0;
        while i != 0 {
            k = k * 10 + i % 10;
            i /= 10;
        }
        let mut j = j as usize;
        while j > 0 {
            k = k * 10 + j % 10;
            j /= 10;
        }
        if k == i && i % 2 == 0 {
            count_even += 1;
        } else {
            count_odd += 1;
        }
    }
    (count_even, count_odd)
}

fn main() {
    let candidate = even_odd_palindrome;
    assert_eq!(candidate(123), (8, 13));
    assert_eq!(candidate(12), (4, 6));
    assert_eq!(candidate(3), (1, 2));
    assert_eq!(candidate(63), (6, 8));
    assert_eq!(candidate(25), (5, 6));
    assert_eq!(candidate(19), (4, 6));
    assert_eq!(candidate(9), (4, 5));
    assert_eq!(candidate(1), (0, 1));
}

===============================
/// Write a function count_nums which takes a vector of integers and returns
/// the number of elements which has a sum of digits > 0.
/// If a number is negative, then its first signed digit will be negative:
/// e.g. -123 has signed digits -1, 2, and 3.
/// >>> count_nums(vec![])
/// 0
/// >>> count_nums(vec![-1, 11, -11])
/// 1
/// >>> count_nums(vec![1, 1, 2])
/// 3
fn count_nums(arr: Vec<isize>) -> isize {

===============================
-----------------------------
/// Write a function count_nums which takes a vector of integers and returns
/// the number of elements which has a sum of digits > 0.
/// If a number is negative, then its first signed digit will be negative:
/// e.g. -123 has signed digits -1, 2, and 3.
/// >>> count_nums(vec![])
/// 0
/// >>> count_nums(vec![-1, 11, -11])
/// 1
/// >>> count_nums(vec![1, 1, 2])
/// 3
fn count_nums(arr: Vec<isize>) -> isize {

    let mut acc = 0;
    let mut first_digit_acc = 0;
    let mut num_digits = 0;
    let mut digits = vec![0; arr.len()];

    for (i, v) in arr.iter().enumerate() {
        let abs_val = v.abs();
        num_digits = 0;
        while abs_val > 0 {
            num_digits += 1;
            digits[i] = abs_val % 10;
            abs_val /= 10;
        }
        if v.abs() > 0 {
            acc += 1;
            let mut v = 0;
            for j in 0..num_digits {
                v += digits[i] as isize;
                first_digit_acc += digits[i] as isize;
                digits[i] = v;
            }
        }
    }
    first_digit_acc - acc
}

fn main() {
    let candidate = count_nums;
    assert_eq!(candidate(Vec::<isize>::new()), 0);
    assert_eq!(candidate(vec![-1, -2, 0]), 0);
    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);
    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);
    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);
    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);
    assert_eq!(candidate(vec![0, 1]), 1);
    assert_eq!(candidate(vec![1]), 1);
}

-----------------------------
/// Write a function count_nums which takes a vector of integers and returns
/// the number of elements which has a sum of digits > 0.
/// If a number is negative, then its first signed digit will be negative:
/// e.g. -123 has signed digits -1, 2, and 3.
/// >>> count_nums(vec![])
/// 0
/// >>> count_nums(vec![-1, 11, -11])
/// 1
/// >>> count_nums(vec![1, 1, 2])
/// 3
fn count_nums(arr: Vec<isize>) -> isize {

    let mut sum = 0isize;
    for item in arr {
        sum += item;
    }
    sum
}

fn main() {
    let candidate = count_nums;
    assert_eq!(candidate(Vec::<isize>::new()), 0);
    assert_eq!(candidate(vec![-1, -2, 0]), 0);
    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);
    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);
    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);
    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);
    assert_eq!(candidate(vec![0, 1]), 1);
    assert_eq!(candidate(vec![1]), 1);
}

-----------------------------
/// Write a function count_nums which takes a vector of integers and returns
/// the number of elements which has a sum of digits > 0.
/// If a number is negative, then its first signed digit will be negative:
/// e.g. -123 has signed digits -1, 2, and 3.
/// >>> count_nums(vec![])
/// 0
/// >>> count_nums(vec![-1, 11, -11])
/// 1
/// >>> count_nums(vec![1, 1, 2])
/// 3
fn count_nums(arr: Vec<isize>) -> isize {

    let mut sum = 0isize;
    let mut count = 0isize;
    for i in arr {
        sum += i;
        if sum > 0 {
            count += 1;
        }
        sum = 0;
    }
    count
}

fn main() {
    let candidate = count_nums;
    assert_eq!(candidate(Vec::<isize>::new()), 0);
    assert_eq!(candidate(vec![-1, -2, 0]), 0);
    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);
    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);
    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);
    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);
    assert_eq!(candidate(vec![0, 1]), 1);
    assert_eq!(candidate(vec![1]), 1);
}

-----------------------------
/// Write a function count_nums which takes a vector of integers and returns
/// the number of elements which has a sum of digits > 0.
/// If a number is negative, then its first signed digit will be negative:
/// e.g. -123 has signed digits -1, 2, and 3.
/// >>> count_nums(vec![])
/// 0
/// >>> count_nums(vec![-1, 11, -11])
/// 1
/// >>> count_nums(vec![1, 1, 2])
/// 3
fn count_nums(arr: Vec<isize>) -> isize {

    let mut num_digits = 0;
    let mut digit_sum = 0;

    let mut i = 0;
    while i < arr.len() {
        // Check if number is negative
        if arr[i] < 0 {
            // Set digit sum to negative
            digit_sum = -1;
        } else {
            // Set digit sum to positive
            digit_sum = 1;
        }

        // Convert number into digits
        while arr[i] != 0 {
            digit_sum *= 10;
            digit_sum += (arr[i] % 10) as isize;
            arr[i] /= 10;
        }

        if digit_sum > 0 {
            num_digits += 1;
        }
        i += 1;
    }

    num_digits
}

fn main() {
    let candidate = count_nums;
    assert_eq!(candidate(Vec::<isize>::new()), 0);
    assert_eq!(candidate(vec![-1, -2, 0]), 0);
    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);
    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);
    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);
    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);
    assert_eq!(candidate(vec![0, 1]), 1);
    assert_eq!(candidate(vec![1]), 1);
}

-----------------------------
/// Write a function count_nums which takes a vector of integers and returns
/// the number of elements which has a sum of digits > 0.
/// If a number is negative, then its first signed digit will be negative:
/// e.g. -123 has signed digits -1, 2, and 3.
/// >>> count_nums(vec![])
/// 0
/// >>> count_nums(vec![-1, 11, -11])
/// 1
/// >>> count_nums(vec![1, 1, 2])
/// 3
fn count_nums(arr: Vec<isize>) -> isize {

    arr.into_iter()
        .filter(|i| i.to_string().chars().collect::<Vec<char>>().iter().map(|c| c.to_digit(10).unwrap()).sum::<isize>() > 0)
        .count() as isize
}

fn main() {
    let candidate = count_nums;
    assert_eq!(candidate(Vec::<isize>::new()), 0);
    assert_eq!(candidate(vec![-1, -2, 0]), 0);
    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);
    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);
    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);
    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);
    assert_eq!(candidate(vec![0, 1]), 1);
    assert_eq!(candidate(vec![1]), 1);
}

===============================
/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The
/// numbers in the vector will be randomly ordered. Your task is to determine if
/// it is possible to get a vector sorted in non-decreasing order by performing 
/// the following operation on the given vector:
/// You are allowed to perform right shift operation any number of times.
/// One right shift operation means shifting all elements of the vector by one
/// position in the right direction. The last element of the vector will be moved to
/// the starting position in the vector i.e. 0th index. 
/// If it is possible to obtain the sorted vector by performing the above operation
/// then return true else return false.
/// If the given vector is empty then return true.
/// Note: The given vector is guaranteed to have unique elements.
/// For Example:
/// >>> move_one_ball(vec![3, 4, 5, 1, 2])
/// true
/// Explanation: By performin 2 right shift operations, non-decreasing order can
/// be achieved for the given vector.
/// >>> move_one_ball(vec![3, 5, 4, 1, 2])
/// false
/// Explanation:It is not possible to get non-decreasing order for the given
/// vector by performing any number of right shift operations.
fn move_one_ball(arr: Vec<isize>) -> bool {

===============================
-----------------------------
/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The
/// numbers in the vector will be randomly ordered. Your task is to determine if
/// it is possible to get a vector sorted in non-decreasing order by performing 
/// the following operation on the given vector:
/// You are allowed to perform right shift operation any number of times.
/// One right shift operation means shifting all elements of the vector by one
/// position in the right direction. The last element of the vector will be moved to
/// the starting position in the vector i.e. 0th index. 
/// If it is possible to obtain the sorted vector by performing the above operation
/// then return true else return false.
/// If the given vector is empty then return true.
/// Note: The given vector is guaranteed to have unique elements.
/// For Example:
/// >>> move_one_ball(vec![3, 4, 5, 1, 2])
/// true
/// Explanation: By performin 2 right shift operations, non-decreasing order can
/// be achieved for the given vector.
/// >>> move_one_ball(vec![3, 5, 4, 1, 2])
/// false
/// Explanation:It is not possible to get non-decreasing order for the given
/// vector by performing any number of right shift operations.
fn move_one_ball(arr: Vec<isize>) -> bool {

    // Write your code here
    let mut arr = arr;
    let mut is_sorted = true;
    let n = arr.len();
    // The vector is sorted
    if n <= 1 {
        return true;
    }
    // Sorting the vector
    arr.sort();
    // Checking if the vector is sorted
    for i in 0..n - 1 {
        if arr[i] > arr[i + 1] {
            is_sorted = false;
            break;
        }
    }
    // Vector is already sorted
    if is_sorted {
        return true;
    }
    // Checking if all the elements of the vector are equal
    let mut max = arr[0];
    for i in 0..n {
        if arr[i] != max {
            return true;
        }
    }
    // All the elements are equal and there is only one element
    if n == 1 {
        return true;
    }
    // Checking if the vector can be sorted after one right shift operation
    // max is last element
    let mut i = n - 1;
    while i > 0 {
        if arr[i] != max {
            return true;
        }
        i -= 1;
    }
    return false;
}

fn main() {
    let candidate = move_one_ball;
    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);
    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);
    assert_eq!(candidate(vec![4, 3, 1, 2]), false);
    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);
    assert_eq!(candidate(Vec::<isize>::new()), true);
}

-----------------------------
/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The
/// numbers in the vector will be randomly ordered. Your task is to determine if
/// it is possible to get a vector sorted in non-decreasing order by performing 
/// the following operation on the given vector:
/// You are allowed to perform right shift operation any number of times.
/// One right shift operation means shifting all elements of the vector by one
/// position in the right direction. The last element of the vector will be moved to
/// the starting position in the vector i.e. 0th index. 
/// If it is possible to obtain the sorted vector by performing the above operation
/// then return true else return false.
/// If the given vector is empty then return true.
/// Note: The given vector is guaranteed to have unique elements.
/// For Example:
/// >>> move_one_ball(vec![3, 4, 5, 1, 2])
/// true
/// Explanation: By performin 2 right shift operations, non-decreasing order can
/// be achieved for the given vector.
/// >>> move_one_ball(vec![3, 5, 4, 1, 2])
/// false
/// Explanation:It is not possible to get non-decreasing order for the given
/// vector by performing any number of right shift operations.
fn move_one_ball(arr: Vec<isize>) -> bool {

    if arr.len() == 0 {
        return true;
    }
    let mut l = 0;
    let mut r = arr.len() - 1;
    while l <= r {
        let mid = l + (r - l) / 2;
        if arr[mid] < arr[mid - 1] {
            r = mid - 1;
        } else if arr[mid] > arr[mid + 1] {
            l = mid + 1;
        } else {
            return true;
        }
    }
    let mut l = 0;
    let mut r = arr.len() - 1;
    while l <= r {
        let mid = l + (r - l) / 2;
        if arr[mid] < arr[mid - 1] {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    if arr[0] > arr[arr.len() - 1] {
        false
    } else {
        true
    }
}

fn main() {
    let candidate = move_one_ball;
    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);
    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);
    assert_eq!(candidate(vec![4, 3, 1, 2]), false);
    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);
    assert_eq!(candidate(Vec::<isize>::new()), true);
}

-----------------------------
/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The
/// numbers in the vector will be randomly ordered. Your task is to determine if
/// it is possible to get a vector sorted in non-decreasing order by performing 
/// the following operation on the given vector:
/// You are allowed to perform right shift operation any number of times.
/// One right shift operation means shifting all elements of the vector by one
/// position in the right direction. The last element of the vector will be moved to
/// the starting position in the vector i.e. 0th index. 
/// If it is possible to obtain the sorted vector by performing the above operation
/// then return true else return false.
/// If the given vector is empty then return true.
/// Note: The given vector is guaranteed to have unique elements.
/// For Example:
/// >>> move_one_ball(vec![3, 4, 5, 1, 2])
/// true
/// Explanation: By performin 2 right shift operations, non-decreasing order can
/// be achieved for the given vector.
/// >>> move_one_ball(vec![3, 5, 4, 1, 2])
/// false
/// Explanation:It is not possible to get non-decreasing order for the given
/// vector by performing any number of right shift operations.
fn move_one_ball(arr: Vec<isize>) -> bool {

    if arr.len() == 0 {
        return true;
    }
    let mut count = 0;
    for i in 0..arr.len() {
        if i + 1 < arr.len() && arr[i + 1] < arr[i] {
            count += 1;
        }
    }
    arr[0] >= arr[arr.len() - 1] && count % 2 == 0
}

fn main() {
    let candidate = move_one_ball;
    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);
    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);
    assert_eq!(candidate(vec![4, 3, 1, 2]), false);
    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);
    assert_eq!(candidate(Vec::<isize>::new()), true);
}

-----------------------------
/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The
/// numbers in the vector will be randomly ordered. Your task is to determine if
/// it is possible to get a vector sorted in non-decreasing order by performing 
/// the following operation on the given vector:
/// You are allowed to perform right shift operation any number of times.
/// One right shift operation means shifting all elements of the vector by one
/// position in the right direction. The last element of the vector will be moved to
/// the starting position in the vector i.e. 0th index. 
/// If it is possible to obtain the sorted vector by performing the above operation
/// then return true else return false.
/// If the given vector is empty then return true.
/// Note: The given vector is guaranteed to have unique elements.
/// For Example:
/// >>> move_one_ball(vec![3, 4, 5, 1, 2])
/// true
/// Explanation: By performin 2 right shift operations, non-decreasing order can
/// be achieved for the given vector.
/// >>> move_one_ball(vec![3, 5, 4, 1, 2])
/// false
/// Explanation:It is not possible to get non-decreasing order for the given
/// vector by performing any number of right shift operations.
fn move_one_ball(arr: Vec<isize>) -> bool {

    if arr.len() == 0 { return true; }
    let mut flag = true;
    for i in 0..arr.len() {
        let mut j = i+1;
        while j < arr.len() && arr[i] > arr[j] {
            if arr[j] > arr[j+1] && arr[j] >= arr[j-1] {
                arr.swap(i, j);
                flag = false;
                break;
            }
            j+=1;
        }
    }
    flag
}

fn main() {
    let candidate = move_one_ball;
    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);
    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);
    assert_eq!(candidate(vec![4, 3, 1, 2]), false);
    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);
    assert_eq!(candidate(Vec::<isize>::new()), true);
}

-----------------------------
/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The
/// numbers in the vector will be randomly ordered. Your task is to determine if
/// it is possible to get a vector sorted in non-decreasing order by performing 
/// the following operation on the given vector:
/// You are allowed to perform right shift operation any number of times.
/// One right shift operation means shifting all elements of the vector by one
/// position in the right direction. The last element of the vector will be moved to
/// the starting position in the vector i.e. 0th index. 
/// If it is possible to obtain the sorted vector by performing the above operation
/// then return true else return false.
/// If the given vector is empty then return true.
/// Note: The given vector is guaranteed to have unique elements.
/// For Example:
/// >>> move_one_ball(vec![3, 4, 5, 1, 2])
/// true
/// Explanation: By performin 2 right shift operations, non-decreasing order can
/// be achieved for the given vector.
/// >>> move_one_ball(vec![3, 5, 4, 1, 2])
/// false
/// Explanation:It is not possible to get non-decreasing order for the given
/// vector by performing any number of right shift operations.
fn move_one_ball(arr: Vec<isize>) -> bool {

    let mut prev_val = -1;
    let mut count = 0;
    let mut sorted = true;

    for v in arr.iter() {
        if prev_val == -1 {
            prev_val = v;
            continue;
        }

        if prev_val > v {
            sorted = false;
            break;
        }

        prev_val = v;
    }

    if sorted {
        return true;
    }

    let mut val_pos_map = HashMap::new();

    for (i, v) in arr.iter().enumerate() {
        val_pos_map.insert(*v, i);
    }

    let mut sorted = false;

    loop {
        let mut sorted_count = 0;
        let mut prev_val = -1;

        for v in arr.iter() {
            if prev_val == -1 {
                prev_val = v;
                continue;
            }

            if prev_val > v {
                let next_pos = val_pos_map.get(v).unwrap();
                let prev_pos = val_pos_map.get(prev_val).unwrap();
                arr[*next_pos] = *prev_val;
                val_pos_map.insert(*v, *next_pos);
                val_pos_map.insert(*prev_val, *prev_pos);
                prev_val = v;
                sorted_count += 1;
                count += 1;
            }
            prev_val = v;
        }

        if sorted_count == 0 {
            break;
        }
    }

    count == arr.len()
}

fn main() {
    let candidate = move_one_ball;
    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);
    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);
    assert_eq!(candidate(vec![4, 3, 1, 2]), false);
    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);
    assert_eq!(candidate(Vec::<isize>::new()), true);
}

===============================
/// In this problem, you will implement a function that takes two vectors of numbers,
/// and determines whether it is possible to perform an exchange of elements
/// between them to make lst1 a vector of only even numbers.
/// There is no limit on the number of exchanged elements between lst1 and lst2.
/// If it is possible to exchange elements between the lst1 and lst2 to make
/// all the elements of lst1 to be even, return "YES".
/// Otherwise, return "NO".
/// For example:
/// >>> exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])
/// String::from("YES")
/// >>> exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])
/// String::from("NO")
/// It is assumed that the input vectors will be non-empty.
fn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {

===============================
-----------------------------
/// In this problem, you will implement a function that takes two vectors of numbers,
/// and determines whether it is possible to perform an exchange of elements
/// between them to make lst1 a vector of only even numbers.
/// There is no limit on the number of exchanged elements between lst1 and lst2.
/// If it is possible to exchange elements between the lst1 and lst2 to make
/// all the elements of lst1 to be even, return "YES".
/// Otherwise, return "NO".
/// For example:
/// >>> exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])
/// String::from("YES")
/// >>> exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])
/// String::from("NO")
/// It is assumed that the input vectors will be non-empty.
fn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {

    let mut even_number_1 = 0;
    let mut even_number_2 = 0;
    for num in lst1 {
        if num % 2 == 0 {
            even_number_1 += 1;
        }
    }
    for num in lst2 {
        if num % 2 == 0 {
            even_number_2 += 1;
        }
    }
    if even_number_1 == lst1.len() && even_number_2 == lst2.len() {
        "YES".to_string()
    } else {
        "NO".to_string()
    }
}

fn main() {
    let candidate = exchange;
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 2, 3, 4]), String::from("YES"));
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 5, 3, 4]), String::from("NO"));
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![2, 1, 4, 3]), String::from("YES"));
    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 4]), String::from("YES"));
    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 3]), String::from("NO"));
    assert_eq!(candidate(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from("NO"));
    assert_eq!(candidate(vec![100, 200], vec![200, 200]), String::from("YES"));
}

-----------------------------
/// In this problem, you will implement a function that takes two vectors of numbers,
/// and determines whether it is possible to perform an exchange of elements
/// between them to make lst1 a vector of only even numbers.
/// There is no limit on the number of exchanged elements between lst1 and lst2.
/// If it is possible to exchange elements between the lst1 and lst2 to make
/// all the elements of lst1 to be even, return "YES".
/// Otherwise, return "NO".
/// For example:
/// >>> exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])
/// String::from("YES")
/// >>> exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])
/// String::from("NO")
/// It is assumed that the input vectors will be non-empty.
fn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {

    let mut nums = vec![];
    let mut odds = 0;
    for num in lst1.into_iter().chain(lst2) {
        nums.push(num);
        if num % 2 == 1 {
            odds += 1;
        }
    }
    if odds % 2 == 0 {
        return String::from("YES");
    }
    String::from("NO")
}

fn main() {
    let candidate = exchange;
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 2, 3, 4]), String::from("YES"));
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 5, 3, 4]), String::from("NO"));
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![2, 1, 4, 3]), String::from("YES"));
    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 4]), String::from("YES"));
    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 3]), String::from("NO"));
    assert_eq!(candidate(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from("NO"));
    assert_eq!(candidate(vec![100, 200], vec![200, 200]), String::from("YES"));
}

-----------------------------
/// In this problem, you will implement a function that takes two vectors of numbers,
/// and determines whether it is possible to perform an exchange of elements
/// between them to make lst1 a vector of only even numbers.
/// There is no limit on the number of exchanged elements between lst1 and lst2.
/// If it is possible to exchange elements between the lst1 and lst2 to make
/// all the elements of lst1 to be even, return "YES".
/// Otherwise, return "NO".
/// For example:
/// >>> exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])
/// String::from("YES")
/// >>> exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])
/// String::from("NO")
/// It is assumed that the input vectors will be non-empty.
fn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {

    let mut sum = 0;
    for i in lst1.iter() {
        sum += i;
    }
    for i in lst2.iter() {
        sum += i;
    }

    let mut num = 0;
    let mut sum_even = 0;
    for i in lst1.iter() {
        if i % 2 == 0 {
            num += 1;
            sum_even += i;
        }
    }

    if num == 0 && sum % 2 != 0 {
        return "NO".to_string();
    }

    if num == 0 && sum % 2 == 0 {
        return "YES".to_string();
    }

    if num > 0 && (sum - sum_even) % 2 != 0 {
        return "NO".to_string();
    }

    return "YES".to_string();
}

fn main() {
    let candidate = exchange;
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 2, 3, 4]), String::from("YES"));
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 5, 3, 4]), String::from("NO"));
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![2, 1, 4, 3]), String::from("YES"));
    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 4]), String::from("YES"));
    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 3]), String::from("NO"));
    assert_eq!(candidate(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from("NO"));
    assert_eq!(candidate(vec![100, 200], vec![200, 200]), String::from("YES"));
}

-----------------------------
/// In this problem, you will implement a function that takes two vectors of numbers,
/// and determines whether it is possible to perform an exchange of elements
/// between them to make lst1 a vector of only even numbers.
/// There is no limit on the number of exchanged elements between lst1 and lst2.
/// If it is possible to exchange elements between the lst1 and lst2 to make
/// all the elements of lst1 to be even, return "YES".
/// Otherwise, return "NO".
/// For example:
/// >>> exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])
/// String::from("YES")
/// >>> exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])
/// String::from("NO")
/// It is assumed that the input vectors will be non-empty.
fn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {

    for i in 0..lst1.len() {
        if !lst1[i].is_even() {
            for j in 0..lst2.len() {
                if !lst2[j].is_even() {
                    lst1.swap(i, j);
                    lst2.swap(i, j);
                    break;
                }
            }
        }
    }

    for n in lst1 {
        if !n.is_even() {
            return "NO".to_owned();
        }
    }

    "YES".to_owned()
}

fn main() {
    let candidate = exchange;
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 2, 3, 4]), String::from("YES"));
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 5, 3, 4]), String::from("NO"));
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![2, 1, 4, 3]), String::from("YES"));
    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 4]), String::from("YES"));
    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 3]), String::from("NO"));
    assert_eq!(candidate(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from("NO"));
    assert_eq!(candidate(vec![100, 200], vec![200, 200]), String::from("YES"));
}

-----------------------------
/// In this problem, you will implement a function that takes two vectors of numbers,
/// and determines whether it is possible to perform an exchange of elements
/// between them to make lst1 a vector of only even numbers.
/// There is no limit on the number of exchanged elements between lst1 and lst2.
/// If it is possible to exchange elements between the lst1 and lst2 to make
/// all the elements of lst1 to be even, return "YES".
/// Otherwise, return "NO".
/// For example:
/// >>> exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])
/// String::from("YES")
/// >>> exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])
/// String::from("NO")
/// It is assumed that the input vectors will be non-empty.
fn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {

    let mut lst1 = lst1;
    let mut lst2 = lst2;
    let mut num = 0;
    let mut flag = true;

    while flag {
        for i in 0..lst1.len() {
            if lst1[i] % 2 == 1 && lst2[i] % 2 == 0 {
                num += 1;
                if num % 2 != 0 {
                    flag = false;
                    break;
                }
            }
        }
        if flag {
            for i in 0..lst1.len() {
                if lst1[i] % 2 == 1 && lst2[i] % 2 == 0 {
                    let temp = lst1[i];
                    lst1[i] = lst2[i];
                    lst2[i] = temp;
                }
            }
        }
    }

    if flag {
        String::from("YES")
    } else {
        String::from("NO")
    }
}

fn main() {
    let candidate = exchange;
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 2, 3, 4]), String::from("YES"));
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 5, 3, 4]), String::from("NO"));
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![2, 1, 4, 3]), String::from("YES"));
    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 4]), String::from("YES"));
    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 3]), String::from("NO"));
    assert_eq!(candidate(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from("NO"));
    assert_eq!(candidate(vec![100, 200], vec![200, 200]), String::from("YES"));
}

===============================
use std::collections::HashMap;

/// Given a string representing a space separated lowercase letters, return a HashMap
/// of the letter with the most repetition and containing the corresponding count.
/// If several letters have the same occurrence, return all of them.
/// Example:
/// >>> histogram(String::from("a b c"))
/// HashMap::from([(String::from("a"), 1), (String::from("b"), 1), (String::from("c"), 1)])
/// >>> histogram(String::from("a b b a"))
/// HashMap::from([(String::from("a"), 2), (String::from("b"), 2)])
/// >>> histogram(String::from("a b c a b"))
/// HashMap::from([(String::from("a"), 2), (String::from("b"), 2)])
/// >>> histogram(String::from("b b b b a"))
/// HashMap::from([(String::from("b"), 4)])
/// >>> histogram(String::from(""))
/// HashMap::from([])
fn histogram(test: String) -> HashMap<String, isize> {

===============================
-----------------------------
use std::collections::HashMap;

/// Given a string representing a space separated lowercase letters, return a HashMap
/// of the letter with the most repetition and containing the corresponding count.
/// If several letters have the same occurrence, return all of them.
/// Example:
/// >>> histogram(String::from("a b c"))
/// HashMap::from([(String::from("a"), 1), (String::from("b"), 1), (String::from("c"), 1)])
/// >>> histogram(String::from("a b b a"))
/// HashMap::from([(String::from("a"), 2), (String::from("b"), 2)])
/// >>> histogram(String::from("a b c a b"))
/// HashMap::from([(String::from("a"), 2), (String::from("b"), 2)])
/// >>> histogram(String::from("b b b b a"))
/// HashMap::from([(String::from("b"), 4)])
/// >>> histogram(String::from(""))
/// HashMap::from([])
fn histogram(test: String) -> HashMap<String, isize> {

    let mut letters_count = HashMap::new();
    let mut word_count = 0;
    let letters: Vec<&str> = test.split(' ').collect();
    for letter in letters {
        word_count += 1;
        match letters_count.get(letter) {
            Some(n) => {
                letters_count.insert(letter.to_string(), n + 1);
            }
            None => {
                letters_count.insert(letter.to_string(), 1);
            }
        }
    }

    let mut max = 0;
    let mut max_letter: String = String::new();
    for (letter, count) in letters_count {
        if max < *count {
            max = *count;
            max_letter = letter;
        }
    }

    if max == 1 {
        if word_count == 1 {
            HashMap::from([(max_letter.clone(), 1)])
        } else {
            HashMap::from([
                (max_letter.clone(), max),
                (String::from(""), word_count - max),
            ])
        }
    } else {
        if word_count == 1 {
            HashMap::from([(max_letter.clone(), 1)])
        } else {
            HashMap::from([(String::from(""), word_count - max), (max_letter, max)])
        }
    }
}

fn main() {
    let candidate = histogram;
    assert_eq!(candidate(String::from("a b b a")), HashMap::from([(String::from("a"), 2), (String::from("b"), 2)]));
    assert_eq!(candidate(String::from("a b c a b")), HashMap::from([(String::from("a"), 2), (String::from("b"), 2)]));
    assert_eq!(candidate(String::from("a b c d g")), HashMap::from([(String::from("a"), 1), (String::from("b"), 1), (String::from("c"), 1), (String::from("d"), 1), (String::from("g"), 1)]));
    assert_eq!(candidate(String::from("r t g")), HashMap::from([(String::from("r"), 1), (String::from("t"), 1), (String::from("g"), 1)]));
    assert_eq!(candidate(String::from("b b b b a")), HashMap::from([(String::from("b"), 4)]));
    assert_eq!(candidate(String::from("r t g")), HashMap::from([(String::from("r"), 1), (String::from("t"), 1), (String::from("g"), 1)]));
    assert_eq!(candidate(String::from("")), HashMap::from([]));
    assert_eq!(candidate(String::from("a")), HashMap::from([(String::from("a"), 1)]));
}

-----------------------------
use std::collections::HashMap;

/// Given a string representing a space separated lowercase letters, return a HashMap
/// of the letter with the most repetition and containing the corresponding count.
/// If several letters have the same occurrence, return all of them.
/// Example:
/// >>> histogram(String::from("a b c"))
/// HashMap::from([(String::from("a"), 1), (String::from("b"), 1), (String::from("c"), 1)])
/// >>> histogram(String::from("a b b a"))
/// HashMap::from([(String::from("a"), 2), (String::from("b"), 2)])
/// >>> histogram(String::from("a b c a b"))
/// HashMap::from([(String::from("a"), 2), (String::from("b"), 2)])
/// >>> histogram(String::from("b b b b a"))
/// HashMap::from([(String::from("b"), 4)])
/// >>> histogram(String::from(""))
/// HashMap::from([])
fn histogram(test: String) -> HashMap<String, isize> {

    let mut hm = HashMap::new();
    let mut most_occur = 0;
    let test = test.replace(" ", "");
    for letter in test.chars() {
        if !hm.contains_key(&letter.to_string()) {
            hm.insert(letter.to_string(), 1);
            if hm.get(&letter.to_string()).unwrap() > &most_occur {
                most_occur = hm.get(&letter.to_string()).unwrap();
            }
        } else {
            *hm.get_mut(&letter.to_string()).unwrap() += 1;
            if hm.get(&letter.to_string()).unwrap() > &most_occur {
                most_occur = hm.get(&letter.to_string()).unwrap();
            }
        }
    }
    let mut answer: HashMap<String, isize> = HashMap::new();
    for (key, value) in hm {
        if value == &most_occur {
            answer.insert(key, value);
        }
    }
    answer
}

fn main() {
    let candidate = histogram;
    assert_eq!(candidate(String::from("a b b a")), HashMap::from([(String::from("a"), 2), (String::from("b"), 2)]));
    assert_eq!(candidate(String::from("a b c a b")), HashMap::from([(String::from("a"), 2), (String::from("b"), 2)]));
    assert_eq!(candidate(String::from("a b c d g")), HashMap::from([(String::from("a"), 1), (String::from("b"), 1), (String::from("c"), 1), (String::from("d"), 1), (String::from("g"), 1)]));
    assert_eq!(candidate(String::from("r t g")), HashMap::from([(String::from("r"), 1), (String::from("t"), 1), (String::from("g"), 1)]));
    assert_eq!(candidate(String::from("b b b b a")), HashMap::from([(String::from("b"), 4)]));
    assert_eq!(candidate(String::from("r t g")), HashMap::from([(String::from("r"), 1), (String::from("t"), 1), (String::from("g"), 1)]));
    assert_eq!(candidate(String::from("")), HashMap::from([]));
    assert_eq!(candidate(String::from("a")), HashMap::from([(String::from("a"), 1)]));
}

-----------------------------
use std::collections::HashMap;

/// Given a string representing a space separated lowercase letters, return a HashMap
/// of the letter with the most repetition and containing the corresponding count.
/// If several letters have the same occurrence, return all of them.
/// Example:
/// >>> histogram(String::from("a b c"))
/// HashMap::from([(String::from("a"), 1), (String::from("b"), 1), (String::from("c"), 1)])
/// >>> histogram(String::from("a b b a"))
/// HashMap::from([(String::from("a"), 2), (String::from("b"), 2)])
/// >>> histogram(String::from("a b c a b"))
/// HashMap::from([(String::from("a"), 2), (String::from("b"), 2)])
/// >>> histogram(String::from("b b b b a"))
/// HashMap::from([(String::from("b"), 4)])
/// >>> histogram(String::from(""))
/// HashMap::from([])
fn histogram(test: String) -> HashMap<String, isize> {

    let mut counts = HashMap::new();
    let words = test.split(" ");
    for word in words {
        *counts.entry(word.to_string()).or_insert(0) += 1;
    }
    counts
}

fn main() {
    let candidate = histogram;
    assert_eq!(candidate(String::from("a b b a")), HashMap::from([(String::from("a"), 2), (String::from("b"), 2)]));
    assert_eq!(candidate(String::from("a b c a b")), HashMap::from([(String::from("a"), 2), (String::from("b"), 2)]));
    assert_eq!(candidate(String::from("a b c d g")), HashMap::from([(String::from("a"), 1), (String::from("b"), 1), (String::from("c"), 1), (String::from("d"), 1), (String::from("g"), 1)]));
    assert_eq!(candidate(String::from("r t g")), HashMap::from([(String::from("r"), 1), (String::from("t"), 1), (String::from("g"), 1)]));
    assert_eq!(candidate(String::from("b b b b a")), HashMap::from([(String::from("b"), 4)]));
    assert_eq!(candidate(String::from("r t g")), HashMap::from([(String::from("r"), 1), (String::from("t"), 1), (String::from("g"), 1)]));
    assert_eq!(candidate(String::from("")), HashMap::from([]));
    assert_eq!(candidate(String::from("a")), HashMap::from([(String::from("a"), 1)]));
}

-----------------------------
use std::collections::HashMap;

/// Given a string representing a space separated lowercase letters, return a HashMap
/// of the letter with the most repetition and containing the corresponding count.
/// If several letters have the same occurrence, return all of them.
/// Example:
/// >>> histogram(String::from("a b c"))
/// HashMap::from([(String::from("a"), 1), (String::from("b"), 1), (String::from("c"), 1)])
/// >>> histogram(String::from("a b b a"))
/// HashMap::from([(String::from("a"), 2), (String::from("b"), 2)])
/// >>> histogram(String::from("a b c a b"))
/// HashMap::from([(String::from("a"), 2), (String::from("b"), 2)])
/// >>> histogram(String::from("b b b b a"))
/// HashMap::from([(String::from("b"), 4)])
/// >>> histogram(String::from(""))
/// HashMap::from([])
fn histogram(test: String) -> HashMap<String, isize> {

    let mut char_map: HashMap<String, isize> = HashMap::new();

    for character in test.split_whitespace() {
        let entry = char_map.entry(character.to_string()).or_insert(0);
        *entry += 1;
    }

    char_map
}

fn main() {
    let candidate = histogram;
    assert_eq!(candidate(String::from("a b b a")), HashMap::from([(String::from("a"), 2), (String::from("b"), 2)]));
    assert_eq!(candidate(String::from("a b c a b")), HashMap::from([(String::from("a"), 2), (String::from("b"), 2)]));
    assert_eq!(candidate(String::from("a b c d g")), HashMap::from([(String::from("a"), 1), (String::from("b"), 1), (String::from("c"), 1), (String::from("d"), 1), (String::from("g"), 1)]));
    assert_eq!(candidate(String::from("r t g")), HashMap::from([(String::from("r"), 1), (String::from("t"), 1), (String::from("g"), 1)]));
    assert_eq!(candidate(String::from("b b b b a")), HashMap::from([(String::from("b"), 4)]));
    assert_eq!(candidate(String::from("r t g")), HashMap::from([(String::from("r"), 1), (String::from("t"), 1), (String::from("g"), 1)]));
    assert_eq!(candidate(String::from("")), HashMap::from([]));
    assert_eq!(candidate(String::from("a")), HashMap::from([(String::from("a"), 1)]));
}

-----------------------------
use std::collections::HashMap;

/// Given a string representing a space separated lowercase letters, return a HashMap
/// of the letter with the most repetition and containing the corresponding count.
/// If several letters have the same occurrence, return all of them.
/// Example:
/// >>> histogram(String::from("a b c"))
/// HashMap::from([(String::from("a"), 1), (String::from("b"), 1), (String::from("c"), 1)])
/// >>> histogram(String::from("a b b a"))
/// HashMap::from([(String::from("a"), 2), (String::from("b"), 2)])
/// >>> histogram(String::from("a b c a b"))
/// HashMap::from([(String::from("a"), 2), (String::from("b"), 2)])
/// >>> histogram(String::from("b b b b a"))
/// HashMap::from([(String::from("b"), 4)])
/// >>> histogram(String::from(""))
/// HashMap::from([])
fn histogram(test: String) -> HashMap<String, isize> {

    let mut res: HashMap<String, isize> = HashMap::new();
    let mut words = test.trim().split(" ");
    let mut word = words.next();
    let mut max_count = 0;
    while word != None {
        let w = word.unwrap();
        let mut count: isize = 1;
        let mut word_count = words.clone();
        while word_count.next() == Some(w) {
            count += 1;
        }
        if res.contains_key(w) {
            if count > max_count {
                max_count = count;
                res.clear();
            } else if count == max_count {
                res.insert(w.to_string(), count);
            }
        } else if count > max_count {
            res.clear();
            max_count = count;
            res.insert(w.to_string(), count);
        }
        word = words.next();
    }
    res
}

fn main() {
    let candidate = histogram;
    assert_eq!(candidate(String::from("a b b a")), HashMap::from([(String::from("a"), 2), (String::from("b"), 2)]));
    assert_eq!(candidate(String::from("a b c a b")), HashMap::from([(String::from("a"), 2), (String::from("b"), 2)]));
    assert_eq!(candidate(String::from("a b c d g")), HashMap::from([(String::from("a"), 1), (String::from("b"), 1), (String::from("c"), 1), (String::from("d"), 1), (String::from("g"), 1)]));
    assert_eq!(candidate(String::from("r t g")), HashMap::from([(String::from("r"), 1), (String::from("t"), 1), (String::from("g"), 1)]));
    assert_eq!(candidate(String::from("b b b b a")), HashMap::from([(String::from("b"), 4)]));
    assert_eq!(candidate(String::from("r t g")), HashMap::from([(String::from("r"), 1), (String::from("t"), 1), (String::from("g"), 1)]));
    assert_eq!(candidate(String::from("")), HashMap::from([]));
    assert_eq!(candidate(String::from("a")), HashMap::from([(String::from("a"), 1)]));
}

===============================
/// Task
/// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c
/// then check if the result string is palindrome.
/// A string is called palindrome if it reads the same backward as forward.
/// You should return a tuple containing the result string and true/false for the check.
/// Example
/// >>> reverse_delete(String::from("abcde"), String::from("ae"))
/// (String::from("bcd"), false)
/// >>> reverse_delete(String::from("abcdef"), String::from("b"))
/// (String::from("acdef"), false)
/// >>> reverse_delete(String::from("abcdedcba"), String::from("ab"))
/// (String::from("cdedc"), true)
fn reverse_delete(s: String, c: String) -> (String, bool) {

===============================
-----------------------------
/// Task
/// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c
/// then check if the result string is palindrome.
/// A string is called palindrome if it reads the same backward as forward.
/// You should return a tuple containing the result string and true/false for the check.
/// Example
/// >>> reverse_delete(String::from("abcde"), String::from("ae"))
/// (String::from("bcd"), false)
/// >>> reverse_delete(String::from("abcdef"), String::from("b"))
/// (String::from("acdef"), false)
/// >>> reverse_delete(String::from("abcdedcba"), String::from("ab"))
/// (String::from("cdedc"), true)
fn reverse_delete(s: String, c: String) -> (String, bool) {

    let mut s_vec = s.chars().collect::<Vec<char>>();
    let mut c_vec = c.chars().collect::<Vec<char>>();
    let mut count = 0;
    let mut result = String::new();

    let mut s_len = s_vec.len();
    let mut c_len = c_vec.len();

    if s_len == 0 && c_len == 0 {
        return (String::from(""), true);
    }

    if s_len == 0 {
        return (String::from(""), false);
    }

    if c_len == 0 {
        return (String::from(s), true);
    }

    loop {
        if count < s_len {
            for i in 0..c_len {
                if s_vec[count] == c_vec[i] {
                    s_vec.remove(count);
                    s_len -= 1;
                    break;
                }
            }
            count += 1;
            if count == s_len {
                break;
            }
        } else {
            break;
        }
    }

    if s_len == 0 {
        return (String::from(""), true);
    }

    for i in 0..s_len {
        result.push(s_vec[i]);
    }

    let result_string = result.as_str();

    let result_string_len = result_string.chars().count();
    let result_string_char = result_string.chars().collect::<Vec<char>>();
    let mut result_char_vec = result_string_char.clone();

    let mut i = 0;

    while i < result_string_len {
        let reverse_index = result_string_len - i - 1;
        if result_char_vec[i] != result_char_vec[reverse_index] {
            result_char_vec.remove(i);
            result_string_char.remove(i);
            result_string_char.remove(reverse_index);
            result_string_len -= 2;
            i = 0;
        } else {
            i += 1;
        }
    }

    let mut result_string_final = String::new();

    for i in 0..result_string_char.len() {
        result_string_final.push(result_string_char[i]);
    }

    (result_string_final, false)
}

fn main() {
    let candidate = reverse_delete;
    assert_eq!(candidate(String::from("abcde"), String::from("ae")), (String::from("bcd"), false));
    assert_eq!(candidate(String::from("abcdef"), String::from("b")), (String::from("acdef"), false));
    assert_eq!(candidate(String::from("abcdedcba"), String::from("ab")), (String::from("cdedc"), true));
    assert_eq!(candidate(String::from("dwik"), String::from("w")), (String::from("dik"), false));
    assert_eq!(candidate(String::from("a"), String::from("a")), (String::from(""), true));
    assert_eq!(candidate(String::from("abcdedcba"), String::from("")), (String::from("abcdedcba"), true));
    assert_eq!(candidate(String::from("abcdedcba"), String::from("v")), (String::from("abcdedcba"), true));
    assert_eq!(candidate(String::from("vabba"), String::from("v")), (String::from("abba"), true));
    assert_eq!(candidate(String::from("mamma"), String::from("mia")), (String::from(""), true));
}

-----------------------------
/// Task
/// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c
/// then check if the result string is palindrome.
/// A string is called palindrome if it reads the same backward as forward.
/// You should return a tuple containing the result string and true/false for the check.
/// Example
/// >>> reverse_delete(String::from("abcde"), String::from("ae"))
/// (String::from("bcd"), false)
/// >>> reverse_delete(String::from("abcdef"), String::from("b"))
/// (String::from("acdef"), false)
/// >>> reverse_delete(String::from("abcdedcba"), String::from("ab"))
/// (String::from("cdedc"), true)
fn reverse_delete(s: String, c: String) -> (String, bool) {

    let mut char_count = [0; 128];
    let s = s.chars().collect::<Vec<char>>();
    for c in &s {
        char_count[c as usize] += 1;
    }
    let mut i = 0;
    let mut j = s.len() - 1;
    let mut result = String::from("");
    while i <= j {
        if char_count[s[i] as usize] > 0 {
            char_count[s[i] as usize] -= 1;
            for cc in &c {
                if s[i] == *cc {
                    i += 1;
                    break;
                }
            }
        } else {
            result.push(s[i]);
            i += 1;
        }
    }
    if result.len() == 0 {
        (result, true)
    } else {
        let mut is_palindrome = true;
        let result = result.chars().rev().collect::<String>();
        for i in 0..result.len() / 2 {
            if result[i] != result[result.len() - 1 - i] {
                is_palindrome = false;
                break;
            }
        }
        (result, is_palindrome)
    }
}

fn main() {
    let candidate = reverse_delete;
    assert_eq!(candidate(String::from("abcde"), String::from("ae")), (String::from("bcd"), false));
    assert_eq!(candidate(String::from("abcdef"), String::from("b")), (String::from("acdef"), false));
    assert_eq!(candidate(String::from("abcdedcba"), String::from("ab")), (String::from("cdedc"), true));
    assert_eq!(candidate(String::from("dwik"), String::from("w")), (String::from("dik"), false));
    assert_eq!(candidate(String::from("a"), String::from("a")), (String::from(""), true));
    assert_eq!(candidate(String::from("abcdedcba"), String::from("")), (String::from("abcdedcba"), true));
    assert_eq!(candidate(String::from("abcdedcba"), String::from("v")), (String::from("abcdedcba"), true));
    assert_eq!(candidate(String::from("vabba"), String::from("v")), (String::from("abba"), true));
    assert_eq!(candidate(String::from("mamma"), String::from("mia")), (String::from(""), true));
}

-----------------------------
/// Task
/// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c
/// then check if the result string is palindrome.
/// A string is called palindrome if it reads the same backward as forward.
/// You should return a tuple containing the result string and true/false for the check.
/// Example
/// >>> reverse_delete(String::from("abcde"), String::from("ae"))
/// (String::from("bcd"), false)
/// >>> reverse_delete(String::from("abcdef"), String::from("b"))
/// (String::from("acdef"), false)
/// >>> reverse_delete(String::from("abcdedcba"), String::from("ab"))
/// (String::from("cdedc"), true)
fn reverse_delete(s: String, c: String) -> (String, bool) {

    let mut res = "".to_string();
    for i in s.chars() {
        if c.contains(i) {
            continue;
        }
        res.push(i);
    }
    let result = is_palindrome(res.as_str());
    (res, result)
}

fn main() {
    let candidate = reverse_delete;
    assert_eq!(candidate(String::from("abcde"), String::from("ae")), (String::from("bcd"), false));
    assert_eq!(candidate(String::from("abcdef"), String::from("b")), (String::from("acdef"), false));
    assert_eq!(candidate(String::from("abcdedcba"), String::from("ab")), (String::from("cdedc"), true));
    assert_eq!(candidate(String::from("dwik"), String::from("w")), (String::from("dik"), false));
    assert_eq!(candidate(String::from("a"), String::from("a")), (String::from(""), true));
    assert_eq!(candidate(String::from("abcdedcba"), String::from("")), (String::from("abcdedcba"), true));
    assert_eq!(candidate(String::from("abcdedcba"), String::from("v")), (String::from("abcdedcba"), true));
    assert_eq!(candidate(String::from("vabba"), String::from("v")), (String::from("abba"), true));
    assert_eq!(candidate(String::from("mamma"), String::from("mia")), (String::from(""), true));
}

-----------------------------
/// Task
/// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c
/// then check if the result string is palindrome.
/// A string is called palindrome if it reads the same backward as forward.
/// You should return a tuple containing the result string and true/false for the check.
/// Example
/// >>> reverse_delete(String::from("abcde"), String::from("ae"))
/// (String::from("bcd"), false)
/// >>> reverse_delete(String::from("abcdef"), String::from("b"))
/// (String::from("acdef"), false)
/// >>> reverse_delete(String::from("abcdedcba"), String::from("ab"))
/// (String::from("cdedc"), true)
fn reverse_delete(s: String, c: String) -> (String, bool) {

    let mut result = String::new();

    let mut s_iter = s.chars();
    let mut c_iter = c.chars();

    while let (Some(s_val), Some(c_val)) = (s_iter.next(), c_iter.next()) {
        if s_val != c_val {
            result.push(s_val);
        }
    }

    let mut result_iter = result.chars();

    let mut result_str = String::new();

    while let Some(c_val) = result_iter.next() {
        if let Some(n) = result_iter.next() {
            if c_val != n {
                result_str.push(c_val);
            }
        } else {
            result_str.push(c_val);
        }
    }

    (result_str, is_palindrome(&result_str))
}

fn main() {
    let candidate = reverse_delete;
    assert_eq!(candidate(String::from("abcde"), String::from("ae")), (String::from("bcd"), false));
    assert_eq!(candidate(String::from("abcdef"), String::from("b")), (String::from("acdef"), false));
    assert_eq!(candidate(String::from("abcdedcba"), String::from("ab")), (String::from("cdedc"), true));
    assert_eq!(candidate(String::from("dwik"), String::from("w")), (String::from("dik"), false));
    assert_eq!(candidate(String::from("a"), String::from("a")), (String::from(""), true));
    assert_eq!(candidate(String::from("abcdedcba"), String::from("")), (String::from("abcdedcba"), true));
    assert_eq!(candidate(String::from("abcdedcba"), String::from("v")), (String::from("abcdedcba"), true));
    assert_eq!(candidate(String::from("vabba"), String::from("v")), (String::from("abba"), true));
    assert_eq!(candidate(String::from("mamma"), String::from("mia")), (String::from(""), true));
}

-----------------------------
/// Task
/// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c
/// then check if the result string is palindrome.
/// A string is called palindrome if it reads the same backward as forward.
/// You should return a tuple containing the result string and true/false for the check.
/// Example
/// >>> reverse_delete(String::from("abcde"), String::from("ae"))
/// (String::from("bcd"), false)
/// >>> reverse_delete(String::from("abcdef"), String::from("b"))
/// (String::from("acdef"), false)
/// >>> reverse_delete(String::from("abcdedcba"), String::from("ab"))
/// (String::from("cdedc"), true)
fn reverse_delete(s: String, c: String) -> (String, bool) {

    let mut result: String = String::from("");
    let mut is_palindrome: bool = true;

    for i in s.chars() {
        if !c.contains(i) {
            result.push(i);
        } else {
            is_palindrome = false;
        }
    }

    (result, is_palindrome)
}

fn main() {
    let candidate = reverse_delete;
    assert_eq!(candidate(String::from("abcde"), String::from("ae")), (String::from("bcd"), false));
    assert_eq!(candidate(String::from("abcdef"), String::from("b")), (String::from("acdef"), false));
    assert_eq!(candidate(String::from("abcdedcba"), String::from("ab")), (String::from("cdedc"), true));
    assert_eq!(candidate(String::from("dwik"), String::from("w")), (String::from("dik"), false));
    assert_eq!(candidate(String::from("a"), String::from("a")), (String::from(""), true));
    assert_eq!(candidate(String::from("abcdedcba"), String::from("")), (String::from("abcdedcba"), true));
    assert_eq!(candidate(String::from("abcdedcba"), String::from("v")), (String::from("abcdedcba"), true));
    assert_eq!(candidate(String::from("vabba"), String::from("v")), (String::from("abba"), true));
    assert_eq!(candidate(String::from("mamma"), String::from("mia")), (String::from(""), true));
}

===============================
/// Given a vector of strings, where each string consists of only digits, return a vector.
/// Each element i of the output should be "the number of odd elements in the
/// string i of the input." where all the i's should be replaced by the number
/// of odd digits in the i'th string of the input.
/// >>> odd_count(vec![String::from("1234567")])
/// vec![String::from("the number of odd elements 4n the str4ng 4 of the 4nput.")]
/// >>> odd_count(vec![String::from("3"), String::from("11111111")])
/// vec![String::from("the number of odd elements 1n the str1ng 1 of the 1nput."), String::from("the number of odd elements 8n the str8ng 8 of the 8nput.")]
fn odd_count(lst: Vec<String>) -> Vec<String> {

===============================
-----------------------------
/// Given a vector of strings, where each string consists of only digits, return a vector.
/// Each element i of the output should be "the number of odd elements in the
/// string i of the input." where all the i's should be replaced by the number
/// of odd digits in the i'th string of the input.
/// >>> odd_count(vec![String::from("1234567")])
/// vec![String::from("the number of odd elements 4n the str4ng 4 of the 4nput.")]
/// >>> odd_count(vec![String::from("3"), String::from("11111111")])
/// vec![String::from("the number of odd elements 1n the str1ng 1 of the 1nput."), String::from("the number of odd elements 8n the str8ng 8 of the 8nput.")]
fn odd_count(lst: Vec<String>) -> Vec<String> {

    let mut res = vec![];
    for s in lst {
        let mut cnt = 0;
        for c in s.chars() {
            if c.to_digit(10).unwrap() % 2 == 1 {
                cnt += 1;
            }
        }
        res.push(format!("the number of odd elements {}n the str{}ng {} of the {}nput.", cnt, cnt, s, cnt));
    }
    res
}

fn main() {
    let candidate = odd_count;
    assert_eq!(candidate(vec![String::from("1234567")]), vec![String::from("the number of odd elements 4n the str4ng 4 of the 4nput.")]);
    assert_eq!(candidate(vec![String::from("3"), String::from("11111111")]), vec![String::from("the number of odd elements 1n the str1ng 1 of the 1nput."), String::from("the number of odd elements 8n the str8ng 8 of the 8nput.")]);
    assert_eq!(candidate(vec![String::from("271"), String::from("137"), String::from("314")]), vec![String::from("the number of odd elements 2n the str2ng 2 of the 2nput."), String::from("the number of odd elements 3n the str3ng 3 of the 3nput."), String::from("the number of odd elements 2n the str2ng 2 of the 2nput.")]);
}

-----------------------------
/// Given a vector of strings, where each string consists of only digits, return a vector.
/// Each element i of the output should be "the number of odd elements in the
/// string i of the input." where all the i's should be replaced by the number
/// of odd digits in the i'th string of the input.
/// >>> odd_count(vec![String::from("1234567")])
/// vec![String::from("the number of odd elements 4n the str4ng 4 of the 4nput.")]
/// >>> odd_count(vec![String::from("3"), String::from("11111111")])
/// vec![String::from("the number of odd elements 1n the str1ng 1 of the 1nput."), String::from("the number of odd elements 8n the str8ng 8 of the 8nput.")]
fn odd_count(lst: Vec<String>) -> Vec<String> {

    lst.iter()
        .map(|x| x.chars().filter(|c| c.is_digit(10)).count() % 2)
        .map(|x| {
            if x == 0 {
                String::from("the number of odd elements 0n the str0ng 0 of the 0nput.")
            } else if x == 1 {
                String::from("the number of odd elements 1n the str1ng 1 of the 1nput.")
            } else if x == 2 {
                String::from("the number of odd elements 2n the str2ng 2 of the 2nput.")
            } else if x == 3 {
                String::from("the number of odd elements 3n the str3ng 3 of the 3nput.")
            } else if x == 4 {
                String::from("the number of odd elements 4n the str4ng 4 of the 4nput.")
            } else if x == 5 {
                String::from("the number of odd elements 5n the str5ng 5 of the 5nput.")
            } else if x == 6 {
                String::from("the number of odd elements 6n the str6ng 6 of the 6nput.")
            } else if x == 7 {
                String::from("the number of odd elements 7n the str7ng 7 of the 7nput.")
            } else if x == 8 {
                String::from("the number of odd elements 8n the str8ng 8 of the 8nput.")
            } else if x == 9 {
                String::from("the number of odd elements 9n the str9ng 9 of the 9nput.")
            } else {
                String::from("the number of odd elements 1n the str1ng 1 of the 1nput.")
            }
        })
        .collect()
}

fn main() {
    let candidate = odd_count;
    assert_eq!(candidate(vec![String::from("1234567")]), vec![String::from("the number of odd elements 4n the str4ng 4 of the 4nput.")]);
    assert_eq!(candidate(vec![String::from("3"), String::from("11111111")]), vec![String::from("the number of odd elements 1n the str1ng 1 of the 1nput."), String::from("the number of odd elements 8n the str8ng 8 of the 8nput.")]);
    assert_eq!(candidate(vec![String::from("271"), String::from("137"), String::from("314")]), vec![String::from("the number of odd elements 2n the str2ng 2 of the 2nput."), String::from("the number of odd elements 3n the str3ng 3 of the 3nput."), String::from("the number of odd elements 2n the str2ng 2 of the 2nput.")]);
}

-----------------------------
/// Given a vector of strings, where each string consists of only digits, return a vector.
/// Each element i of the output should be "the number of odd elements in the
/// string i of the input." where all the i's should be replaced by the number
/// of odd digits in the i'th string of the input.
/// >>> odd_count(vec![String::from("1234567")])
/// vec![String::from("the number of odd elements 4n the str4ng 4 of the 4nput.")]
/// >>> odd_count(vec![String::from("3"), String::from("11111111")])
/// vec![String::from("the number of odd elements 1n the str1ng 1 of the 1nput."), String::from("the number of odd elements 8n the str8ng 8 of the 8nput.")]
fn odd_count(lst: Vec<String>) -> Vec<String> {

    unimplemented!()
}

fn main() {
    let candidate = odd_count;
    assert_eq!(candidate(vec![String::from("1234567")]), vec![String::from("the number of odd elements 4n the str4ng 4 of the 4nput.")]);
    assert_eq!(candidate(vec![String::from("3"), String::from("11111111")]), vec![String::from("the number of odd elements 1n the str1ng 1 of the 1nput."), String::from("the number of odd elements 8n the str8ng 8 of the 8nput.")]);
    assert_eq!(candidate(vec![String::from("271"), String::from("137"), String::from("314")]), vec![String::from("the number of odd elements 2n the str2ng 2 of the 2nput."), String::from("the number of odd elements 3n the str3ng 3 of the 3nput."), String::from("the number of odd elements 2n the str2ng 2 of the 2nput.")]);
}

-----------------------------
/// Given a vector of strings, where each string consists of only digits, return a vector.
/// Each element i of the output should be "the number of odd elements in the
/// string i of the input." where all the i's should be replaced by the number
/// of odd digits in the i'th string of the input.
/// >>> odd_count(vec![String::from("1234567")])
/// vec![String::from("the number of odd elements 4n the str4ng 4 of the 4nput.")]
/// >>> odd_count(vec![String::from("3"), String::from("11111111")])
/// vec![String::from("the number of odd elements 1n the str1ng 1 of the 1nput."), String::from("the number of odd elements 8n the str8ng 8 of the 8nput.")]
fn odd_count(lst: Vec<String>) -> Vec<String> {

    // Create a vector of strings.
    let mut vec_string = Vec::new();
    // Iterate through each string.
    for i in lst {
        // Initialize a count variable.
        let mut count = 0;
        // Iterate through each character of the string.
        for j in i.chars() {
            // If character is odd, increment the count.
            if j % 2 != 0 {
                count += 1;
            }
        }
        // Create a string.
        let mut string = String::new();
        // Convert count to string.
        string.push_str(&count.to_string());
        // Push the string to the vector of strings.
        vec_string.push(string);
    }
    // Return the vector of strings.
    vec_string
}

fn main() {
    let candidate = odd_count;
    assert_eq!(candidate(vec![String::from("1234567")]), vec![String::from("the number of odd elements 4n the str4ng 4 of the 4nput.")]);
    assert_eq!(candidate(vec![String::from("3"), String::from("11111111")]), vec![String::from("the number of odd elements 1n the str1ng 1 of the 1nput."), String::from("the number of odd elements 8n the str8ng 8 of the 8nput.")]);
    assert_eq!(candidate(vec![String::from("271"), String::from("137"), String::from("314")]), vec![String::from("the number of odd elements 2n the str2ng 2 of the 2nput."), String::from("the number of odd elements 3n the str3ng 3 of the 3nput."), String::from("the number of odd elements 2n the str2ng 2 of the 2nput.")]);
}

-----------------------------
/// Given a vector of strings, where each string consists of only digits, return a vector.
/// Each element i of the output should be "the number of odd elements in the
/// string i of the input." where all the i's should be replaced by the number
/// of odd digits in the i'th string of the input.
/// >>> odd_count(vec![String::from("1234567")])
/// vec![String::from("the number of odd elements 4n the str4ng 4 of the 4nput.")]
/// >>> odd_count(vec![String::from("3"), String::from("11111111")])
/// vec![String::from("the number of odd elements 1n the str1ng 1 of the 1nput."), String::from("the number of odd elements 8n the str8ng 8 of the 8nput.")]
fn odd_count(lst: Vec<String>) -> Vec<String> {

    let odd = |n: &str| n.chars().filter(|c| *c != '0').count();
    lst.into_iter().map(|s| format!("the number of odd elements {}n the str{}ng {} of the {}nput.", odd(&s), odd(&s), odd(&s), odd(&s))).collect()
}

fn main() {
    let candidate = odd_count;
    assert_eq!(candidate(vec![String::from("1234567")]), vec![String::from("the number of odd elements 4n the str4ng 4 of the 4nput.")]);
    assert_eq!(candidate(vec![String::from("3"), String::from("11111111")]), vec![String::from("the number of odd elements 1n the str1ng 1 of the 1nput."), String::from("the number of odd elements 8n the str8ng 8 of the 8nput.")]);
    assert_eq!(candidate(vec![String::from("271"), String::from("137"), String::from("314")]), vec![String::from("the number of odd elements 2n the str2ng 2 of the 2nput."), String::from("the number of odd elements 3n the str3ng 3 of the 3nput."), String::from("the number of odd elements 2n the str2ng 2 of the 2nput.")]);
}

===============================
/// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector
/// of nums.
/// Example
/// >>> minSubArraySum(vec![2, 3, 4, 1, 2, 4])
/// 1
/// >>> minSubArraySum(vec![-1, -2, -3])
/// -6
fn minSubArraySum(nums: Vec<isize>) -> isize {

===============================
-----------------------------
/// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector
/// of nums.
/// Example
/// >>> minSubArraySum(vec![2, 3, 4, 1, 2, 4])
/// 1
/// >>> minSubArraySum(vec![-1, -2, -3])
/// -6
fn minSubArraySum(nums: Vec<isize>) -> isize {

    if nums.is_empty() {
        return 0;
    }
    let mut sum = 0;
    let mut min_sum = std::isize::MAX;
    let mut left = 0;
    let mut right = 0;
    while left < nums.len() {
        sum += nums[right];
        if sum < min_sum {
            min_sum = sum;
        }
        if right + 1 < nums.len() {
            right += 1;
        } else {
            left += 1;
            right = left;
            sum = 0;
        }
    }
    min_sum
}

fn main() {
    let candidate = minSubArraySum;
    assert_eq!(candidate(vec![2, 3, 4, 1, 2, 4]), 1);
    assert_eq!(candidate(vec![-1, -2, -3]), -6);
    assert_eq!(candidate(vec![-1, -2, -3, 2, -10]), -14);
    assert_eq!(candidate(vec![-9999999999999999]), -9999999999999999);
    assert_eq!(candidate(vec![0, 10, 20, 1000000]), 0);
    assert_eq!(candidate(vec![-1, -2, -3, 10, -5]), -6);
    assert_eq!(candidate(vec![100, -1, -2, -3, 10, -5]), -6);
    assert_eq!(candidate(vec![10, 11, 13, 8, 3, 4]), 3);
    assert_eq!(candidate(vec![100, -33, 32, -1, 0, -2]), -33);
    assert_eq!(candidate(vec![-10]), -10);
    assert_eq!(candidate(vec![7]), 7);
    assert_eq!(candidate(vec![1, -1]), -1);
}

-----------------------------
/// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector
/// of nums.
/// Example
/// >>> minSubArraySum(vec![2, 3, 4, 1, 2, 4])
/// 1
/// >>> minSubArraySum(vec![-1, -2, -3])
/// -6
fn minSubArraySum(nums: Vec<isize>) -> isize {

    let mut min_sum = std::isize::MAX;

    let mut sum: isize = 0;
    for i in 0..nums.len() {
        sum += nums[i];
        if sum < min_sum {
            min_sum = sum;
        }
        if sum > 0 {
            sum = 0;
        }
    }
    min_sum
}

fn main() {
    let candidate = minSubArraySum;
    assert_eq!(candidate(vec![2, 3, 4, 1, 2, 4]), 1);
    assert_eq!(candidate(vec![-1, -2, -3]), -6);
    assert_eq!(candidate(vec![-1, -2, -3, 2, -10]), -14);
    assert_eq!(candidate(vec![-9999999999999999]), -9999999999999999);
    assert_eq!(candidate(vec![0, 10, 20, 1000000]), 0);
    assert_eq!(candidate(vec![-1, -2, -3, 10, -5]), -6);
    assert_eq!(candidate(vec![100, -1, -2, -3, 10, -5]), -6);
    assert_eq!(candidate(vec![10, 11, 13, 8, 3, 4]), 3);
    assert_eq!(candidate(vec![100, -33, 32, -1, 0, -2]), -33);
    assert_eq!(candidate(vec![-10]), -10);
    assert_eq!(candidate(vec![7]), 7);
    assert_eq!(candidate(vec![1, -1]), -1);
}

-----------------------------
/// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector
/// of nums.
/// Example
/// >>> minSubArraySum(vec![2, 3, 4, 1, 2, 4])
/// 1
/// >>> minSubArraySum(vec![-1, -2, -3])
/// -6
fn minSubArraySum(nums: Vec<isize>) -> isize {

    let mut min = isize::MAX;
    let mut sum = 0;
    for num in nums {
        sum += num;
        min = min.min(sum);
        if sum < 0 {
            sum = 0;
        }
    }
    min
}

fn main() {
    let candidate = minSubArraySum;
    assert_eq!(candidate(vec![2, 3, 4, 1, 2, 4]), 1);
    assert_eq!(candidate(vec![-1, -2, -3]), -6);
    assert_eq!(candidate(vec![-1, -2, -3, 2, -10]), -14);
    assert_eq!(candidate(vec![-9999999999999999]), -9999999999999999);
    assert_eq!(candidate(vec![0, 10, 20, 1000000]), 0);
    assert_eq!(candidate(vec![-1, -2, -3, 10, -5]), -6);
    assert_eq!(candidate(vec![100, -1, -2, -3, 10, -5]), -6);
    assert_eq!(candidate(vec![10, 11, 13, 8, 3, 4]), 3);
    assert_eq!(candidate(vec![100, -33, 32, -1, 0, -2]), -33);
    assert_eq!(candidate(vec![-10]), -10);
    assert_eq!(candidate(vec![7]), 7);
    assert_eq!(candidate(vec![1, -1]), -1);
}

-----------------------------
/// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector
/// of nums.
/// Example
/// >>> minSubArraySum(vec![2, 3, 4, 1, 2, 4])
/// 1
/// >>> minSubArraySum(vec![-1, -2, -3])
/// -6
fn minSubArraySum(nums: Vec<isize>) -> isize {

    if nums.len() == 1 {
        return nums[0];
    }

    let mut sum = nums[0];
    let mut min = sum;
    for i in 1..nums.len() {
        sum += nums[i];
        min = min.min(sum - nums[i - 1]);
    }

    min
}

fn main() {
    let candidate = minSubArraySum;
    assert_eq!(candidate(vec![2, 3, 4, 1, 2, 4]), 1);
    assert_eq!(candidate(vec![-1, -2, -3]), -6);
    assert_eq!(candidate(vec![-1, -2, -3, 2, -10]), -14);
    assert_eq!(candidate(vec![-9999999999999999]), -9999999999999999);
    assert_eq!(candidate(vec![0, 10, 20, 1000000]), 0);
    assert_eq!(candidate(vec![-1, -2, -3, 10, -5]), -6);
    assert_eq!(candidate(vec![100, -1, -2, -3, 10, -5]), -6);
    assert_eq!(candidate(vec![10, 11, 13, 8, 3, 4]), 3);
    assert_eq!(candidate(vec![100, -33, 32, -1, 0, -2]), -33);
    assert_eq!(candidate(vec![-10]), -10);
    assert_eq!(candidate(vec![7]), 7);
    assert_eq!(candidate(vec![1, -1]), -1);
}

-----------------------------
/// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector
/// of nums.
/// Example
/// >>> minSubArraySum(vec![2, 3, 4, 1, 2, 4])
/// 1
/// >>> minSubArraySum(vec![-1, -2, -3])
/// -6
fn minSubArraySum(nums: Vec<isize>) -> isize {

    let mut sub_array = vec![];
    let mut total = 0;

    for num in nums {
        sub_array.push(num);
        total += num;

        if sub_array.len() > 1 && total < 0 {
            sub_array.drain(0..sub_array.len() - 1);
            total = 0;
        }

        if total < 0 {
            continue;
        }

        if sub_array.len() == 1 {
            return total;
        }

        if sub_array.iter().sum::<isize>() < 0 {
            continue;
        }

        let mut current_sum = sub_array.iter().sum::<isize>();
        while current_sum > total {
            current_sum -= sub_array.remove(0);
        }
        total = current_sum;
    }
    total
}

fn main() {
    let candidate = minSubArraySum;
    assert_eq!(candidate(vec![2, 3, 4, 1, 2, 4]), 1);
    assert_eq!(candidate(vec![-1, -2, -3]), -6);
    assert_eq!(candidate(vec![-1, -2, -3, 2, -10]), -14);
    assert_eq!(candidate(vec![-9999999999999999]), -9999999999999999);
    assert_eq!(candidate(vec![0, 10, 20, 1000000]), 0);
    assert_eq!(candidate(vec![-1, -2, -3, 10, -5]), -6);
    assert_eq!(candidate(vec![100, -1, -2, -3, 10, -5]), -6);
    assert_eq!(candidate(vec![10, 11, 13, 8, 3, 4]), 3);
    assert_eq!(candidate(vec![100, -33, 32, -1, 0, -2]), -33);
    assert_eq!(candidate(vec![-10]), -10);
    assert_eq!(candidate(vec![7]), 7);
    assert_eq!(candidate(vec![1, -1]), -1);
}

===============================
/// You are given a rectangular grid of wells. Each row represents a single well,
/// and each 1 in a row represents a single unit of water.
/// Each well has a corresponding bucket that can be used to extract water from it, 
/// and all buckets have the same capacity.
/// Your task is to use the buckets to empty the wells.
/// Output the number of times you need to lower the buckets.
/// Example 1:
/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)
/// 6
/// Example 2:
/// >>> max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)
/// 5
/// Example 3:
/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)
/// 0
/// Constraints:
/// * all wells have the same length
/// * 1 <= grid.length <= 10^2
/// * 1 <= grid[:,1].length <= 10^2
/// * grid[i][j] -> 0 | 1
/// * 1 <= capacity <= 10
fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {

===============================
-----------------------------
/// You are given a rectangular grid of wells. Each row represents a single well,
/// and each 1 in a row represents a single unit of water.
/// Each well has a corresponding bucket that can be used to extract water from it, 
/// and all buckets have the same capacity.
/// Your task is to use the buckets to empty the wells.
/// Output the number of times you need to lower the buckets.
/// Example 1:
/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)
/// 6
/// Example 2:
/// >>> max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)
/// 5
/// Example 3:
/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)
/// 0
/// Constraints:
/// * all wells have the same length
/// * 1 <= grid.length <= 10^2
/// * 1 <= grid[:,1].length <= 10^2
/// * grid[i][j] -> 0 | 1
/// * 1 <= capacity <= 10
fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {

    todo!()
}

fn main() {
    let candidate = max_fill;
    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);
    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);
    assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);
    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);
    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);
}

-----------------------------
/// You are given a rectangular grid of wells. Each row represents a single well,
/// and each 1 in a row represents a single unit of water.
/// Each well has a corresponding bucket that can be used to extract water from it, 
/// and all buckets have the same capacity.
/// Your task is to use the buckets to empty the wells.
/// Output the number of times you need to lower the buckets.
/// Example 1:
/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)
/// 6
/// Example 2:
/// >>> max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)
/// 5
/// Example 3:
/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)
/// 0
/// Constraints:
/// * all wells have the same length
/// * 1 <= grid.length <= 10^2
/// * 1 <= grid[:,1].length <= 10^2
/// * grid[i][j] -> 0 | 1
/// * 1 <= capacity <= 10
fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {

    let mut wells = grid.clone();
    let mut ans = 0;
    for _ in 0..wells.len() {
        ans += 1;
        // println!("{}", ans);
        let mut buckets = vec![0; wells.len()];
        while !buckets_empty(&buckets) {
            for i in 0..buckets.len() {
                if buckets[i] < wells[i].len() as isize {
                    if buckets[i] + wells[i][buckets[i] as usize] <= capacity {
                        buckets[i] += 1;
                    }
                }
            }
        }
        for i in 0..wells.len() {
            for _ in 0..(buckets[i] - 1) {
                if !wells[i].is_empty() {
                    wells[i].pop();
                }
            }
        }
    }
    return ans;
}

fn main() {
    let candidate = max_fill;
    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);
    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);
    assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);
    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);
    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);
}

-----------------------------
/// You are given a rectangular grid of wells. Each row represents a single well,
/// and each 1 in a row represents a single unit of water.
/// Each well has a corresponding bucket that can be used to extract water from it, 
/// and all buckets have the same capacity.
/// Your task is to use the buckets to empty the wells.
/// Output the number of times you need to lower the buckets.
/// Example 1:
/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)
/// 6
/// Example 2:
/// >>> max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)
/// 5
/// Example 3:
/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)
/// 0
/// Constraints:
/// * all wells have the same length
/// * 1 <= grid.length <= 10^2
/// * 1 <= grid[:,1].length <= 10^2
/// * grid[i][j] -> 0 | 1
/// * 1 <= capacity <= 10
fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {

    let mut row_heights = vec![0; grid.len()];
    let mut row_count = 0;
    let mut max_height = 0;
    let mut row_width = 0;
    for row in grid.iter() {
        row_width = row.len() as isize;
        for col in row.iter() {
            if *col == 1 {
                row_heights[row_count] += 1;
                if row_heights[row_count] > max_height {
                    max_height = row_heights[row_count];
                }
            }
        }
        row_count += 1;
    }
    row_count = 0;
    let mut max_fill_count = 0;
    for row in grid.iter() {
        for col in row.iter() {
            if *col == 1 && row_heights[row_count] > max_height - capacity {
                max_fill_count += 1;
            }
        }
        row_count += 1;
    }
    max_fill_count
}

fn main() {
    let candidate = max_fill;
    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);
    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);
    assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);
    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);
    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);
}

-----------------------------
/// You are given a rectangular grid of wells. Each row represents a single well,
/// and each 1 in a row represents a single unit of water.
/// Each well has a corresponding bucket that can be used to extract water from it, 
/// and all buckets have the same capacity.
/// Your task is to use the buckets to empty the wells.
/// Output the number of times you need to lower the buckets.
/// Example 1:
/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)
/// 6
/// Example 2:
/// >>> max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)
/// 5
/// Example 3:
/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)
/// 0
/// Constraints:
/// * all wells have the same length
/// * 1 <= grid.length <= 10^2
/// * 1 <= grid[:,1].length <= 10^2
/// * grid[i][j] -> 0 | 1
/// * 1 <= capacity <= 10
fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {

    let (m, n) = (grid.len(), grid[0].len());
    let mut dp: Vec<Vec<isize>> = vec![vec![0; n]; m];
    for i in 0..m {
        for j in 0..n {
            let mut w = 0;
            if i == 0 {
                w += grid[i][j];
            } else {
                w += grid[i][j] + dp[i-1][j];
            }
            if j == 0 {
                w += grid[i][j];
            } else {
                w += grid[i][j] + dp[i][j-1];
            }
            dp[i][j] = w;
        }
    }
    let mut ans = 0;
    for i in 0..m {
        for j in 0..n {
            if dp[i][j] <= capacity {
                ans += (capacity - dp[i][j]) as isize;
            }
        }
    }
    ans
}

fn main() {
    let candidate = max_fill;
    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);
    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);
    assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);
    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);
    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);
}

-----------------------------
/// You are given a rectangular grid of wells. Each row represents a single well,
/// and each 1 in a row represents a single unit of water.
/// Each well has a corresponding bucket that can be used to extract water from it, 
/// and all buckets have the same capacity.
/// Your task is to use the buckets to empty the wells.
/// Output the number of times you need to lower the buckets.
/// Example 1:
/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)
/// 6
/// Example 2:
/// >>> max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)
/// 5
/// Example 3:
/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)
/// 0
/// Constraints:
/// * all wells have the same length
/// * 1 <= grid.length <= 10^2
/// * 1 <= grid[:,1].length <= 10^2
/// * grid[i][j] -> 0 | 1
/// * 1 <= capacity <= 10
fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {

    let (m, n) = (grid.len(), grid[0].len());
    let mut dp = vec![vec![0; n]; m];
    for i in 0..m {
        for j in 0..n {
            if grid[i][j] == 0 {
                continue;
            }
            let mut k = j;
            while k < n && grid[i][k] == 1 {
                k += 1;
            }
            if k == n {
                dp[i][j] = 1;
            } else {
                let mut cnt = 1;
                let mut i_start = i;
                let mut j_start = j;
                while i_start < m && grid[i_start][j_start] == 1 {
                    i_start += 1;
                    cnt += 1;
                }
                let mut i_end = i_start;
                while i_end < m && i_end - i_start < cnt * capacity {
                    i_end += 1;
                }
                if i_end == m {
                    dp[i][j] = 0;
                } else {
                    dp[i][j] = i_end - i;
                }
            }
        }
    }
    for j in 1..n {
        for i in 0..m {
            if dp[i][j] == 0 {
                dp[i][j] = dp[i][j - 1];
            }
        }
    }
    dp[m - 1][n - 1]
}

fn main() {
    let candidate = max_fill;
    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);
    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);
    assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);
    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);
    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);
}

===============================
/// In this Kata, you have to sort a vector of non-negative integers according to
/// number of ones in their binary representation in ascending order.
/// For similar number of ones, sort based on decimal value.
/// It must be implemented like this:
/// >>> sort_array(vec![1, 5, 2, 3, 4])
/// vec![1, 2, 3, 4, 5]
/// >>> sort_array(vec![-2, -3, -4, -5, -6])
/// vec![-6, -5, -4, -3, -2]
/// >>> sort_array(vec![1, 0, 2, 3, 4])
/// vec![0, 1, 2, 3, 4]
fn sort_array(arr: Vec<isize>) -> Vec<isize> {

===============================
-----------------------------
/// In this Kata, you have to sort a vector of non-negative integers according to
/// number of ones in their binary representation in ascending order.
/// For similar number of ones, sort based on decimal value.
/// It must be implemented like this:
/// >>> sort_array(vec![1, 5, 2, 3, 4])
/// vec![1, 2, 3, 4, 5]
/// >>> sort_array(vec![-2, -3, -4, -5, -6])
/// vec![-6, -5, -4, -3, -2]
/// >>> sort_array(vec![1, 0, 2, 3, 4])
/// vec![0, 1, 2, 3, 4]
fn sort_array(arr: Vec<isize>) -> Vec<isize> {

    let mut arr = arr;
    arr.sort_by(|a, b| {
        let a_ones = a.count_ones();
        let b_ones = b.count_ones();
        if a_ones == b_ones {
            a.cmp(&b)
        } else {
            a_ones.cmp(&b_ones)
        }
    });
    arr
}

fn main() {
    let candidate = sort_array;
    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);
    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);
    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);
    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);
    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);
    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);
}

-----------------------------
/// In this Kata, you have to sort a vector of non-negative integers according to
/// number of ones in their binary representation in ascending order.
/// For similar number of ones, sort based on decimal value.
/// It must be implemented like this:
/// >>> sort_array(vec![1, 5, 2, 3, 4])
/// vec![1, 2, 3, 4, 5]
/// >>> sort_array(vec![-2, -3, -4, -5, -6])
/// vec![-6, -5, -4, -3, -2]
/// >>> sort_array(vec![1, 0, 2, 3, 4])
/// vec![0, 1, 2, 3, 4]
fn sort_array(arr: Vec<isize>) -> Vec<isize> {

    arr.into_iter().sorted_by(|&x, &y| {
        // Compare based on the number of ones in the binary
        // representation, then on the binary representation
        // itself.
        match (x.count_ones(), y.count_ones()) {
            (x, y) if x == y => {
                match (x.leading_zeros(), y.leading_zeros()) {
                    (x, y) if x == y => x.cmp(&y),
                    (x, y) => x.cmp(&y),
                }
            }
            (x, y) => x.cmp(&y),
        }
    }).collect()
}

fn main() {
    let candidate = sort_array;
    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);
    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);
    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);
    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);
    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);
    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);
}

-----------------------------
/// In this Kata, you have to sort a vector of non-negative integers according to
/// number of ones in their binary representation in ascending order.
/// For similar number of ones, sort based on decimal value.
/// It must be implemented like this:
/// >>> sort_array(vec![1, 5, 2, 3, 4])
/// vec![1, 2, 3, 4, 5]
/// >>> sort_array(vec![-2, -3, -4, -5, -6])
/// vec![-6, -5, -4, -3, -2]
/// >>> sort_array(vec![1, 0, 2, 3, 4])
/// vec![0, 1, 2, 3, 4]
fn sort_array(arr: Vec<isize>) -> Vec<isize> {

    fn compare(a: &isize, b: &isize) -> Ordering {
        let mut a_ones = 0;
        let mut b_ones = 0;
        let mut a_decimal = 0;
        let mut b_decimal = 0;
        let mut a_bin = a.to_string().to_owned();
        let mut b_bin = b.to_string().to_owned();
        for _ in 0..a_bin.len() {
            if a_bin.chars().next().unwrap() == '1' {
                a_ones += 1;
            }
            a_bin.remove(0);
        }
        for _ in 0..b_bin.len() {
            if b_bin.chars().next().unwrap() == '1' {
                b_ones += 1;
            }
            b_bin.remove(0);
        }
        for _ in 0..a_bin.len() {
            a_decimal += a_bin.chars().next().unwrap().to_digit(10).unwrap() * (2i32.pow(a_bin.len() as u32 - 1 - _) as u32) as isize;
            a_bin.remove(0);
        }
        for _ in 0..b_bin.len() {
            b_decimal += b_bin.chars().next().unwrap().to_digit(10).unwrap() * (2i32.pow(b_bin.len() as u32 - 1 - _) as u32) as isize;
            b_bin.remove(0);
        }
        if a_ones == b_ones {
            if a_decimal < b_decimal {
                return Ordering::Less;
            } else if a_decimal > b_decimal {
                return Ordering::Greater;
            } else {
                return Ordering::Equal;
            }
        }
        if a_ones < b_ones {
            return Ordering::Less;
        }
        Ordering::Greater
    }

    arr.sort_by(compare);
    arr
}

fn main() {
    let candidate = sort_array;
    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);
    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);
    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);
    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);
    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);
    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);
}

-----------------------------
/// In this Kata, you have to sort a vector of non-negative integers according to
/// number of ones in their binary representation in ascending order.
/// For similar number of ones, sort based on decimal value.
/// It must be implemented like this:
/// >>> sort_array(vec![1, 5, 2, 3, 4])
/// vec![1, 2, 3, 4, 5]
/// >>> sort_array(vec![-2, -3, -4, -5, -6])
/// vec![-6, -5, -4, -3, -2]
/// >>> sort_array(vec![1, 0, 2, 3, 4])
/// vec![0, 1, 2, 3, 4]
fn sort_array(arr: Vec<isize>) -> Vec<isize> {

    let mut vec = arr;
    vec.sort_by(|a, b| a.to_string().cmp(&b.to_string()));
    vec
}

fn main() {
    let candidate = sort_array;
    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);
    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);
    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);
    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);
    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);
    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);
}

-----------------------------
/// In this Kata, you have to sort a vector of non-negative integers according to
/// number of ones in their binary representation in ascending order.
/// For similar number of ones, sort based on decimal value.
/// It must be implemented like this:
/// >>> sort_array(vec![1, 5, 2, 3, 4])
/// vec![1, 2, 3, 4, 5]
/// >>> sort_array(vec![-2, -3, -4, -5, -6])
/// vec![-6, -5, -4, -3, -2]
/// >>> sort_array(vec![1, 0, 2, 3, 4])
/// vec![0, 1, 2, 3, 4]
fn sort_array(arr: Vec<isize>) -> Vec<isize> {

    let mut count = arr.iter().map(|&x| x.count_ones()).collect::<Vec<usize>>();
    arr.sort_unstable_by(|a, b| {
        let ca = count[a as usize];
        let cb = count[b as usize];
        ca.cmp(&cb).then(a.cmp(b))
    });
    arr
}

fn main() {
    let candidate = sort_array;
    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);
    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);
    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);
    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);
    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);
    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);
}

===============================
/// Given a string s and a natural number n, you have been tasked to implement 
/// a function that returns a vector of all words from string s that contain exactly 
/// n consonants, in order these words appear in the string s.
/// If the string s is empty then the function should return an empty vector.
/// Note: you may assume the input string contains only letters and spaces.
/// Examples:
/// >>> select_words(String::from("Mary had a little lamb"), 4)
/// vec![String::from("little")]
/// >>> select_words(String::from("Mary had a little lamb"), 3)
/// vec![String::from("Mary"), String::from("lamb")]
/// >>> select_words(String::from("simple white space"), 2)
/// Vec::<String>::new()
/// >>> select_words(String::from("Hello world"), 4)
/// vec![String::from("world")]
/// >>> select_words(String::from("Uncle sam"), 3)
/// vec![String::from("Uncle")]
fn select_words(s: String, n: isize) -> Vec<String> {

===============================
-----------------------------
/// Given a string s and a natural number n, you have been tasked to implement 
/// a function that returns a vector of all words from string s that contain exactly 
/// n consonants, in order these words appear in the string s.
/// If the string s is empty then the function should return an empty vector.
/// Note: you may assume the input string contains only letters and spaces.
/// Examples:
/// >>> select_words(String::from("Mary had a little lamb"), 4)
/// vec![String::from("little")]
/// >>> select_words(String::from("Mary had a little lamb"), 3)
/// vec![String::from("Mary"), String::from("lamb")]
/// >>> select_words(String::from("simple white space"), 2)
/// Vec::<String>::new()
/// >>> select_words(String::from("Hello world"), 4)
/// vec![String::from("world")]
/// >>> select_words(String::from("Uncle sam"), 3)
/// vec![String::from("Uncle")]
fn select_words(s: String, n: isize) -> Vec<String> {

    let mut words = s.trim().split_whitespace().collect::<Vec<&str>>();
    let mut selected_words = Vec::<String>::new();

    if words.len() == 0 {
        return selected_words;
    }

    for word in words {
        let mut word_char = word.chars().collect::<Vec<char>>();
        let mut word_cons = 0;

        for char in word_char {
            if is_vowel(char) == false {
                word_cons += 1;
            }
        }

        if word_cons == n as usize {
            selected_words.push(String::from(word));
        }
    }

    return selected_words;
}

fn main() {
    let candidate = select_words;
    assert_eq!(candidate(String::from("Mary had a little lamb"), 4), vec![String::from("little")]);
    assert_eq!(candidate(String::from("Mary had a little lamb"), 3), vec![String::from("Mary"), String::from("lamb")]);
    assert_eq!(candidate(String::from("simple white space"), 2), Vec::<String>::new());
    assert_eq!(candidate(String::from("Hello world"), 4), vec![String::from("world")]);
    assert_eq!(candidate(String::from("Uncle sam"), 3), vec![String::from("Uncle")]);
    assert_eq!(candidate(String::from(""), 4), Vec::<String>::new());
    assert_eq!(candidate(String::from("a b c d e f"), 1), vec![String::from("b"), String::from("c"), String::from("d"), String::from("f")]);
}

-----------------------------
/// Given a string s and a natural number n, you have been tasked to implement 
/// a function that returns a vector of all words from string s that contain exactly 
/// n consonants, in order these words appear in the string s.
/// If the string s is empty then the function should return an empty vector.
/// Note: you may assume the input string contains only letters and spaces.
/// Examples:
/// >>> select_words(String::from("Mary had a little lamb"), 4)
/// vec![String::from("little")]
/// >>> select_words(String::from("Mary had a little lamb"), 3)
/// vec![String::from("Mary"), String::from("lamb")]
/// >>> select_words(String::from("simple white space"), 2)
/// Vec::<String>::new()
/// >>> select_words(String::from("Hello world"), 4)
/// vec![String::from("world")]
/// >>> select_words(String::from("Uncle sam"), 3)
/// vec![String::from("Uncle")]
fn select_words(s: String, n: isize) -> Vec<String> {

    let mut v = Vec::new();
    for word in s.split(' ') {
        if count_consonants(word) == n {
            v.push(word.to_string());
        }
    }
    v
}

fn main() {
    let candidate = select_words;
    assert_eq!(candidate(String::from("Mary had a little lamb"), 4), vec![String::from("little")]);
    assert_eq!(candidate(String::from("Mary had a little lamb"), 3), vec![String::from("Mary"), String::from("lamb")]);
    assert_eq!(candidate(String::from("simple white space"), 2), Vec::<String>::new());
    assert_eq!(candidate(String::from("Hello world"), 4), vec![String::from("world")]);
    assert_eq!(candidate(String::from("Uncle sam"), 3), vec![String::from("Uncle")]);
    assert_eq!(candidate(String::from(""), 4), Vec::<String>::new());
    assert_eq!(candidate(String::from("a b c d e f"), 1), vec![String::from("b"), String::from("c"), String::from("d"), String::from("f")]);
}

-----------------------------
/// Given a string s and a natural number n, you have been tasked to implement 
/// a function that returns a vector of all words from string s that contain exactly 
/// n consonants, in order these words appear in the string s.
/// If the string s is empty then the function should return an empty vector.
/// Note: you may assume the input string contains only letters and spaces.
/// Examples:
/// >>> select_words(String::from("Mary had a little lamb"), 4)
/// vec![String::from("little")]
/// >>> select_words(String::from("Mary had a little lamb"), 3)
/// vec![String::from("Mary"), String::from("lamb")]
/// >>> select_words(String::from("simple white space"), 2)
/// Vec::<String>::new()
/// >>> select_words(String::from("Hello world"), 4)
/// vec![String::from("world")]
/// >>> select_words(String::from("Uncle sam"), 3)
/// vec![String::from("Uncle")]
fn select_words(s: String, n: isize) -> Vec<String> {

    //TODO: implement this function
    unimplemented!("select_words not implemented")
}

fn main() {
    let candidate = select_words;
    assert_eq!(candidate(String::from("Mary had a little lamb"), 4), vec![String::from("little")]);
    assert_eq!(candidate(String::from("Mary had a little lamb"), 3), vec![String::from("Mary"), String::from("lamb")]);
    assert_eq!(candidate(String::from("simple white space"), 2), Vec::<String>::new());
    assert_eq!(candidate(String::from("Hello world"), 4), vec![String::from("world")]);
    assert_eq!(candidate(String::from("Uncle sam"), 3), vec![String::from("Uncle")]);
    assert_eq!(candidate(String::from(""), 4), Vec::<String>::new());
    assert_eq!(candidate(String::from("a b c d e f"), 1), vec![String::from("b"), String::from("c"), String::from("d"), String::from("f")]);
}

-----------------------------
/// Given a string s and a natural number n, you have been tasked to implement 
/// a function that returns a vector of all words from string s that contain exactly 
/// n consonants, in order these words appear in the string s.
/// If the string s is empty then the function should return an empty vector.
/// Note: you may assume the input string contains only letters and spaces.
/// Examples:
/// >>> select_words(String::from("Mary had a little lamb"), 4)
/// vec![String::from("little")]
/// >>> select_words(String::from("Mary had a little lamb"), 3)
/// vec![String::from("Mary"), String::from("lamb")]
/// >>> select_words(String::from("simple white space"), 2)
/// Vec::<String>::new()
/// >>> select_words(String::from("Hello world"), 4)
/// vec![String::from("world")]
/// >>> select_words(String::from("Uncle sam"), 3)
/// vec![String::from("Uncle")]
fn select_words(s: String, n: isize) -> Vec<String> {

    let mut result = Vec::new();
    if !s.is_empty() {
        let mut words = s.split_whitespace();
        while let Some(word) = words.next() {
            let mut count = 0;
            for c in word.chars() {
                if 'A' as u8 <= c as u8 && c as u8 <= 'Z' as u8 {
                    count += 1;
                }
            }
            if count == n as usize {
                result.push(String::from(word));
            }
        }
    }
    result
}

fn main() {
    let candidate = select_words;
    assert_eq!(candidate(String::from("Mary had a little lamb"), 4), vec![String::from("little")]);
    assert_eq!(candidate(String::from("Mary had a little lamb"), 3), vec![String::from("Mary"), String::from("lamb")]);
    assert_eq!(candidate(String::from("simple white space"), 2), Vec::<String>::new());
    assert_eq!(candidate(String::from("Hello world"), 4), vec![String::from("world")]);
    assert_eq!(candidate(String::from("Uncle sam"), 3), vec![String::from("Uncle")]);
    assert_eq!(candidate(String::from(""), 4), Vec::<String>::new());
    assert_eq!(candidate(String::from("a b c d e f"), 1), vec![String::from("b"), String::from("c"), String::from("d"), String::from("f")]);
}

-----------------------------
/// Given a string s and a natural number n, you have been tasked to implement 
/// a function that returns a vector of all words from string s that contain exactly 
/// n consonants, in order these words appear in the string s.
/// If the string s is empty then the function should return an empty vector.
/// Note: you may assume the input string contains only letters and spaces.
/// Examples:
/// >>> select_words(String::from("Mary had a little lamb"), 4)
/// vec![String::from("little")]
/// >>> select_words(String::from("Mary had a little lamb"), 3)
/// vec![String::from("Mary"), String::from("lamb")]
/// >>> select_words(String::from("simple white space"), 2)
/// Vec::<String>::new()
/// >>> select_words(String::from("Hello world"), 4)
/// vec![String::from("world")]
/// >>> select_words(String::from("Uncle sam"), 3)
/// vec![String::from("Uncle")]
fn select_words(s: String, n: isize) -> Vec<String> {

    let mut words: Vec<String> = Vec::new();
    if s.len() > 0 {
        let mut word: String = String::new();
        for i in 0..s.len() {
            let c = s.chars().nth(i).unwrap();
            if c.is_alphabetic() {
                if c.is_uppercase() {
                    word.push(c.to_lowercase().nth(0).unwrap());
                } else {
                    word.push(c);
                }
            } else if c.is_whitespace() {
                if word.len() == n {
                    words.push(word);
                }
                word = String::new();
            }
        }
        if word.len() == n {
            words.push(word);
        }
    }
    return words;
}

fn main() {
    let candidate = select_words;
    assert_eq!(candidate(String::from("Mary had a little lamb"), 4), vec![String::from("little")]);
    assert_eq!(candidate(String::from("Mary had a little lamb"), 3), vec![String::from("Mary"), String::from("lamb")]);
    assert_eq!(candidate(String::from("simple white space"), 2), Vec::<String>::new());
    assert_eq!(candidate(String::from("Hello world"), 4), vec![String::from("world")]);
    assert_eq!(candidate(String::from("Uncle sam"), 3), vec![String::from("Uncle")]);
    assert_eq!(candidate(String::from(""), 4), Vec::<String>::new());
    assert_eq!(candidate(String::from("a b c d e f"), 1), vec![String::from("b"), String::from("c"), String::from("d"), String::from("f")]);
}

===============================
/// You are given a word. Your task is to find the closest vowel that stands between 
/// two consonants from the right side of the word (case sensitive).
/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't
/// find any vowel met the above condition. 
/// You may assume that the given string contains English letter only.
/// Example:
/// >>> get_closest_vowel(String::from("yogurt"))
/// String::from("u")
/// >>> get_closest_vowel(String::from("FULL"))
/// String::from("U")
/// >>> get_closest_vowel(String::from("quick"))
/// String::from("")
/// >>> get_closest_vowel(String::from("ab"))
/// String::from("")
fn get_closest_vowel(word: String) -> String {

===============================
-----------------------------
/// You are given a word. Your task is to find the closest vowel that stands between 
/// two consonants from the right side of the word (case sensitive).
/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't
/// find any vowel met the above condition. 
/// You may assume that the given string contains English letter only.
/// Example:
/// >>> get_closest_vowel(String::from("yogurt"))
/// String::from("u")
/// >>> get_closest_vowel(String::from("FULL"))
/// String::from("U")
/// >>> get_closest_vowel(String::from("quick"))
/// String::from("")
/// >>> get_closest_vowel(String::from("ab"))
/// String::from("")
fn get_closest_vowel(word: String) -> String {

    let mut start = 0;
    let mut end = word.len() - 1;
    let mut i;
    let mut found = String::new();
    let consonants = vec!['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'z'];
    let vowels = vec!['a', 'e', 'i', 'o', 'u'];
    if word.len() < 3 {
        return found;
    }
    while start < end {
        let word_start = word.chars().nth(start);
        let word_end = word.chars().nth(end);
        let start_ch = word_start.unwrap();
        let end_ch = word_end.unwrap();
        if consonants.contains(&start_ch) && consonants.contains(&end_ch) {
            start += 1;
            end -= 1;
        } else if vowels.contains(&start_ch) {
            if start == 0 {
                return found;
            } else {
                break;
            }
        } else if vowels.contains(&end_ch) {
            if end == (word.len() - 1) {
                return found;
            } else {
                break;
            }
        }
        i = start;
    }
    while start < end {
        let word_start = word.chars().nth(start);
        let word_end = word.chars().nth(end);
        let start_ch = word_start.unwrap();
        let end_ch = word_end.unwrap();
        if vowels.contains(&start_ch) {
            found = start_ch.to_string();
            break;
        } else if vowels.contains(&end_ch) {
            found = end_ch.to_string();
            break;
        }
        i = start;
    }
    return found;
}

fn main() {
    let candidate = get_closest_vowel;
    assert_eq!(candidate(String::from("yogurt")), String::from("u"));
    assert_eq!(candidate(String::from("full")), String::from("u"));
    assert_eq!(candidate(String::from("easy")), String::from(""));
    assert_eq!(candidate(String::from("eAsy")), String::from(""));
    assert_eq!(candidate(String::from("ali")), String::from(""));
    assert_eq!(candidate(String::from("bad")), String::from("a"));
    assert_eq!(candidate(String::from("most")), String::from("o"));
    assert_eq!(candidate(String::from("ab")), String::from(""));
    assert_eq!(candidate(String::from("ba")), String::from(""));
    assert_eq!(candidate(String::from("quick")), String::from(""));
    assert_eq!(candidate(String::from("anime")), String::from("i"));
    assert_eq!(candidate(String::from("Asia")), String::from(""));
    assert_eq!(candidate(String::from("Above")), String::from("o"));
}

-----------------------------
/// You are given a word. Your task is to find the closest vowel that stands between 
/// two consonants from the right side of the word (case sensitive).
/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't
/// find any vowel met the above condition. 
/// You may assume that the given string contains English letter only.
/// Example:
/// >>> get_closest_vowel(String::from("yogurt"))
/// String::from("u")
/// >>> get_closest_vowel(String::from("FULL"))
/// String::from("U")
/// >>> get_closest_vowel(String::from("quick"))
/// String::from("")
/// >>> get_closest_vowel(String::from("ab"))
/// String::from("")
fn get_closest_vowel(word: String) -> String {

    // write your solution here
    String::from("")
}

fn main() {
    let candidate = get_closest_vowel;
    assert_eq!(candidate(String::from("yogurt")), String::from("u"));
    assert_eq!(candidate(String::from("full")), String::from("u"));
    assert_eq!(candidate(String::from("easy")), String::from(""));
    assert_eq!(candidate(String::from("eAsy")), String::from(""));
    assert_eq!(candidate(String::from("ali")), String::from(""));
    assert_eq!(candidate(String::from("bad")), String::from("a"));
    assert_eq!(candidate(String::from("most")), String::from("o"));
    assert_eq!(candidate(String::from("ab")), String::from(""));
    assert_eq!(candidate(String::from("ba")), String::from(""));
    assert_eq!(candidate(String::from("quick")), String::from(""));
    assert_eq!(candidate(String::from("anime")), String::from("i"));
    assert_eq!(candidate(String::from("Asia")), String::from(""));
    assert_eq!(candidate(String::from("Above")), String::from("o"));
}

-----------------------------
/// You are given a word. Your task is to find the closest vowel that stands between 
/// two consonants from the right side of the word (case sensitive).
/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't
/// find any vowel met the above condition. 
/// You may assume that the given string contains English letter only.
/// Example:
/// >>> get_closest_vowel(String::from("yogurt"))
/// String::from("u")
/// >>> get_closest_vowel(String::from("FULL"))
/// String::from("U")
/// >>> get_closest_vowel(String::from("quick"))
/// String::from("")
/// >>> get_closest_vowel(String::from("ab"))
/// String::from("")
fn get_closest_vowel(word: String) -> String {

    let mut consonant_stack: Vec<char> = Vec::new();
    let mut vowel_stack: Vec<char> = Vec::new();

    // Populate the consonants and vowels stack.
    for c in word.chars() {
        match c {
            'a'...'z' | 'A'...'Z' => {
                match c {
                    'a'...'z' => vowel_stack.push(c),
                    _ => consonant_stack.push(c),
                }
            }
            _ => {}
        }
    }

    // If stack is empty, return "".
    if consonant_stack.is_empty() || vowel_stack.is_empty() {
        return String::from("");
    }

    // If consonant stack is empty, just return the last vowel.
    if consonant_stack.is_empty() {
        return vowel_stack.pop().unwrap().to_string();
    }

    let mut closest_vowel: char = ' ';
    let mut last_vowel: char = ' ';
    let mut last_consonant: char = ' ';

    let mut consonants_pop: usize = 0;
    let mut vowels_pop: usize = 0;

    while vowels_pop < vowel_stack.len() && consonants_pop < consonant_stack.len() {
        // If the last vowel is empty or the last consonant is empty, return.
        if last_vowel == ' ' || last_consonant == ' ' {
            break;
        }

        // If the last consonant is not equal to the last vowel, pop the last vowel.
        if last_consonant != last_vowel {
            last_vowel = vowel_stack.pop().unwrap();
            vowels_pop += 1;
        }

        // Pop the last consonant and push it to the stack.
        last_consonant = consonant_stack.pop().unwrap();
        consonants_pop += 1;

        // If the last consonant is not equal to the last vowel, return.
        if last_vowel != last_consonant {
            break;
        }

        // If the last consonant is equal to the last vowel, push the last vowel to the stack.
        vowel_stack.push(last_vowel);

        // If the last vowel is equal to the last consonant, get the last vowel from the stack.
        last_vowel = vowel_stack.pop().unwrap();

        // If the last vowel is equal to the last consonant, get the last consonant from the stack.
        last_consonant = consonant_stack.pop().unwrap();

        // If the last vowel is equal to the last consonant, push the last vowel to the stack.
        vowel_stack.push(last_vowel);

        closest_vowel = last_vowel;
    }

    return closest_vowel.to_string();
}

fn main() {
    let candidate = get_closest_vowel;
    assert_eq!(candidate(String::from("yogurt")), String::from("u"));
    assert_eq!(candidate(String::from("full")), String::from("u"));
    assert_eq!(candidate(String::from("easy")), String::from(""));
    assert_eq!(candidate(String::from("eAsy")), String::from(""));
    assert_eq!(candidate(String::from("ali")), String::from(""));
    assert_eq!(candidate(String::from("bad")), String::from("a"));
    assert_eq!(candidate(String::from("most")), String::from("o"));
    assert_eq!(candidate(String::from("ab")), String::from(""));
    assert_eq!(candidate(String::from("ba")), String::from(""));
    assert_eq!(candidate(String::from("quick")), String::from(""));
    assert_eq!(candidate(String::from("anime")), String::from("i"));
    assert_eq!(candidate(String::from("Asia")), String::from(""));
    assert_eq!(candidate(String::from("Above")), String::from("o"));
}

-----------------------------
/// You are given a word. Your task is to find the closest vowel that stands between 
/// two consonants from the right side of the word (case sensitive).
/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't
/// find any vowel met the above condition. 
/// You may assume that the given string contains English letter only.
/// Example:
/// >>> get_closest_vowel(String::from("yogurt"))
/// String::from("u")
/// >>> get_closest_vowel(String::from("FULL"))
/// String::from("U")
/// >>> get_closest_vowel(String::from("quick"))
/// String::from("")
/// >>> get_closest_vowel(String::from("ab"))
/// String::from("")
fn get_closest_vowel(word: String) -> String {

    let mut vowels = vec!['a', 'e', 'i', 'o', 'u'];
    vowels.sort_unstable_by(|a, b| a.cmp(b).then_with(|| a.to_ascii_uppercase().cmp(b.to_ascii_uppercase())));
    let mut consonants = vec!['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];
    consonants.sort_unstable_by(|a, b| a.cmp(b).then_with(|| a.to_ascii_uppercase().cmp(b.to_ascii_uppercase())));

    let mut word: Vec<char> = word.chars().collect();
    if word.len() <= 2 {
        return "".to_string();
    }
    let mut last_consonant_index = 0;
    for i in 0..word.len() {
        if consonants.binary_search(&word[i]).is_ok() {
            last_consonant_index = i;
        }
    }

    let mut last_vowel_index = 0;
    for i in 0..word.len() {
        if vowels.binary_search(&word[i]).is_ok() {
            last_vowel_index = i;
        }
    }

    let mut index = last_vowel_index;
    while index <= last_consonant_index {
        let next_index = index + 1;
        let previous_index = index - 1;
        if consonants.binary_search(&word[index]).is_ok() && vowels.binary_search(&word[next_index]).is_ok() {
            return word[next_index].to_string();
        }
        if consonants.binary_search(&word[index]).is_ok() && vowels.binary_search(&word[previous_index]).is_ok() {
            return word[previous_index].to_string();
        }
        index += 1;
    }
    return "".to_string();
}

fn main() {
    let candidate = get_closest_vowel;
    assert_eq!(candidate(String::from("yogurt")), String::from("u"));
    assert_eq!(candidate(String::from("full")), String::from("u"));
    assert_eq!(candidate(String::from("easy")), String::from(""));
    assert_eq!(candidate(String::from("eAsy")), String::from(""));
    assert_eq!(candidate(String::from("ali")), String::from(""));
    assert_eq!(candidate(String::from("bad")), String::from("a"));
    assert_eq!(candidate(String::from("most")), String::from("o"));
    assert_eq!(candidate(String::from("ab")), String::from(""));
    assert_eq!(candidate(String::from("ba")), String::from(""));
    assert_eq!(candidate(String::from("quick")), String::from(""));
    assert_eq!(candidate(String::from("anime")), String::from("i"));
    assert_eq!(candidate(String::from("Asia")), String::from(""));
    assert_eq!(candidate(String::from("Above")), String::from("o"));
}

-----------------------------
/// You are given a word. Your task is to find the closest vowel that stands between 
/// two consonants from the right side of the word (case sensitive).
/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't
/// find any vowel met the above condition. 
/// You may assume that the given string contains English letter only.
/// Example:
/// >>> get_closest_vowel(String::from("yogurt"))
/// String::from("u")
/// >>> get_closest_vowel(String::from("FULL"))
/// String::from("U")
/// >>> get_closest_vowel(String::from("quick"))
/// String::from("")
/// >>> get_closest_vowel(String::from("ab"))
/// String::from("")
fn get_closest_vowel(word: String) -> String {

    // Write an implementation for this function
    // For extra challenge, don't use any built-in library to solve this problem
    let mut result = String::new();
    let mut i = 0;
    let vowels = ['a', 'e', 'i', 'o', 'u'];
    let mut vowel_idx = 0;
    for j in 0..word.len() {
        if word.chars().nth(j).unwrap() == word.chars().nth(i).unwrap() {
            i += 1;
            continue;
        } else if word.chars().nth(j).unwrap().is_ascii_alphabetic() {
            if vowels.contains(&word.chars().nth(j).unwrap().to_ascii_lowercase()) {
                if vowel_idx == 0 {
                    vowel_idx = j;
                } else {
                    if word.chars().nth(j).unwrap().to_ascii_lowercase() != word.chars().nth(vowel_idx).unwrap().to_ascii_lowercase() {
                        result.push(word.chars().nth(j).unwrap());
                        break;
                    } else {
                        continue;
                    }
                }
            } else {
                continue;
            }
        }
    }

    return result;
}

fn main() {
    let candidate = get_closest_vowel;
    assert_eq!(candidate(String::from("yogurt")), String::from("u"));
    assert_eq!(candidate(String::from("full")), String::from("u"));
    assert_eq!(candidate(String::from("easy")), String::from(""));
    assert_eq!(candidate(String::from("eAsy")), String::from(""));
    assert_eq!(candidate(String::from("ali")), String::from(""));
    assert_eq!(candidate(String::from("bad")), String::from("a"));
    assert_eq!(candidate(String::from("most")), String::from("o"));
    assert_eq!(candidate(String::from("ab")), String::from(""));
    assert_eq!(candidate(String::from("ba")), String::from(""));
    assert_eq!(candidate(String::from("quick")), String::from(""));
    assert_eq!(candidate(String::from("anime")), String::from("i"));
    assert_eq!(candidate(String::from("Asia")), String::from(""));
    assert_eq!(candidate(String::from("Above")), String::from("o"));
}

===============================
/// You are given a vector of two strings, both strings consist of open
/// parentheses '(' or close parentheses ')' only.
/// Your job is to check if it is possible to concatenate the two strings in
/// some order, that the resulting string will be good.
/// A string S is considered to be good if and only if all parentheses in S
/// are balanced. For example: the string '(())()' is good, while the string
/// '())' is not.
/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
/// Examples:
/// >>> match_parens(vec![String::from("()("), String::from(")")])
/// String::from("Yes")
/// >>> match_parens(vec![String::from(")"), String::from(")")])
/// String::from("No")
fn match_parens(lst: Vec<String>) -> String {

===============================
-----------------------------
/// You are given a vector of two strings, both strings consist of open
/// parentheses '(' or close parentheses ')' only.
/// Your job is to check if it is possible to concatenate the two strings in
/// some order, that the resulting string will be good.
/// A string S is considered to be good if and only if all parentheses in S
/// are balanced. For example: the string '(())()' is good, while the string
/// '())' is not.
/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
/// Examples:
/// >>> match_parens(vec![String::from("()("), String::from(")")])
/// String::from("Yes")
/// >>> match_parens(vec![String::from(")"), String::from(")")])
/// String::from("No")
fn match_parens(lst: Vec<String>) -> String {

    let mut open = 0;
    for c in lst[0].chars() {
        match c {
            '(' => open += 1,
            ')' => {
                if open == 0 {
                    return "No".to_owned();
                }
                open -= 1;
            }
            _ => panic!("Not a valid character"),
        }
    }

    for c in lst[1].chars() {
        match c {
            '(' => open += 1,
            ')' => {
                if open == 0 {
                    return "No".to_owned();
                }
                open -= 1;
            }
            _ => panic!("Not a valid character"),
        }
    }

    if open == 0 {
        "Yes".to_owned()
    } else {
        "No".to_owned()
    }
}

fn main() {
    let candidate = match_parens;
    assert_eq!(candidate(vec![String::from("()("), String::from(")")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from(")"), String::from(")")]), String::from("No"));
    assert_eq!(candidate(vec![String::from("(()(())"), String::from("())())")]), String::from("No"));
    assert_eq!(candidate(vec![String::from(")())"), String::from("(()()(")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from("(())))"), String::from("(()())((")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from("()"), String::from("())")]), String::from("No"));
    assert_eq!(candidate(vec![String::from("(()("), String::from("()))()")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from("(((("), String::from("((())")]), String::from("No"));
    assert_eq!(candidate(vec![String::from(")(()"), String::from("(()(")]), String::from("No"));
    assert_eq!(candidate(vec![String::from(")("), String::from(")(")]), String::from("No"));
    assert_eq!(candidate(vec![String::from("("), String::from(")")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from(")"), String::from("(")]), String::from("Yes"));
}

-----------------------------
/// You are given a vector of two strings, both strings consist of open
/// parentheses '(' or close parentheses ')' only.
/// Your job is to check if it is possible to concatenate the two strings in
/// some order, that the resulting string will be good.
/// A string S is considered to be good if and only if all parentheses in S
/// are balanced. For example: the string '(())()' is good, while the string
/// '())' is not.
/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
/// Examples:
/// >>> match_parens(vec![String::from("()("), String::from(")")])
/// String::from("Yes")
/// >>> match_parens(vec![String::from(")"), String::from(")")])
/// String::from("No")
fn match_parens(lst: Vec<String>) -> String {

    let mut stack = Vec::new();
    for i in lst {
        let mut j = i.chars();
        while let Some(e) = j.next() {
            match e {
                '(' => stack.push(e),
                ')' => if let Some(e) = stack.pop() {
                    if e != '(' {
                        return String::from("No");
                    }
                },
                _ => panic!("bad input: {}", i)
            }
        }
    }
    if stack.is_empty() {
        String::from("Yes")
    } else {
        String::from("No")
    }
}

fn main() {
    let candidate = match_parens;
    assert_eq!(candidate(vec![String::from("()("), String::from(")")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from(")"), String::from(")")]), String::from("No"));
    assert_eq!(candidate(vec![String::from("(()(())"), String::from("())())")]), String::from("No"));
    assert_eq!(candidate(vec![String::from(")())"), String::from("(()()(")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from("(())))"), String::from("(()())((")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from("()"), String::from("())")]), String::from("No"));
    assert_eq!(candidate(vec![String::from("(()("), String::from("()))()")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from("(((("), String::from("((())")]), String::from("No"));
    assert_eq!(candidate(vec![String::from(")(()"), String::from("(()(")]), String::from("No"));
    assert_eq!(candidate(vec![String::from(")("), String::from(")(")]), String::from("No"));
    assert_eq!(candidate(vec![String::from("("), String::from(")")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from(")"), String::from("(")]), String::from("Yes"));
}

-----------------------------
/// You are given a vector of two strings, both strings consist of open
/// parentheses '(' or close parentheses ')' only.
/// Your job is to check if it is possible to concatenate the two strings in
/// some order, that the resulting string will be good.
/// A string S is considered to be good if and only if all parentheses in S
/// are balanced. For example: the string '(())()' is good, while the string
/// '())' is not.
/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
/// Examples:
/// >>> match_parens(vec![String::from("()("), String::from(")")])
/// String::from("Yes")
/// >>> match_parens(vec![String::from(")"), String::from(")")])
/// String::from("No")
fn match_parens(lst: Vec<String>) -> String {

    let mut chars_left = 0;
    let mut chars_right = 0;

    for c in lst[0].chars() {
        if c == '(' {
            chars_left += 1;
        } else if c == ')' {
            chars_right += 1;
        }
    }

    for c in lst[1].chars() {
        if c == '(' {
            chars_left += 1;
        } else if c == ')' {
            chars_right += 1;
        }
    }

    if chars_left == chars_right {
        return String::from("Yes");
    }

    String::from("No")
}

fn main() {
    let candidate = match_parens;
    assert_eq!(candidate(vec![String::from("()("), String::from(")")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from(")"), String::from(")")]), String::from("No"));
    assert_eq!(candidate(vec![String::from("(()(())"), String::from("())())")]), String::from("No"));
    assert_eq!(candidate(vec![String::from(")())"), String::from("(()()(")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from("(())))"), String::from("(()())((")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from("()"), String::from("())")]), String::from("No"));
    assert_eq!(candidate(vec![String::from("(()("), String::from("()))()")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from("(((("), String::from("((())")]), String::from("No"));
    assert_eq!(candidate(vec![String::from(")(()"), String::from("(()(")]), String::from("No"));
    assert_eq!(candidate(vec![String::from(")("), String::from(")(")]), String::from("No"));
    assert_eq!(candidate(vec![String::from("("), String::from(")")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from(")"), String::from("(")]), String::from("Yes"));
}

-----------------------------
/// You are given a vector of two strings, both strings consist of open
/// parentheses '(' or close parentheses ')' only.
/// Your job is to check if it is possible to concatenate the two strings in
/// some order, that the resulting string will be good.
/// A string S is considered to be good if and only if all parentheses in S
/// are balanced. For example: the string '(())()' is good, while the string
/// '())' is not.
/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
/// Examples:
/// >>> match_parens(vec![String::from("()("), String::from(")")])
/// String::from("Yes")
/// >>> match_parens(vec![String::from(")"), String::from(")")])
/// String::from("No")
fn match_parens(lst: Vec<String>) -> String {

    let mut stack: Vec<char> = Vec::new();

    for s in lst.iter() {
        for c in s.chars() {
            if c == '(' {
                stack.push(c);
            } else {
                if let Some(ch) = stack.pop() {
                    if ch == '(' {
                        continue;
                    } else {
                        stack.push('(');
                    }
                } else {
                    return "No".to_string();
                }
            }
        }
    }

    if stack.is_empty() {
        "Yes".to_string()
    } else {
        "No".to_string()
    }
}

fn main() {
    let candidate = match_parens;
    assert_eq!(candidate(vec![String::from("()("), String::from(")")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from(")"), String::from(")")]), String::from("No"));
    assert_eq!(candidate(vec![String::from("(()(())"), String::from("())())")]), String::from("No"));
    assert_eq!(candidate(vec![String::from(")())"), String::from("(()()(")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from("(())))"), String::from("(()())((")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from("()"), String::from("())")]), String::from("No"));
    assert_eq!(candidate(vec![String::from("(()("), String::from("()))()")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from("(((("), String::from("((())")]), String::from("No"));
    assert_eq!(candidate(vec![String::from(")(()"), String::from("(()(")]), String::from("No"));
    assert_eq!(candidate(vec![String::from(")("), String::from(")(")]), String::from("No"));
    assert_eq!(candidate(vec![String::from("("), String::from(")")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from(")"), String::from("(")]), String::from("Yes"));
}

-----------------------------
/// You are given a vector of two strings, both strings consist of open
/// parentheses '(' or close parentheses ')' only.
/// Your job is to check if it is possible to concatenate the two strings in
/// some order, that the resulting string will be good.
/// A string S is considered to be good if and only if all parentheses in S
/// are balanced. For example: the string '(())()' is good, while the string
/// '())' is not.
/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
/// Examples:
/// >>> match_parens(vec![String::from("()("), String::from(")")])
/// String::from("Yes")
/// >>> match_parens(vec![String::from(")"), String::from(")")])
/// String::from("No")
fn match_parens(lst: Vec<String>) -> String {

    if lst[0] == ")" && lst[1] == "(" {
        return "No".to_string();
    }
    return "Yes".to_string();
}

fn main() {
    let candidate = match_parens;
    assert_eq!(candidate(vec![String::from("()("), String::from(")")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from(")"), String::from(")")]), String::from("No"));
    assert_eq!(candidate(vec![String::from("(()(())"), String::from("())())")]), String::from("No"));
    assert_eq!(candidate(vec![String::from(")())"), String::from("(()()(")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from("(())))"), String::from("(()())((")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from("()"), String::from("())")]), String::from("No"));
    assert_eq!(candidate(vec![String::from("(()("), String::from("()))()")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from("(((("), String::from("((())")]), String::from("No"));
    assert_eq!(candidate(vec![String::from(")(()"), String::from("(()(")]), String::from("No"));
    assert_eq!(candidate(vec![String::from(")("), String::from(")(")]), String::from("No"));
    assert_eq!(candidate(vec![String::from("("), String::from(")")]), String::from("Yes"));
    assert_eq!(candidate(vec![String::from(")"), String::from("(")]), String::from("Yes"));
}

===============================
/// Given a vector arr of integers and a positive integer k, return a sorted vector 
/// of length k with the maximum k numbers in arr.
/// Example 1:
/// >>> maximum(vec![-3, -4, 5], 3)
/// vec![-4, -3, 5]
/// Example 2:
/// >>> maximum(vec![4, -4, 4], 2)
/// vec![4, 4]
/// Example 3:
/// >>> maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1)
/// vec![2]
/// Note:
/// 1. The length of the vector will be in the range of [1, 1000].
/// 2. The elements in the vector will be in the range of [-1000, 1000].
/// 3. 0 <= k <= len(arr)
fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {

===============================
-----------------------------
/// Given a vector arr of integers and a positive integer k, return a sorted vector 
/// of length k with the maximum k numbers in arr.
/// Example 1:
/// >>> maximum(vec![-3, -4, 5], 3)
/// vec![-4, -3, 5]
/// Example 2:
/// >>> maximum(vec![4, -4, 4], 2)
/// vec![4, 4]
/// Example 3:
/// >>> maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1)
/// vec![2]
/// Note:
/// 1. The length of the vector will be in the range of [1, 1000].
/// 2. The elements in the vector will be in the range of [-1000, 1000].
/// 3. 0 <= k <= len(arr)
fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {

    if k == 0 || arr.len() == 0 {
        return Vec::new();
    }
    if k == 1 {
        return arr;
    }
    let mut max_arr = vec![isize::MIN; k as usize];
    let mut i = 0;
    for num in arr {
        let last_i = max_arr.len() - 1;
        if i < k as usize && max_arr[last_i] < num {
            max_arr[last_i] = num;
        } else {
            let mut max_num = max_arr[0];
            let mut max_index = 0;
            for j in 0..k as usize {
                if max_arr[j] > max_num {
                    max_num = max_arr[j];
                    max_index = j;
                }
            }
            if num > max_num {
                max_arr[max_index] = num;
            }
        }
        i += 1;
    }
    max_arr
}

fn main() {
    let candidate = maximum;
    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);
    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);
    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);
    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);
    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);
    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);
    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3, 5]);
    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);
    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);
    assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);
    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());
}

-----------------------------
/// Given a vector arr of integers and a positive integer k, return a sorted vector 
/// of length k with the maximum k numbers in arr.
/// Example 1:
/// >>> maximum(vec![-3, -4, 5], 3)
/// vec![-4, -3, 5]
/// Example 2:
/// >>> maximum(vec![4, -4, 4], 2)
/// vec![4, 4]
/// Example 3:
/// >>> maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1)
/// vec![2]
/// Note:
/// 1. The length of the vector will be in the range of [1, 1000].
/// 2. The elements in the vector will be in the range of [-1000, 1000].
/// 3. 0 <= k <= len(arr)
fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {

    if k <= 0 {
        return vec![];
    }
    let mut heap = BinaryHeap::new();
    for x in arr {
        if heap.len() < k as usize {
            heap.push(x);
        } else if x > *heap.peek().unwrap() {
            heap.pop();
            heap.push(x);
        }
    }
    let mut res = vec![];
    while let Some(x) = heap.pop() {
        res.push(x);
    }
    res
}

fn main() {
    let candidate = maximum;
    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);
    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);
    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);
    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);
    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);
    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);
    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3, 5]);
    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);
    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);
    assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);
    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());
}

-----------------------------
/// Given a vector arr of integers and a positive integer k, return a sorted vector 
/// of length k with the maximum k numbers in arr.
/// Example 1:
/// >>> maximum(vec![-3, -4, 5], 3)
/// vec![-4, -3, 5]
/// Example 2:
/// >>> maximum(vec![4, -4, 4], 2)
/// vec![4, 4]
/// Example 3:
/// >>> maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1)
/// vec![2]
/// Note:
/// 1. The length of the vector will be in the range of [1, 1000].
/// 2. The elements in the vector will be in the range of [-1000, 1000].
/// 3. 0 <= k <= len(arr)
fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {

    // write code here
    let k = k as usize;
    let len = arr.len();
    let mut max_nums: Vec<isize> = Vec::with_capacity(k);
    for i in 0..k {
        max_nums.push(i32::min_value());
    }
    let mut left = 0;
    let mut right = k - 1;
    for i in 0..len {
        while right < k - 1 && arr[i] > max_nums[right + 1] {
            right += 1;
        }
        max_nums[left] = arr[i];
        left += 1;
        while left < k && left < len && arr[i] < max_nums[left] {
            max_nums[right] = max_nums[left];
            right -= 1;
            left += 1;
        }
    }
    max_nums
}

fn main() {
    let candidate = maximum;
    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);
    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);
    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);
    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);
    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);
    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);
    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3, 5]);
    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);
    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);
    assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);
    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());
}

-----------------------------
/// Given a vector arr of integers and a positive integer k, return a sorted vector 
/// of length k with the maximum k numbers in arr.
/// Example 1:
/// >>> maximum(vec![-3, -4, 5], 3)
/// vec![-4, -3, 5]
/// Example 2:
/// >>> maximum(vec![4, -4, 4], 2)
/// vec![4, 4]
/// Example 3:
/// >>> maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1)
/// vec![2]
/// Note:
/// 1. The length of the vector will be in the range of [1, 1000].
/// 2. The elements in the vector will be in the range of [-1000, 1000].
/// 3. 0 <= k <= len(arr)
fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {

    let k = k as usize;
    let mut arr = arr;
    let mut temp_arr = vec![];
    let mut count = 1;
    arr.sort_by(|a, b| b.cmp(a));
    arr.iter().for_each(|x| {
        temp_arr.push(x.clone());
        count += 1;
        if count > k {
            count = 1;
            temp_arr.clear();
        }
    });
    temp_arr.sort_by(|a, b| a.cmp(b));
    temp_arr
}

fn main() {
    let candidate = maximum;
    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);
    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);
    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);
    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);
    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);
    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);
    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3, 5]);
    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);
    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);
    assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);
    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());
}

-----------------------------
/// Given a vector arr of integers and a positive integer k, return a sorted vector 
/// of length k with the maximum k numbers in arr.
/// Example 1:
/// >>> maximum(vec![-3, -4, 5], 3)
/// vec![-4, -3, 5]
/// Example 2:
/// >>> maximum(vec![4, -4, 4], 2)
/// vec![4, 4]
/// Example 3:
/// >>> maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1)
/// vec![2]
/// Note:
/// 1. The length of the vector will be in the range of [1, 1000].
/// 2. The elements in the vector will be in the range of [-1000, 1000].
/// 3. 0 <= k <= len(arr)
fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {

    let n = arr.len();
    if k == 0 || k as usize > n {
        return vec![];
    }
    let mut res = vec![arr[0]];
    let mut max_heap = vec![arr[0]];
    for i in 1..k as usize {
        let cur = arr[i];
        max_heap.push(cur);
        if max_heap.len() == 2 * i + 2 {
            let mut max = max_heap.pop().unwrap();
            if max == cur {
                max = max_heap.pop().unwrap();
            }
            max_heap.push(max);
        }
    }
    for i in k as usize..n {
        if arr[i] > max_heap[0] {
            max_heap.pop();
            max_heap.push(arr[i]);
            if max_heap.len() == 2 * (i - k + 1) + 1 {
                let mut max = max_heap.pop().unwrap();
                if max == arr[i] {
                    max = max_heap.pop().unwrap();
                }
                max_heap.push(max);
            }
        }
    }
    res.extend(max_heap);
    res.sort();
    res
}

fn main() {
    let candidate = maximum;
    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);
    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);
    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);
    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);
    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);
    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);
    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3, 5]);
    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);
    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);
    assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);
    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());
}

===============================
/// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.
/// Examples
/// >>> solution(vec![5, 8, 7, 1])
/// 12
/// >>> solution(vec![3, 3, 3, 3, 3])
/// 9
/// >>> solution(vec![30, 13, 24, 321])
/// 0
fn solution(lst: Vec<isize>) -> isize {

===============================
-----------------------------
/// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.
/// Examples
/// >>> solution(vec![5, 8, 7, 1])
/// 12
/// >>> solution(vec![3, 3, 3, 3, 3])
/// 9
/// >>> solution(vec![30, 13, 24, 321])
/// 0
fn solution(lst: Vec<isize>) -> isize {

    lst.iter().enumerate()
        .filter(|&(&_, &x)| x % 2 == 1 && x % 2 == x.count_ones())
        .map(|(_, &x)| x).sum()
}

fn main() {
    let candidate = solution;
    assert_eq!(candidate(vec![5, 8, 7, 1]), 12);
    assert_eq!(candidate(vec![3, 3, 3, 3, 3]), 9);
    assert_eq!(candidate(vec![30, 13, 24, 321]), 0);
    assert_eq!(candidate(vec![5, 9]), 5);
    assert_eq!(candidate(vec![2, 4, 8]), 0);
    assert_eq!(candidate(vec![30, 13, 23, 32]), 23);
    assert_eq!(candidate(vec![3, 13, 2, 9]), 3);
}

-----------------------------
/// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.
/// Examples
/// >>> solution(vec![5, 8, 7, 1])
/// 12
/// >>> solution(vec![3, 3, 3, 3, 3])
/// 9
/// >>> solution(vec![30, 13, 24, 321])
/// 0
fn solution(lst: Vec<isize>) -> isize {

    let len = lst.len();
    let mut sum: isize = 0;
    for i in (0..len).step_by(2) {
        sum += lst[i];
    }
    sum
}

fn main() {
    let candidate = solution;
    assert_eq!(candidate(vec![5, 8, 7, 1]), 12);
    assert_eq!(candidate(vec![3, 3, 3, 3, 3]), 9);
    assert_eq!(candidate(vec![30, 13, 24, 321]), 0);
    assert_eq!(candidate(vec![5, 9]), 5);
    assert_eq!(candidate(vec![2, 4, 8]), 0);
    assert_eq!(candidate(vec![30, 13, 23, 32]), 23);
    assert_eq!(candidate(vec![3, 13, 2, 9]), 3);
}

-----------------------------
/// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.
/// Examples
/// >>> solution(vec![5, 8, 7, 1])
/// 12
/// >>> solution(vec![3, 3, 3, 3, 3])
/// 9
/// >>> solution(vec![30, 13, 24, 321])
/// 0
fn solution(lst: Vec<isize>) -> isize {

    let mut ret = 0;
    for (idx, num) in lst.iter().enumerate() {
        if idx % 2 == 0 && num % 2 == 1 {
            ret += num
        }
    }
    ret
}

fn main() {
    let candidate = solution;
    assert_eq!(candidate(vec![5, 8, 7, 1]), 12);
    assert_eq!(candidate(vec![3, 3, 3, 3, 3]), 9);
    assert_eq!(candidate(vec![30, 13, 24, 321]), 0);
    assert_eq!(candidate(vec![5, 9]), 5);
    assert_eq!(candidate(vec![2, 4, 8]), 0);
    assert_eq!(candidate(vec![30, 13, 23, 32]), 23);
    assert_eq!(candidate(vec![3, 13, 2, 9]), 3);
}

-----------------------------
/// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.
/// Examples
/// >>> solution(vec![5, 8, 7, 1])
/// 12
/// >>> solution(vec![3, 3, 3, 3, 3])
/// 9
/// >>> solution(vec![30, 13, 24, 321])
/// 0
fn solution(lst: Vec<isize>) -> isize {

    if lst.len() == 0 {
        return 0;
    }
    let mut res = 0;
    for i in 0..lst.len() {
        if i % 2 == 0 && lst[i] % 2 == 1 {
            res += lst[i];
        }
    }
    res
}

fn main() {
    let candidate = solution;
    assert_eq!(candidate(vec![5, 8, 7, 1]), 12);
    assert_eq!(candidate(vec![3, 3, 3, 3, 3]), 9);
    assert_eq!(candidate(vec![30, 13, 24, 321]), 0);
    assert_eq!(candidate(vec![5, 9]), 5);
    assert_eq!(candidate(vec![2, 4, 8]), 0);
    assert_eq!(candidate(vec![30, 13, 23, 32]), 23);
    assert_eq!(candidate(vec![3, 13, 2, 9]), 3);
}

-----------------------------
/// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.
/// Examples
/// >>> solution(vec![5, 8, 7, 1])
/// 12
/// >>> solution(vec![3, 3, 3, 3, 3])
/// 9
/// >>> solution(vec![30, 13, 24, 321])
/// 0
fn solution(lst: Vec<isize>) -> isize {

    // Write your code here
    let mut total: isize = 0;
    for i in 0..lst.len() {
        if lst[i] % 2 == 1 && lst[i] != 0 {
            total += lst[i];
        }
    }

    return total;
}

fn main() {
    let candidate = solution;
    assert_eq!(candidate(vec![5, 8, 7, 1]), 12);
    assert_eq!(candidate(vec![3, 3, 3, 3, 3]), 9);
    assert_eq!(candidate(vec![30, 13, 24, 321]), 0);
    assert_eq!(candidate(vec![5, 9]), 5);
    assert_eq!(candidate(vec![2, 4, 8]), 0);
    assert_eq!(candidate(vec![30, 13, 23, 32]), 23);
    assert_eq!(candidate(vec![3, 13, 2, 9]), 3);
}

===============================
/// Given a non-empty vector of integers arr and an integer k, return
/// the sum of the elements with at most two digits from the first k elements of arr.
/// Example:
/// >>> add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)
/// 24
/// Constraints:
/// 1. 1 <= len(arr) <= 100
/// 2. 1 <= k <= len(arr)
fn add_elements(arr: Vec<isize>, k: isize) -> isize {

===============================
-----------------------------
/// Given a non-empty vector of integers arr and an integer k, return
/// the sum of the elements with at most two digits from the first k elements of arr.
/// Example:
/// >>> add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)
/// 24
/// Constraints:
/// 1. 1 <= len(arr) <= 100
/// 2. 1 <= k <= len(arr)
fn add_elements(arr: Vec<isize>, k: isize) -> isize {

    let k = k as usize;
    let mut nums = vec![0; 10];
    let mut n = 0;
    for i in 0..k {
        let v = arr[i];
        if v < 10 {
            nums[v as usize] += 1;
            n += 1;
        } else {
            nums[9] += 1;
            n += 10;
        }
    }
    let mut sum = 0;
    for i in 0..10 {
        sum += nums[i] * i as isize + (nums[i] - 1) * (i - 1) as isize / 2;
    }
    if n > 0 {
        sum += nums[9] * (n - k) as isize;
    }
    sum
}

fn main() {
    let candidate = add_elements;
    assert_eq!(candidate(vec![1, -2, -3, 41, 57, 76, 87, 88, 99], 3), -4);
    assert_eq!(candidate(vec![111, 121, 3, 4000, 5, 6], 2), 0);
    assert_eq!(candidate(vec![11, 21, 3, 90, 5, 6, 7, 8, 9], 4), 125);
    assert_eq!(candidate(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4), 24);
    assert_eq!(candidate(vec![1], 1), 1);
}

-----------------------------
/// Given a non-empty vector of integers arr and an integer k, return
/// the sum of the elements with at most two digits from the first k elements of arr.
/// Example:
/// >>> add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)
/// 24
/// Constraints:
/// 1. 1 <= len(arr) <= 100
/// 2. 1 <= k <= len(arr)
fn add_elements(arr: Vec<isize>, k: isize) -> isize {

    if k as usize == 0 {
        return 0;
    }
    let mut nums = vec![0; 10];
    for i in 0..arr.len() {
        if i < k as usize {
            let index = (arr[i] % 10) as usize;
            nums[index] += arr[i];
        }
    }

    let mut result = 0;
    for i in 0..nums.len() {
        result += nums[i];
    }
    result
}

fn main() {
    let candidate = add_elements;
    assert_eq!(candidate(vec![1, -2, -3, 41, 57, 76, 87, 88, 99], 3), -4);
    assert_eq!(candidate(vec![111, 121, 3, 4000, 5, 6], 2), 0);
    assert_eq!(candidate(vec![11, 21, 3, 90, 5, 6, 7, 8, 9], 4), 125);
    assert_eq!(candidate(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4), 24);
    assert_eq!(candidate(vec![1], 1), 1);
}

-----------------------------
/// Given a non-empty vector of integers arr and an integer k, return
/// the sum of the elements with at most two digits from the first k elements of arr.
/// Example:
/// >>> add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)
/// 24
/// Constraints:
/// 1. 1 <= len(arr) <= 100
/// 2. 1 <= k <= len(arr)
fn add_elements(arr: Vec<isize>, k: isize) -> isize {

    let k = k as usize;
    let arr = arr.iter().take(k);
    arr.filter(|&x| x >= 0 && x < 10)
        .fold(0, |acc, x| acc + x)
}

fn main() {
    let candidate = add_elements;
    assert_eq!(candidate(vec![1, -2, -3, 41, 57, 76, 87, 88, 99], 3), -4);
    assert_eq!(candidate(vec![111, 121, 3, 4000, 5, 6], 2), 0);
    assert_eq!(candidate(vec![11, 21, 3, 90, 5, 6, 7, 8, 9], 4), 125);
    assert_eq!(candidate(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4), 24);
    assert_eq!(candidate(vec![1], 1), 1);
}

-----------------------------
/// Given a non-empty vector of integers arr and an integer k, return
/// the sum of the elements with at most two digits from the first k elements of arr.
/// Example:
/// >>> add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)
/// 24
/// Constraints:
/// 1. 1 <= len(arr) <= 100
/// 2. 1 <= k <= len(arr)
fn add_elements(arr: Vec<isize>, k: isize) -> isize {

    if k == 0 {
        return 0;
    }
    let k = k as usize;
    let mut result = 0;
    let mut count = 0;
    for i in 0..arr.len() {
        if i < k {
            count += 1;
        }
        let n = arr[i] as u32;
        let digit = n % 10;
        if count < 3 {
            result += digit as isize;
        }
        if count == 3 && digit != 0 {
            break;
        }
    }
    result
}

fn main() {
    let candidate = add_elements;
    assert_eq!(candidate(vec![1, -2, -3, 41, 57, 76, 87, 88, 99], 3), -4);
    assert_eq!(candidate(vec![111, 121, 3, 4000, 5, 6], 2), 0);
    assert_eq!(candidate(vec![11, 21, 3, 90, 5, 6, 7, 8, 9], 4), 125);
    assert_eq!(candidate(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4), 24);
    assert_eq!(candidate(vec![1], 1), 1);
}

-----------------------------
/// Given a non-empty vector of integers arr and an integer k, return
/// the sum of the elements with at most two digits from the first k elements of arr.
/// Example:
/// >>> add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)
/// 24
/// Constraints:
/// 1. 1 <= len(arr) <= 100
/// 2. 1 <= k <= len(arr)
fn add_elements(arr: Vec<isize>, k: isize) -> isize {

    use std::cmp::Ordering::*;
    let k = k as usize;
    arr.iter().take(k).fold(0, |acc, x| match x.cmp(&9) {
        Equal => acc,
        Less => acc + x,
        Greater => acc + x.rem_euclid(10),
    })
}

fn main() {
    let candidate = add_elements;
    assert_eq!(candidate(vec![1, -2, -3, 41, 57, 76, 87, 88, 99], 3), -4);
    assert_eq!(candidate(vec![111, 121, 3, 4000, 5, 6], 2), 0);
    assert_eq!(candidate(vec![11, 21, 3, 90, 5, 6, 7, 8, 9], 4), 125);
    assert_eq!(candidate(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4), 24);
    assert_eq!(candidate(vec![1], 1), 1);
}

===============================
/// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.
/// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined
/// as follows: start with any positive integer n. Then each term is obtained from the 
/// previous term as follows: if the previous term is even, the next term is one half of 
/// the previous term. If the previous term is odd, the next term is 3 times the previous
/// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.
/// Note: 
/// 1. Collatz(1) is [1].
/// 2. returned vector sorted in increasing order.
/// For example:
/// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.
/// >>> get_odd_collatz(5)
/// vec![1, 5]
fn get_odd_collatz(n: isize) -> Vec<isize> {

===============================
-----------------------------
/// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.
/// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined
/// as follows: start with any positive integer n. Then each term is obtained from the 
/// previous term as follows: if the previous term is even, the next term is one half of 
/// the previous term. If the previous term is odd, the next term is 3 times the previous
/// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.
/// Note: 
/// 1. Collatz(1) is [1].
/// 2. returned vector sorted in increasing order.
/// For example:
/// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.
/// >>> get_odd_collatz(5)
/// vec![1, 5]
fn get_odd_collatz(n: isize) -> Vec<isize> {

    let mut num_vec: Vec<isize> = vec![];
    let mut num = n;

    while num != 1 {
        let temp = num;
        num = if temp % 2 == 0 { temp / 2 } else { 3 * temp + 1 };
        num_vec.push(num);
    }

    num_vec.sort_unstable();
    num_vec
}

fn main() {
    let candidate = get_odd_collatz;
    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);
    assert_eq!(candidate(5), vec![1, 5]);
    assert_eq!(candidate(12), vec![1, 3, 5]);
    assert_eq!(candidate(1), vec![1]);
}

-----------------------------
/// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.
/// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined
/// as follows: start with any positive integer n. Then each term is obtained from the 
/// previous term as follows: if the previous term is even, the next term is one half of 
/// the previous term. If the previous term is odd, the next term is 3 times the previous
/// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.
/// Note: 
/// 1. Collatz(1) is [1].
/// 2. returned vector sorted in increasing order.
/// For example:
/// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.
/// >>> get_odd_collatz(5)
/// vec![1, 5]
fn get_odd_collatz(n: isize) -> Vec<isize> {

    let mut collatz = vec![];
    let mut number = n;
    while number != 1 {
        if number % 2 == 0 {
            number /= 2;
            collatz.push(number);
        } else {
            number = number * 3 + 1;
            collatz.push(number);
        }
    }
    collatz
}

fn main() {
    let candidate = get_odd_collatz;
    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);
    assert_eq!(candidate(5), vec![1, 5]);
    assert_eq!(candidate(12), vec![1, 3, 5]);
    assert_eq!(candidate(1), vec![1]);
}

-----------------------------
/// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.
/// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined
/// as follows: start with any positive integer n. Then each term is obtained from the 
/// previous term as follows: if the previous term is even, the next term is one half of 
/// the previous term. If the previous term is odd, the next term is 3 times the previous
/// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.
/// Note: 
/// 1. Collatz(1) is [1].
/// 2. returned vector sorted in increasing order.
/// For example:
/// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.
/// >>> get_odd_collatz(5)
/// vec![1, 5]
fn get_odd_collatz(n: isize) -> Vec<isize> {

    let mut odd_collatz = Vec::new();

    while n > 1 {
        odd_collatz.push(n);
        if n % 2 == 0 {
            n = n / 2;
        } else {
            n = 3 * n + 1;
        }
    }
    odd_collatz
}

fn main() {
    let candidate = get_odd_collatz;
    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);
    assert_eq!(candidate(5), vec![1, 5]);
    assert_eq!(candidate(12), vec![1, 3, 5]);
    assert_eq!(candidate(1), vec![1]);
}

-----------------------------
/// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.
/// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined
/// as follows: start with any positive integer n. Then each term is obtained from the 
/// previous term as follows: if the previous term is even, the next term is one half of 
/// the previous term. If the previous term is odd, the next term is 3 times the previous
/// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.
/// Note: 
/// 1. Collatz(1) is [1].
/// 2. returned vector sorted in increasing order.
/// For example:
/// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.
/// >>> get_odd_collatz(5)
/// vec![1, 5]
fn get_odd_collatz(n: isize) -> Vec<isize> {

    if n == 1 {
        return vec![1];
    }
    let mut v: Vec<isize> = vec![];
    let mut s = 1;
    let mut f = 1;
    while s != 1 {
        if n % 2 == 0 {
            s = s * 2;
            v.push(s);
        } else {
            f = f * 3 + 1;
            s = f * 3 + 1;
            v.push(s);
        }
    }
    v
}

fn main() {
    let candidate = get_odd_collatz;
    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);
    assert_eq!(candidate(5), vec![1, 5]);
    assert_eq!(candidate(12), vec![1, 3, 5]);
    assert_eq!(candidate(1), vec![1]);
}

-----------------------------
/// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.
/// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined
/// as follows: start with any positive integer n. Then each term is obtained from the 
/// previous term as follows: if the previous term is even, the next term is one half of 
/// the previous term. If the previous term is odd, the next term is 3 times the previous
/// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.
/// Note: 
/// 1. Collatz(1) is [1].
/// 2. returned vector sorted in increasing order.
/// For example:
/// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.
/// >>> get_odd_collatz(5)
/// vec![1, 5]
fn get_odd_collatz(n: isize) -> Vec<isize> {

    let mut seq = vec![];
    for i in 1..=n {
        let mut cur = i;
        while cur != 1 {
            if cur % 2 == 0 {
                cur = cur / 2;
            } else {
                cur = 3 * cur + 1;
            }
            if cur % 2 != 0 {
                seq.push(cur);
            }
        }
    }
    seq.sort();
    seq
}

fn main() {
    let candidate = get_odd_collatz;
    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);
    assert_eq!(candidate(5), vec![1, 5]);
    assert_eq!(candidate(12), vec![1, 3, 5]);
    assert_eq!(candidate(1), vec![1]);
}

===============================
/// You have to write a function which validates a given date string and
/// returns true if the date is valid otherwise false.
/// The date is valid if all of the following rules are satisfied:
/// 1. The date string is not empty.
/// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
/// 3. The months should not be less than 1 or higher than 12.
/// 4. The date should be in the format: mm-dd-yyyy
/// >>> valid_date(String::from("03-11-2000"))
/// true
/// >>> valid_date(String::from("15-01-2012"))
/// false
/// >>> valid_date(String::from("04-0-2040"))
/// false
/// >>> valid_date(String::from("06-04-2020"))
/// true
/// >>> valid_date(String::from("06/04/2020"))
/// false
fn valid_date(date: String) -> bool {

===============================
-----------------------------
/// You have to write a function which validates a given date string and
/// returns true if the date is valid otherwise false.
/// The date is valid if all of the following rules are satisfied:
/// 1. The date string is not empty.
/// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
/// 3. The months should not be less than 1 or higher than 12.
/// 4. The date should be in the format: mm-dd-yyyy
/// >>> valid_date(String::from("03-11-2000"))
/// true
/// >>> valid_date(String::from("15-01-2012"))
/// false
/// >>> valid_date(String::from("04-0-2040"))
/// false
/// >>> valid_date(String::from("06-04-2020"))
/// true
/// >>> valid_date(String::from("06/04/2020"))
/// false
fn valid_date(date: String) -> bool {

    // your code goes here
    let date = date.split('-').collect::<Vec<&str>>();
    if date.len() != 3 {
        return false;
    }

    let month = date[0].parse::<i32>().unwrap();
    let day = date[1].parse::<i32>().unwrap();
    let year = date[2].parse::<i32>().unwrap();

    if month < 1 || month > 12 {
        return false;
    }

    if day < 1 || day > 31 {
        return false;
    }

    if year < 1900 || year > 2100 {
        return false;
    }

    let is_leap_year = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
    if is_leap_year && month == 2 && day > 29 {
        return false;
    }

    let month_days = match month {
        1 => 31,
        2 => 28,
        3 => 31,
        4 => 30,
        5 => 31,
        6 => 30,
        7 => 31,
        8 => 31,
        9 => 30,
        10 => 31,
        11 => 30,
        12 => 31,
        _ => 0,
    };

    if month_days < day {
        return false;
    }

    return true;
}

fn main() {
    let candidate = valid_date;
    assert_eq!(candidate(String::from("03-11-2000")), true);
    assert_eq!(candidate(String::from("15-01-2012")), false);
    assert_eq!(candidate(String::from("04-0-2040")), false);
    assert_eq!(candidate(String::from("06-04-2020")), true);
    assert_eq!(candidate(String::from("01-01-2007")), true);
    assert_eq!(candidate(String::from("03-32-2011")), false);
    assert_eq!(candidate(String::from("")), false);
    assert_eq!(candidate(String::from("04-31-3000")), false);
    assert_eq!(candidate(String::from("06-06-2005")), true);
    assert_eq!(candidate(String::from("21-31-2000")), false);
    assert_eq!(candidate(String::from("04-12-2003")), true);
    assert_eq!(candidate(String::from("04122003")), false);
    assert_eq!(candidate(String::from("20030412")), false);
    assert_eq!(candidate(String::from("2003-04")), false);
    assert_eq!(candidate(String::from("2003-04-12")), false);
    assert_eq!(candidate(String::from("04-2003")), false);
}

-----------------------------
/// You have to write a function which validates a given date string and
/// returns true if the date is valid otherwise false.
/// The date is valid if all of the following rules are satisfied:
/// 1. The date string is not empty.
/// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
/// 3. The months should not be less than 1 or higher than 12.
/// 4. The date should be in the format: mm-dd-yyyy
/// >>> valid_date(String::from("03-11-2000"))
/// true
/// >>> valid_date(String::from("15-01-2012"))
/// false
/// >>> valid_date(String::from("04-0-2040"))
/// false
/// >>> valid_date(String::from("06-04-2020"))
/// true
/// >>> valid_date(String::from("06/04/2020"))
/// false
fn valid_date(date: String) -> bool {

    if date == "" {
        return false;
    }
    let mut split_date: Vec<&str> = date.split('-').collect();
    if split_date.len() != 3 {
        return false;
    }
    let day_string = split_date[1];
    let day = day_string.parse::<i32>();
    let day_is_valid = day.is_ok() && day.unwrap() >= 1 && day.unwrap() <= 31;
    if !day_is_valid {
        return false;
    }
    let month_string = split_date[0];
    let month = month_string.parse::<i32>();
    let month_is_valid = month.is_ok() && month.unwrap() >= 1 && month.unwrap() <= 12;
    if !month_is_valid {
        return false;
    }
    let year = split_date[2].parse::<i32>();
    let year_is_valid = year.is_ok() && year.unwrap() >= 1;
    if !year_is_valid {
        return false;
    }
    if day_is_valid && month_is_valid && year_is_valid {
        return true;
    }
    return false;
}

fn main() {
    let candidate = valid_date;
    assert_eq!(candidate(String::from("03-11-2000")), true);
    assert_eq!(candidate(String::from("15-01-2012")), false);
    assert_eq!(candidate(String::from("04-0-2040")), false);
    assert_eq!(candidate(String::from("06-04-2020")), true);
    assert_eq!(candidate(String::from("01-01-2007")), true);
    assert_eq!(candidate(String::from("03-32-2011")), false);
    assert_eq!(candidate(String::from("")), false);
    assert_eq!(candidate(String::from("04-31-3000")), false);
    assert_eq!(candidate(String::from("06-06-2005")), true);
    assert_eq!(candidate(String::from("21-31-2000")), false);
    assert_eq!(candidate(String::from("04-12-2003")), true);
    assert_eq!(candidate(String::from("04122003")), false);
    assert_eq!(candidate(String::from("20030412")), false);
    assert_eq!(candidate(String::from("2003-04")), false);
    assert_eq!(candidate(String::from("2003-04-12")), false);
    assert_eq!(candidate(String::from("04-2003")), false);
}

-----------------------------
/// You have to write a function which validates a given date string and
/// returns true if the date is valid otherwise false.
/// The date is valid if all of the following rules are satisfied:
/// 1. The date string is not empty.
/// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
/// 3. The months should not be less than 1 or higher than 12.
/// 4. The date should be in the format: mm-dd-yyyy
/// >>> valid_date(String::from("03-11-2000"))
/// true
/// >>> valid_date(String::from("15-01-2012"))
/// false
/// >>> valid_date(String::from("04-0-2040"))
/// false
/// >>> valid_date(String::from("06-04-2020"))
/// true
/// >>> valid_date(String::from("06/04/2020"))
/// false
fn valid_date(date: String) -> bool {

    let re = Regex::new(r"^(((0[1-9]|[12]\d|3[01])-(0[13578]|1[02])|((0[1-9]|[12]\d|30)-(0[13456789]|1[012]))-|(0[1-9]|1\d|2[0-8])-02-)(19|[2-9]\d)\d{2})|(((0[1-9]|[12]\d|30)-(0[13456789]|1[012]))-((19|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))|(0[1-9]|1\d|2[0-8])-02-((19|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))|((29-02-((19|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$").unwrap();
    re.is_match(&date)
}

fn main() {
    let candidate = valid_date;
    assert_eq!(candidate(String::from("03-11-2000")), true);
    assert_eq!(candidate(String::from("15-01-2012")), false);
    assert_eq!(candidate(String::from("04-0-2040")), false);
    assert_eq!(candidate(String::from("06-04-2020")), true);
    assert_eq!(candidate(String::from("01-01-2007")), true);
    assert_eq!(candidate(String::from("03-32-2011")), false);
    assert_eq!(candidate(String::from("")), false);
    assert_eq!(candidate(String::from("04-31-3000")), false);
    assert_eq!(candidate(String::from("06-06-2005")), true);
    assert_eq!(candidate(String::from("21-31-2000")), false);
    assert_eq!(candidate(String::from("04-12-2003")), true);
    assert_eq!(candidate(String::from("04122003")), false);
    assert_eq!(candidate(String::from("20030412")), false);
    assert_eq!(candidate(String::from("2003-04")), false);
    assert_eq!(candidate(String::from("2003-04-12")), false);
    assert_eq!(candidate(String::from("04-2003")), false);
}

-----------------------------
/// You have to write a function which validates a given date string and
/// returns true if the date is valid otherwise false.
/// The date is valid if all of the following rules are satisfied:
/// 1. The date string is not empty.
/// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
/// 3. The months should not be less than 1 or higher than 12.
/// 4. The date should be in the format: mm-dd-yyyy
/// >>> valid_date(String::from("03-11-2000"))
/// true
/// >>> valid_date(String::from("15-01-2012"))
/// false
/// >>> valid_date(String::from("04-0-2040"))
/// false
/// >>> valid_date(String::from("06-04-2020"))
/// true
/// >>> valid_date(String::from("06/04/2020"))
/// false
fn valid_date(date: String) -> bool {

    // check that the length is correct
    if date.len() != 10 {
        return false;
    }
    // check the format
    if !(date.chars().nth(2) == Some('-') && date.chars().nth(5) == Some('-')) {
        return false;
    }
    // check the month
    let month_str = &date[0..2];
    let month = month_str.parse::<i32>();
    if month.is_err() || month.unwrap() < 1 || month.unwrap() > 12 {
        return false;
    }
    // check the day
    let day_str = &date[3..5];
    let day = day_str.parse::<i32>();
    if day.is_err() {
        return false;
    }
    let month = month.unwrap();
    if month == 4 || month == 6 || month == 9 || month == 11 {
        // the month has only 30 days
        if day.unwrap() < 1 || day.unwrap() > 30 {
            return false;
        }
    } else if month == 2 {
        // february has 28 days
        if day.unwrap() < 1 || day.unwrap() > 28 {
            return false;
        }
    } else {
        // the month has 31 days
        if day.unwrap() < 1 || day.unwrap() > 31 {
            return false;
        }
    }
    // if all checks are successful then the date is valid
    true
}

fn main() {
    let candidate = valid_date;
    assert_eq!(candidate(String::from("03-11-2000")), true);
    assert_eq!(candidate(String::from("15-01-2012")), false);
    assert_eq!(candidate(String::from("04-0-2040")), false);
    assert_eq!(candidate(String::from("06-04-2020")), true);
    assert_eq!(candidate(String::from("01-01-2007")), true);
    assert_eq!(candidate(String::from("03-32-2011")), false);
    assert_eq!(candidate(String::from("")), false);
    assert_eq!(candidate(String::from("04-31-3000")), false);
    assert_eq!(candidate(String::from("06-06-2005")), true);
    assert_eq!(candidate(String::from("21-31-2000")), false);
    assert_eq!(candidate(String::from("04-12-2003")), true);
    assert_eq!(candidate(String::from("04122003")), false);
    assert_eq!(candidate(String::from("20030412")), false);
    assert_eq!(candidate(String::from("2003-04")), false);
    assert_eq!(candidate(String::from("2003-04-12")), false);
    assert_eq!(candidate(String::from("04-2003")), false);
}

-----------------------------
/// You have to write a function which validates a given date string and
/// returns true if the date is valid otherwise false.
/// The date is valid if all of the following rules are satisfied:
/// 1. The date string is not empty.
/// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
/// 3. The months should not be less than 1 or higher than 12.
/// 4. The date should be in the format: mm-dd-yyyy
/// >>> valid_date(String::from("03-11-2000"))
/// true
/// >>> valid_date(String::from("15-01-2012"))
/// false
/// >>> valid_date(String::from("04-0-2040"))
/// false
/// >>> valid_date(String::from("06-04-2020"))
/// true
/// >>> valid_date(String::from("06/04/2020"))
/// false
fn valid_date(date: String) -> bool {

    let date_array: Vec<&str> = date.split('-').collect();
    if date.is_empty() || date_array.len() != 3 {
        return false;
    }

    let year = date_array[2];
    let month = date_array[0];
    let day = date_array[1];

    let is_year_valid = year.parse::<u32>().is_ok();
    let is_month_valid = month.parse::<u32>().is_ok();
    let is_day_valid = day.parse::<u32>().is_ok();

    if !is_year_valid || !is_month_valid || !is_day_valid {
        return false;
    }

    let month: u32 = month.parse().unwrap();
    let day: u32 = day.parse().unwrap();
    let year: u32 = year.parse().unwrap();

    if month < 1 || month > 12 || day < 1 {
        return false;
    }

    match month {
        1 | 3 | 5 | 7 | 8 | 10 | 12 => {
            if day > 31 {
                return false;
            }
        }
        4 | 6 | 9 | 11 => {
            if day > 30 {
                return false;
            }
        }
        2 => {
            if year % 400 == 0 {
                if day > 29 {
                    return false;
                }
            } else if year % 100 == 0 {
                if day > 28 {
                    return false;
                }
            } else if year % 4 == 0 {
                if day > 29 {
                    return false;
                }
            } else {
                if day > 28 {
                    return false;
                }
            }
        }
        _ => (),
    }

    true
}

fn main() {
    let candidate = valid_date;
    assert_eq!(candidate(String::from("03-11-2000")), true);
    assert_eq!(candidate(String::from("15-01-2012")), false);
    assert_eq!(candidate(String::from("04-0-2040")), false);
    assert_eq!(candidate(String::from("06-04-2020")), true);
    assert_eq!(candidate(String::from("01-01-2007")), true);
    assert_eq!(candidate(String::from("03-32-2011")), false);
    assert_eq!(candidate(String::from("")), false);
    assert_eq!(candidate(String::from("04-31-3000")), false);
    assert_eq!(candidate(String::from("06-06-2005")), true);
    assert_eq!(candidate(String::from("21-31-2000")), false);
    assert_eq!(candidate(String::from("04-12-2003")), true);
    assert_eq!(candidate(String::from("04122003")), false);
    assert_eq!(candidate(String::from("20030412")), false);
    assert_eq!(candidate(String::from("2003-04")), false);
    assert_eq!(candidate(String::from("2003-04-12")), false);
    assert_eq!(candidate(String::from("04-2003")), false);
}

===============================
/// Given a vector of numbers, return whether or not they are sorted
/// in ascending order. If vector has more than 1 duplicate of the same
/// number, return false. Assume no negative numbers and only integers.
/// Examples
/// >>> is_sorted(vec![5])
/// true
/// >>> is_sorted(vec![1, 2, 3, 4, 5])
/// true
/// >>> is_sorted(vec![1, 3, 2, 4, 5])
/// false
/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6])
/// true
/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])
/// true
/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])
/// false
/// >>> is_sorted(vec![1, 2, 2, 3, 3, 4])
/// true
/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])
/// false
fn is_sorted(lst: Vec<isize>) -> bool {

===============================
-----------------------------
/// Given a vector of numbers, return whether or not they are sorted
/// in ascending order. If vector has more than 1 duplicate of the same
/// number, return false. Assume no negative numbers and only integers.
/// Examples
/// >>> is_sorted(vec![5])
/// true
/// >>> is_sorted(vec![1, 2, 3, 4, 5])
/// true
/// >>> is_sorted(vec![1, 3, 2, 4, 5])
/// false
/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6])
/// true
/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])
/// true
/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])
/// false
/// >>> is_sorted(vec![1, 2, 2, 3, 3, 4])
/// true
/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])
/// false
fn is_sorted(lst: Vec<isize>) -> bool {

    if lst.is_empty() {
        return true;
    }
    for (idx, item) in lst.iter().enumerate() {
        if idx != 0 && item < &lst[idx - 1] {
            return false;
        }
    }
    true
}

fn main() {
    let candidate = is_sorted;
    assert_eq!(candidate(vec![5]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);
    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);
    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, 7]), false);
    assert_eq!(candidate(Vec::<isize>::new()), true);
    assert_eq!(candidate(vec![1]), true);
    assert_eq!(candidate(vec![3, 2, 1]), false);
    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);
    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);
    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4]), true);
}

-----------------------------
/// Given a vector of numbers, return whether or not they are sorted
/// in ascending order. If vector has more than 1 duplicate of the same
/// number, return false. Assume no negative numbers and only integers.
/// Examples
/// >>> is_sorted(vec![5])
/// true
/// >>> is_sorted(vec![1, 2, 3, 4, 5])
/// true
/// >>> is_sorted(vec![1, 3, 2, 4, 5])
/// false
/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6])
/// true
/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])
/// true
/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])
/// false
/// >>> is_sorted(vec![1, 2, 2, 3, 3, 4])
/// true
/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])
/// false
fn is_sorted(lst: Vec<isize>) -> bool {

    let mut lst = lst;

    lst.sort_by(|a, b| a.cmp(b));

    for i in 1..lst.len() {
        if lst[i] == lst[i - 1] {
            return false;
        }
    }

    true
}

fn main() {
    let candidate = is_sorted;
    assert_eq!(candidate(vec![5]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);
    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);
    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, 7]), false);
    assert_eq!(candidate(Vec::<isize>::new()), true);
    assert_eq!(candidate(vec![1]), true);
    assert_eq!(candidate(vec![3, 2, 1]), false);
    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);
    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);
    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4]), true);
}

-----------------------------
/// Given a vector of numbers, return whether or not they are sorted
/// in ascending order. If vector has more than 1 duplicate of the same
/// number, return false. Assume no negative numbers and only integers.
/// Examples
/// >>> is_sorted(vec![5])
/// true
/// >>> is_sorted(vec![1, 2, 3, 4, 5])
/// true
/// >>> is_sorted(vec![1, 3, 2, 4, 5])
/// false
/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6])
/// true
/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])
/// true
/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])
/// false
/// >>> is_sorted(vec![1, 2, 2, 3, 3, 4])
/// true
/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])
/// false
fn is_sorted(lst: Vec<isize>) -> bool {

    for i in 1..lst.len() {
        if lst[i-1] > lst[i] {
            return false;
        }
    }
    true
}

fn main() {
    let candidate = is_sorted;
    assert_eq!(candidate(vec![5]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);
    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);
    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, 7]), false);
    assert_eq!(candidate(Vec::<isize>::new()), true);
    assert_eq!(candidate(vec![1]), true);
    assert_eq!(candidate(vec![3, 2, 1]), false);
    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);
    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);
    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4]), true);
}

-----------------------------
/// Given a vector of numbers, return whether or not they are sorted
/// in ascending order. If vector has more than 1 duplicate of the same
/// number, return false. Assume no negative numbers and only integers.
/// Examples
/// >>> is_sorted(vec![5])
/// true
/// >>> is_sorted(vec![1, 2, 3, 4, 5])
/// true
/// >>> is_sorted(vec![1, 3, 2, 4, 5])
/// false
/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6])
/// true
/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])
/// true
/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])
/// false
/// >>> is_sorted(vec![1, 2, 2, 3, 3, 4])
/// true
/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])
/// false
fn is_sorted(lst: Vec<isize>) -> bool {

    // write me!
    let len = lst.len();
    let mut sorted = true;
    let mut previous = lst[0];
    for item in lst {
        if item == previous {
            sorted = false;
            break;
        } else if item < previous {
            sorted = false;
            break;
        } else {
            previous = item;
        }
    }
    sorted
}

fn main() {
    let candidate = is_sorted;
    assert_eq!(candidate(vec![5]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);
    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);
    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, 7]), false);
    assert_eq!(candidate(Vec::<isize>::new()), true);
    assert_eq!(candidate(vec![1]), true);
    assert_eq!(candidate(vec![3, 2, 1]), false);
    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);
    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);
    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4]), true);
}

-----------------------------
/// Given a vector of numbers, return whether or not they are sorted
/// in ascending order. If vector has more than 1 duplicate of the same
/// number, return false. Assume no negative numbers and only integers.
/// Examples
/// >>> is_sorted(vec![5])
/// true
/// >>> is_sorted(vec![1, 2, 3, 4, 5])
/// true
/// >>> is_sorted(vec![1, 3, 2, 4, 5])
/// false
/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6])
/// true
/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])
/// true
/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])
/// false
/// >>> is_sorted(vec![1, 2, 2, 3, 3, 4])
/// true
/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])
/// false
fn is_sorted(lst: Vec<isize>) -> bool {

    if lst.len() <= 1 {
        return true;
    }
    let mut last_val = lst[0];
    for val in lst.iter().skip(1) {
        if val == &last_val {
            return false;
        }
        if val < &last_val {
            return false;
        }
        last_val = *val;
    }
    true
}

fn main() {
    let candidate = is_sorted;
    assert_eq!(candidate(vec![5]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);
    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);
    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, 7]), false);
    assert_eq!(candidate(Vec::<isize>::new()), true);
    assert_eq!(candidate(vec![1]), true);
    assert_eq!(candidate(vec![3, 2, 1]), false);
    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);
    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);
    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4]), true);
}

===============================
/// You are given two intervals,
/// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
/// The given intervals are closed which means that the interval (start, end)
/// includes both start and end.
/// For each given interval, it is assumed that its start is less or equal its end.
/// Your task is to determine whether the length of intersection of these two 
/// intervals is a prime number.
/// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
/// which its length is 1, which not a prime number.
/// If the length of the intersection is a prime number, return "YES",
/// otherwise, return "NO".
/// If the two intervals don't intersect, return "NO".
/// [input/output] samples:
/// >>> intersection((1, 2), (2, 3))
/// String::from("NO")
/// >>> intersection((-1, 1), (0, 4))
/// String::from("NO")
/// >>> intersection((-3, -1), (-5, 5))
/// String::from("YES")
fn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {

===============================
-----------------------------
/// You are given two intervals,
/// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
/// The given intervals are closed which means that the interval (start, end)
/// includes both start and end.
/// For each given interval, it is assumed that its start is less or equal its end.
/// Your task is to determine whether the length of intersection of these two 
/// intervals is a prime number.
/// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
/// which its length is 1, which not a prime number.
/// If the length of the intersection is a prime number, return "YES",
/// otherwise, return "NO".
/// If the two intervals don't intersect, return "NO".
/// [input/output] samples:
/// >>> intersection((1, 2), (2, 3))
/// String::from("NO")
/// >>> intersection((-1, 1), (0, 4))
/// String::from("NO")
/// >>> intersection((-3, -1), (-5, 5))
/// String::from("YES")
fn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {

    if interval1.0 > interval1.1 {
        interval1.0 = interval1.1;
        interval1.1 = interval1.0;
    }
    if interval2.0 > interval2.1 {
        interval2.0 = interval2.1;
        interval2.1 = interval2.0;
    }
    if interval1.1 < interval2.0 || interval1.0 > interval2.1 {
        return "NO".to_string();
    }

    let mut res: isize = 0;
    if interval1.0 <= interval2.0 {
        res = interval1.1 - interval2.0;
    } else {
        res = interval2.1 - interval1.0;
    }
    if is_prime(res) {
        "YES".to_string()
    } else {
        "NO".to_string()
    }
}

fn main() {
    let candidate = intersection;
    assert_eq!(candidate((1, 2), (2, 3)), String::from("NO"));
    assert_eq!(candidate((-1, 1), (0, 4)), String::from("NO"));
    assert_eq!(candidate((-3, -1), (-5, 5)), String::from("YES"));
    assert_eq!(candidate((-2, 2), (-4, 0)), String::from("YES"));
    assert_eq!(candidate((-11, 2), (-1, -1)), String::from("NO"));
    assert_eq!(candidate((1, 2), (3, 5)), String::from("NO"));
    assert_eq!(candidate((1, 2), (1, 2)), String::from("NO"));
    assert_eq!(candidate((-2, -2), (-3, -2)), String::from("NO"));
}

-----------------------------
/// You are given two intervals,
/// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
/// The given intervals are closed which means that the interval (start, end)
/// includes both start and end.
/// For each given interval, it is assumed that its start is less or equal its end.
/// Your task is to determine whether the length of intersection of these two 
/// intervals is a prime number.
/// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
/// which its length is 1, which not a prime number.
/// If the length of the intersection is a prime number, return "YES",
/// otherwise, return "NO".
/// If the two intervals don't intersect, return "NO".
/// [input/output] samples:
/// >>> intersection((1, 2), (2, 3))
/// String::from("NO")
/// >>> intersection((-1, 1), (0, 4))
/// String::from("NO")
/// >>> intersection((-3, -1), (-5, 5))
/// String::from("YES")
fn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {

    let (start1, end1) = interval1;
    let (start2, end2) = interval2;

    let length = (
        max(start1, start2),
        min(end1, end2)
    );

    if length.0 > length.1 {
        return String::from("NO");
    }

    let (start, end) = length;
    let length = end - start + 1;
    let mut is_prime = true;

    if start == 0 {
        is_prime = false;
    } else {
        for x in 2..=start {
            if start % x == 0 {
                is_prime = false;
                break;
            }
        }
    }

    if is_prime {
        for x in 2..=length {
            if length % x == 0 {
                is_prime = false;
                break;
            }
        }
    }

    if is_prime {
        return String::from("YES");
    }

    String::from("NO")
}

fn main() {
    let candidate = intersection;
    assert_eq!(candidate((1, 2), (2, 3)), String::from("NO"));
    assert_eq!(candidate((-1, 1), (0, 4)), String::from("NO"));
    assert_eq!(candidate((-3, -1), (-5, 5)), String::from("YES"));
    assert_eq!(candidate((-2, 2), (-4, 0)), String::from("YES"));
    assert_eq!(candidate((-11, 2), (-1, -1)), String::from("NO"));
    assert_eq!(candidate((1, 2), (3, 5)), String::from("NO"));
    assert_eq!(candidate((1, 2), (1, 2)), String::from("NO"));
    assert_eq!(candidate((-2, -2), (-3, -2)), String::from("NO"));
}

-----------------------------
/// You are given two intervals,
/// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
/// The given intervals are closed which means that the interval (start, end)
/// includes both start and end.
/// For each given interval, it is assumed that its start is less or equal its end.
/// Your task is to determine whether the length of intersection of these two 
/// intervals is a prime number.
/// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
/// which its length is 1, which not a prime number.
/// If the length of the intersection is a prime number, return "YES",
/// otherwise, return "NO".
/// If the two intervals don't intersect, return "NO".
/// [input/output] samples:
/// >>> intersection((1, 2), (2, 3))
/// String::from("NO")
/// >>> intersection((-1, 1), (0, 4))
/// String::from("NO")
/// >>> intersection((-3, -1), (-5, 5))
/// String::from("YES")
fn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {

    let start = interval1.0.max(interval2.0);
    let end = interval1.1.min(interval2.1);
    if start > end {
        return String::from("NO");
    }
    let len = end - start + 1;
    if len.is_prime() {
        String::from("YES")
    } else {
        String::from("NO")
    }
}

fn main() {
    let candidate = intersection;
    assert_eq!(candidate((1, 2), (2, 3)), String::from("NO"));
    assert_eq!(candidate((-1, 1), (0, 4)), String::from("NO"));
    assert_eq!(candidate((-3, -1), (-5, 5)), String::from("YES"));
    assert_eq!(candidate((-2, 2), (-4, 0)), String::from("YES"));
    assert_eq!(candidate((-11, 2), (-1, -1)), String::from("NO"));
    assert_eq!(candidate((1, 2), (3, 5)), String::from("NO"));
    assert_eq!(candidate((1, 2), (1, 2)), String::from("NO"));
    assert_eq!(candidate((-2, -2), (-3, -2)), String::from("NO"));
}

-----------------------------
/// You are given two intervals,
/// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
/// The given intervals are closed which means that the interval (start, end)
/// includes both start and end.
/// For each given interval, it is assumed that its start is less or equal its end.
/// Your task is to determine whether the length of intersection of these two 
/// intervals is a prime number.
/// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
/// which its length is 1, which not a prime number.
/// If the length of the intersection is a prime number, return "YES",
/// otherwise, return "NO".
/// If the two intervals don't intersect, return "NO".
/// [input/output] samples:
/// >>> intersection((1, 2), (2, 3))
/// String::from("NO")
/// >>> intersection((-1, 1), (0, 4))
/// String::from("NO")
/// >>> intersection((-3, -1), (-5, 5))
/// String::from("YES")
fn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {

    let mut is_prime = true;
    if interval1.1 < interval1.0 || interval2.1 < interval2.0 {
        return String::from("NO");
    }
    if interval1.0 <= interval2.0 && interval1.1 >= interval2.0 {
        return String::from("YES");
    }
    if interval1.0 >= interval2.0 && interval1.1 <= interval2.1 {
        return String::from("YES");
    }
    let mut intersection_start = interval1.0.max(interval2.0);
    let mut intersection_end = interval1.1.min(interval2.1);
    let length = intersection_end - intersection_start + 1;
    for i in 1..length {
        if length % i == 0 {
            is_prime = false;
        }
    }
    return if is_prime {
        String::from("YES")
    } else {
        String::from("NO")
    };
}

fn main() {
    let candidate = intersection;
    assert_eq!(candidate((1, 2), (2, 3)), String::from("NO"));
    assert_eq!(candidate((-1, 1), (0, 4)), String::from("NO"));
    assert_eq!(candidate((-3, -1), (-5, 5)), String::from("YES"));
    assert_eq!(candidate((-2, 2), (-4, 0)), String::from("YES"));
    assert_eq!(candidate((-11, 2), (-1, -1)), String::from("NO"));
    assert_eq!(candidate((1, 2), (3, 5)), String::from("NO"));
    assert_eq!(candidate((1, 2), (1, 2)), String::from("NO"));
    assert_eq!(candidate((-2, -2), (-3, -2)), String::from("NO"));
}

-----------------------------
/// You are given two intervals,
/// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
/// The given intervals are closed which means that the interval (start, end)
/// includes both start and end.
/// For each given interval, it is assumed that its start is less or equal its end.
/// Your task is to determine whether the length of intersection of these two 
/// intervals is a prime number.
/// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
/// which its length is 1, which not a prime number.
/// If the length of the intersection is a prime number, return "YES",
/// otherwise, return "NO".
/// If the two intervals don't intersect, return "NO".
/// [input/output] samples:
/// >>> intersection((1, 2), (2, 3))
/// String::from("NO")
/// >>> intersection((-1, 1), (0, 4))
/// String::from("NO")
/// >>> intersection((-3, -1), (-5, 5))
/// String::from("YES")
fn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {

    let intersection = max(interval1.0, interval2.0)..min(interval1.1, interval2.1);
    if intersection.is_empty() {
        return "NO".to_string();
    }
    let result = intersection.end - intersection.start;
    if result == 0 {
        return "NO".to_string();
    }
    if is_prime(result) {
        return "YES".to_string();
    }
    return "NO".to_string();
}

fn main() {
    let candidate = intersection;
    assert_eq!(candidate((1, 2), (2, 3)), String::from("NO"));
    assert_eq!(candidate((-1, 1), (0, 4)), String::from("NO"));
    assert_eq!(candidate((-3, -1), (-5, 5)), String::from("YES"));
    assert_eq!(candidate((-2, 2), (-4, 0)), String::from("YES"));
    assert_eq!(candidate((-11, 2), (-1, -1)), String::from("NO"));
    assert_eq!(candidate((1, 2), (3, 5)), String::from("NO"));
    assert_eq!(candidate((1, 2), (1, 2)), String::from("NO"));
    assert_eq!(candidate((-2, -2), (-3, -2)), String::from("NO"));
}

===============================
/// You are given a vector arr of integers and you need to return
/// sum of magnitudes of integers multiplied by product of all signs
/// of each number in the vector, represented by 1, -1 or 0.
/// Note: return None for empty arr.
/// Example:
/// >>> prod_signs(vec![1, 2, 2, -4])
/// Some(9)
/// >>> prod_signs(vec![0, 1])
/// Some(0)
/// >>> prod_signs(vec![])
/// None
fn prod_signs(arr: Vec<isize>) -> Option<isize> {

===============================
-----------------------------
/// You are given a vector arr of integers and you need to return
/// sum of magnitudes of integers multiplied by product of all signs
/// of each number in the vector, represented by 1, -1 or 0.
/// Note: return None for empty arr.
/// Example:
/// >>> prod_signs(vec![1, 2, 2, -4])
/// Some(9)
/// >>> prod_signs(vec![0, 1])
/// Some(0)
/// >>> prod_signs(vec![])
/// None
fn prod_signs(arr: Vec<isize>) -> Option<isize> {

    if arr.is_empty() {
        return None;
    }
    let prod_signs = arr.iter().fold(1, |acc, &x| acc * x.signum());
    let arr_magnitudes = arr.iter().map(|&x| x.abs()).collect::<Vec<_>>();
    let sum_magnitudes = arr_magnitudes.iter().sum::<isize>();
    Some(sum_magnitudes * prod_signs)
}

fn main() {
    let candidate = prod_signs;
    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));
    assert_eq!(candidate(vec![0, 1]), Some(0));
    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));
    assert_eq!(candidate(Vec::<isize>::new()), None);
    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));
    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));
    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));
    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));
}

-----------------------------
/// You are given a vector arr of integers and you need to return
/// sum of magnitudes of integers multiplied by product of all signs
/// of each number in the vector, represented by 1, -1 or 0.
/// Note: return None for empty arr.
/// Example:
/// >>> prod_signs(vec![1, 2, 2, -4])
/// Some(9)
/// >>> prod_signs(vec![0, 1])
/// Some(0)
/// >>> prod_signs(vec![])
/// None
fn prod_signs(arr: Vec<isize>) -> Option<isize> {

    if arr.len() == 0 {
        None
    } else {
        let mut res = 1;
        let mut prod = 1;
        let mut sign = 1;
        for i in arr {
            if i == 0 {
                res *= 0;
                sign = 1;
            } else if i < 0 {
                res *= -1;
                sign = -1;
            } else {
                res *= 1;
                sign = 1;
            }
            prod *= sign;
        }
        Some(res * prod)
    }
}

fn main() {
    let candidate = prod_signs;
    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));
    assert_eq!(candidate(vec![0, 1]), Some(0));
    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));
    assert_eq!(candidate(Vec::<isize>::new()), None);
    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));
    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));
    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));
    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));
}

-----------------------------
/// You are given a vector arr of integers and you need to return
/// sum of magnitudes of integers multiplied by product of all signs
/// of each number in the vector, represented by 1, -1 or 0.
/// Note: return None for empty arr.
/// Example:
/// >>> prod_signs(vec![1, 2, 2, -4])
/// Some(9)
/// >>> prod_signs(vec![0, 1])
/// Some(0)
/// >>> prod_signs(vec![])
/// None
fn prod_signs(arr: Vec<isize>) -> Option<isize> {

    let mut count_positive = 0;
    let mut count_negative = 0;
    let mut count_zero = 0;
    for i in arr.iter() {
        if i < &0 {
            count_negative += 1;
        } else if i > &0 {
            count_positive += 1;
        } else {
            count_zero += 1;
        }
    }
    let mut product = 1;
    if count_positive > 0 {
        product *= count_negative as isize;
    } else if count_negative > 0 {
        product *= count_positive as isize;
    }
    if count_positive > 0 && count_negative > 0 {
        if count_zero > 0 {
            return Some(0);
        } else {
            product *= 1;
        }
    } else if count_positive == 0 && count_negative == 0 {
        if count_zero > 0 {
            return Some(0);
        } else {
            product *= -1;
        }
    }
    return Some((arr.iter().map(|x| x.abs()).sum::<isize>()) * product);
}

fn main() {
    let candidate = prod_signs;
    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));
    assert_eq!(candidate(vec![0, 1]), Some(0));
    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));
    assert_eq!(candidate(Vec::<isize>::new()), None);
    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));
    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));
    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));
    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));
}

-----------------------------
/// You are given a vector arr of integers and you need to return
/// sum of magnitudes of integers multiplied by product of all signs
/// of each number in the vector, represented by 1, -1 or 0.
/// Note: return None for empty arr.
/// Example:
/// >>> prod_signs(vec![1, 2, 2, -4])
/// Some(9)
/// >>> prod_signs(vec![0, 1])
/// Some(0)
/// >>> prod_signs(vec![])
/// None
fn prod_signs(arr: Vec<isize>) -> Option<isize> {

    if arr.is_empty() {
        return None;
    }

    let mut product = 1;
    let mut signs: Vec<isize> = Vec::with_capacity(arr.len());
    for val in arr.iter() {
        let mut sign = 1;
        if *val == 0 {
            sign = 0;
        } else if *val < 0 {
            sign = -1;
        }
        product *= sign;
        signs.push(sign);
    }

    let mut sum = 0;
    for (a, sign) in arr.iter().zip(signs.iter()) {
        sum += a.abs() * sign;
    }

    Some(sum * product)
}

fn main() {
    let candidate = prod_signs;
    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));
    assert_eq!(candidate(vec![0, 1]), Some(0));
    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));
    assert_eq!(candidate(Vec::<isize>::new()), None);
    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));
    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));
    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));
    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));
}

-----------------------------
/// You are given a vector arr of integers and you need to return
/// sum of magnitudes of integers multiplied by product of all signs
/// of each number in the vector, represented by 1, -1 or 0.
/// Note: return None for empty arr.
/// Example:
/// >>> prod_signs(vec![1, 2, 2, -4])
/// Some(9)
/// >>> prod_signs(vec![0, 1])
/// Some(0)
/// >>> prod_signs(vec![])
/// None
fn prod_signs(arr: Vec<isize>) -> Option<isize> {

    if arr.len() == 0 {
        return None;
    }
    let mut prod = 1;
    let mut sum = 0;
    for &x in arr.iter() {
        if x == 0 {
            return Some(0);
        } else if x > 0 {
            prod *= 1;
            sum += x;
        } else {
            prod *= -1;
            sum += -x;
        }
    }
    Some(sum * prod)
}

fn main() {
    let candidate = prod_signs;
    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));
    assert_eq!(candidate(vec![0, 1]), Some(0));
    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));
    assert_eq!(candidate(Vec::<isize>::new()), None);
    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));
    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));
    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));
    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));
}

===============================
/// Given a grid with N rows and N columns (N >= 2) and a positive integer k, 
/// each cell of the grid contains a value. Every integer in the range [1, N * N]
/// inclusive appears exactly once on the cells of the grid.
/// You have to find the minimum path of length k in the grid. You can start
/// from any cell, and in each step you can move to any of the neighbor cells,
/// in other words, you can go to cells which share an edge with you current
/// cell.
/// Please note that a path of length k means visiting exactly k cells (not
/// necessarily distinct).
/// You CANNOT go off the grid.
/// A path A (of length k) is considered less than a path B (of length k) if
/// after making the ordered vectors of the values on the cells that A and B go
/// through (let's call them lst_A and lst_B), lst_A is lexicographically less
/// than lst_B, in other words, there exist an integer index i (1 <= i <= k)
/// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have
/// lst_A[j] = lst_B[j].
/// It is guaranteed that the answer is unique.
/// Return an ordered vector of the values on the cells that the minimum path go through.
/// Examples:    
/// >>> minPath(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3)
/// vec![1, 2, 1]
/// >>> minPath(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1)
/// vec![1]
fn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {

===============================
-----------------------------
/// Given a grid with N rows and N columns (N >= 2) and a positive integer k, 
/// each cell of the grid contains a value. Every integer in the range [1, N * N]
/// inclusive appears exactly once on the cells of the grid.
/// You have to find the minimum path of length k in the grid. You can start
/// from any cell, and in each step you can move to any of the neighbor cells,
/// in other words, you can go to cells which share an edge with you current
/// cell.
/// Please note that a path of length k means visiting exactly k cells (not
/// necessarily distinct).
/// You CANNOT go off the grid.
/// A path A (of length k) is considered less than a path B (of length k) if
/// after making the ordered vectors of the values on the cells that A and B go
/// through (let's call them lst_A and lst_B), lst_A is lexicographically less
/// than lst_B, in other words, there exist an integer index i (1 <= i <= k)
/// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have
/// lst_A[j] = lst_B[j].
/// It is guaranteed that the answer is unique.
/// Return an ordered vector of the values on the cells that the minimum path go through.
/// Examples:    
/// >>> minPath(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3)
/// vec![1, 2, 1]
/// >>> minPath(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1)
/// vec![1]
fn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {

    let (m, n) = (grid.len(), grid[0].len());
    let mut graph = Graph::new(m * n + 1);
    let mut start = 0;
    for i in 0..m {
        for j in 0..n {
            let index = i * n + j;
            if i != 0 {
                graph.add_edge(index, index - n);
            }
            if j != 0 {
                graph.add_edge(index, index - 1);
            }
            if i != m - 1 {
                graph.add_edge(index, index + n);
            }
            if j != n - 1 {
                graph.add_edge(index, index + 1);
            }
        }
    }
    let mut value = vec![0; m * n];
    for (i, v) in grid.into_iter().flatten().enumerate() {
        value[i] = v;
    }
    let end = (m * n) as isize;
    let mut dist = vec![isize::MAX; m * n];
    let mut prev = vec![0; m * n];
    for i in 0..m * n {
        dist[i] = value[i];
        prev[i] = -1;
    }
    let mut path = vec![];
    let mut v = start;
    for _ in 0..k {
        let mut min = isize::MAX;
        let mut next = 0;
        for neighbor in graph.edges[v].iter() {
            if dist[*neighbor] < min {
                min = dist[*neighbor];
                next = *neighbor;
            }
        }
        path.push(v);
        dist[v] = min;
        prev[v] = next;
        v = next;
    }
    let mut res = vec![0; k as usize];
    for i in 0..k as usize {
        res[i] = value[path[k - i - 1]];
    }
    res
}

fn main() {
    let candidate = minPath;
    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3), vec![1, 2, 1]);
    assert_eq!(candidate(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1), vec![1]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4], vec![5, 6, 7, 8], vec![9, 10, 11, 12], vec![13, 14, 15, 16]], 4), vec![1, 2, 1, 2]);
    assert_eq!(candidate(vec![vec![6, 4, 13, 10], vec![5, 7, 12, 1], vec![3, 16, 11, 15], vec![8, 14, 9, 2]], 7), vec![1, 10, 1, 10, 1, 10, 1]);
    assert_eq!(candidate(vec![vec![8, 14, 9, 2], vec![6, 4, 13, 15], vec![5, 7, 1, 12], vec![3, 10, 11, 16]], 5), vec![1, 7, 1, 7, 1]);
    assert_eq!(candidate(vec![vec![11, 8, 7, 2], vec![5, 16, 14, 4], vec![9, 3, 15, 6], vec![12, 13, 10, 1]], 9), vec![1, 6, 1, 6, 1, 6, 1, 6, 1]);
    assert_eq!(candidate(vec![vec![12, 13, 10, 1], vec![9, 3, 15, 6], vec![5, 16, 14, 4], vec![11, 8, 7, 2]], 12), vec![1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);
    assert_eq!(candidate(vec![vec![2, 7, 4], vec![3, 1, 5], vec![6, 8, 9]], 8), vec![1, 3, 1, 3, 1, 3, 1, 3]);
    assert_eq!(candidate(vec![vec![6, 1, 5], vec![3, 8, 9], vec![2, 7, 4]], 8), vec![1, 5, 1, 5, 1, 5, 1, 5]);
    assert_eq!(candidate(vec![vec![1, 2], vec![3, 4]], 10), vec![1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);
    assert_eq!(candidate(vec![vec![1, 3], vec![3, 2]], 10), vec![1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);
}

-----------------------------
/// Given a grid with N rows and N columns (N >= 2) and a positive integer k, 
/// each cell of the grid contains a value. Every integer in the range [1, N * N]
/// inclusive appears exactly once on the cells of the grid.
/// You have to find the minimum path of length k in the grid. You can start
/// from any cell, and in each step you can move to any of the neighbor cells,
/// in other words, you can go to cells which share an edge with you current
/// cell.
/// Please note that a path of length k means visiting exactly k cells (not
/// necessarily distinct).
/// You CANNOT go off the grid.
/// A path A (of length k) is considered less than a path B (of length k) if
/// after making the ordered vectors of the values on the cells that A and B go
/// through (let's call them lst_A and lst_B), lst_A is lexicographically less
/// than lst_B, in other words, there exist an integer index i (1 <= i <= k)
/// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have
/// lst_A[j] = lst_B[j].
/// It is guaranteed that the answer is unique.
/// Return an ordered vector of the values on the cells that the minimum path go through.
/// Examples:    
/// >>> minPath(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3)
/// vec![1, 2, 1]
/// >>> minPath(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1)
/// vec![1]
fn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {

    let n_rows = grid.len();
    let n_cols = grid[0].len();
    let mut path = Vec::with_capacity(k as usize);
    let mut memo = vec![vec![vec![vec![]; n_rows]; n_cols]; n_rows];
    for i in 0..n_rows {
        for j in 0..n_cols {
            memo[i][j][0][i] = vec![grid[i][j]];
        }
    }
    for k in 1..=k {
        for i in 0..n_rows {
            for j in 0..n_cols {
                let mut paths = Vec::with_capacity(n_rows * n_cols);
                for x in (i as isize).min(k - 1)..n_rows as isize {
                    let x_index = x as usize;
                    for y in (j as isize).min(k - 1)..n_cols as isize {
                        let y_index = y as usize;
                        let mut path_left = memo[x as usize][y as usize][k - 1][i];
                        let mut path_up = memo[x as usize][y as usize][k - 1][j];
                        path_left.extend(path_up.iter());
                        path_left.sort();
                        path_left.dedup();
                        paths.push(path_left);
                        path_up.extend(path_left.iter());
                        path_up.sort();
                        path_up.dedup();
                        paths.push(path_up);
                    }
                }
                memo[i][j][k] = paths;
            }
        }
    }
    for i in 0..n_rows {
        for j in 0..n_cols {
            path.extend(memo[i][j][k].iter());
        }
    }
    path.sort();
    path.dedup();
    path
}

fn main() {
    let candidate = minPath;
    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3), vec![1, 2, 1]);
    assert_eq!(candidate(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1), vec![1]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4], vec![5, 6, 7, 8], vec![9, 10, 11, 12], vec![13, 14, 15, 16]], 4), vec![1, 2, 1, 2]);
    assert_eq!(candidate(vec![vec![6, 4, 13, 10], vec![5, 7, 12, 1], vec![3, 16, 11, 15], vec![8, 14, 9, 2]], 7), vec![1, 10, 1, 10, 1, 10, 1]);
    assert_eq!(candidate(vec![vec![8, 14, 9, 2], vec![6, 4, 13, 15], vec![5, 7, 1, 12], vec![3, 10, 11, 16]], 5), vec![1, 7, 1, 7, 1]);
    assert_eq!(candidate(vec![vec![11, 8, 7, 2], vec![5, 16, 14, 4], vec![9, 3, 15, 6], vec![12, 13, 10, 1]], 9), vec![1, 6, 1, 6, 1, 6, 1, 6, 1]);
    assert_eq!(candidate(vec![vec![12, 13, 10, 1], vec![9, 3, 15, 6], vec![5, 16, 14, 4], vec![11, 8, 7, 2]], 12), vec![1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);
    assert_eq!(candidate(vec![vec![2, 7, 4], vec![3, 1, 5], vec![6, 8, 9]], 8), vec![1, 3, 1, 3, 1, 3, 1, 3]);
    assert_eq!(candidate(vec![vec![6, 1, 5], vec![3, 8, 9], vec![2, 7, 4]], 8), vec![1, 5, 1, 5, 1, 5, 1, 5]);
    assert_eq!(candidate(vec![vec![1, 2], vec![3, 4]], 10), vec![1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);
    assert_eq!(candidate(vec![vec![1, 3], vec![3, 2]], 10), vec![1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);
}

-----------------------------
/// Given a grid with N rows and N columns (N >= 2) and a positive integer k, 
/// each cell of the grid contains a value. Every integer in the range [1, N * N]
/// inclusive appears exactly once on the cells of the grid.
/// You have to find the minimum path of length k in the grid. You can start
/// from any cell, and in each step you can move to any of the neighbor cells,
/// in other words, you can go to cells which share an edge with you current
/// cell.
/// Please note that a path of length k means visiting exactly k cells (not
/// necessarily distinct).
/// You CANNOT go off the grid.
/// A path A (of length k) is considered less than a path B (of length k) if
/// after making the ordered vectors of the values on the cells that A and B go
/// through (let's call them lst_A and lst_B), lst_A is lexicographically less
/// than lst_B, in other words, there exist an integer index i (1 <= i <= k)
/// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have
/// lst_A[j] = lst_B[j].
/// It is guaranteed that the answer is unique.
/// Return an ordered vector of the values on the cells that the minimum path go through.
/// Examples:    
/// >>> minPath(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3)
/// vec![1, 2, 1]
/// >>> minPath(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1)
/// vec![1]
fn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {

    let n = grid.len();
    let mut visited: Vec<Vec<bool>> = vec![vec![false; n]; n];
    let mut values = vec![vec![isize::MAX; n]; n];

    // mark the first cell as visited
    visited[0][0] = true;

    // mark the value of the first cell
    values[0][0] = 1;

    // mark the first cell as visited
    for i in 0..k {
        let mut max_sum = 0;
        let mut max_index = 0;
        for row in 0..n {
            for col in 0..n {
                if visited[row][col] {
                    continue;
                }
                let sum = if row > 0 && col > 0 {
                    values[row][col] = values[row - 1][col - 1] + grid[row][col];
                    values[row][col]
                } else if row > 0 {
                    values[row][col] = values[row - 1][col] + grid[row][col];
                    values[row][col]
                } else if col > 0 {
                    values[row][col] = values[row][col - 1] + grid[row][col];
                    values[row][col]
                } else {
                    values[row][col] = grid[row][col];
                    grid[row][col]
                };
                if sum > max_sum {
                    max_sum = sum;
                    max_index = (row, col);
                }
            }
        }

        visited[max_index.0][max_index.1] = true;
    }

    let mut path: Vec<isize> = vec![];
    let mut cur_index = (n - 1, n - 1);

    for _ in 0..k {
        path.push(grid[cur_index.0][cur_index.1]);
        let (nrow, ncol) = match cur_index {
            (row, col) if row > 0 && col > 0 => {
                if visited[row - 1][col] {
                    (row - 1, col)
                } else if visited[row][col - 1] {
                    (row, col - 1)
                } else
}

fn main() {
    let candidate = minPath;
    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3), vec![1, 2, 1]);
    assert_eq!(candidate(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1), vec![1]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4], vec![5, 6, 7, 8], vec![9, 10, 11, 12], vec![13, 14, 15, 16]], 4), vec![1, 2, 1, 2]);
    assert_eq!(candidate(vec![vec![6, 4, 13, 10], vec![5, 7, 12, 1], vec![3, 16, 11, 15], vec![8, 14, 9, 2]], 7), vec![1, 10, 1, 10, 1, 10, 1]);
    assert_eq!(candidate(vec![vec![8, 14, 9, 2], vec![6, 4, 13, 15], vec![5, 7, 1, 12], vec![3, 10, 11, 16]], 5), vec![1, 7, 1, 7, 1]);
    assert_eq!(candidate(vec![vec![11, 8, 7, 2], vec![5, 16, 14, 4], vec![9, 3, 15, 6], vec![12, 13, 10, 1]], 9), vec![1, 6, 1, 6, 1, 6, 1, 6, 1]);
    assert_eq!(candidate(vec![vec![12, 13, 10, 1], vec![9, 3, 15, 6], vec![5, 16, 14, 4], vec![11, 8, 7, 2]], 12), vec![1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);
    assert_eq!(candidate(vec![vec![2, 7, 4], vec![3, 1, 5], vec![6, 8, 9]], 8), vec![1, 3, 1, 3, 1, 3, 1, 3]);
    assert_eq!(candidate(vec![vec![6, 1, 5], vec![3, 8, 9], vec![2, 7, 4]], 8), vec![1, 5, 1, 5, 1, 5, 1, 5]);
    assert_eq!(candidate(vec![vec![1, 2], vec![3, 4]], 10), vec![1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);
    assert_eq!(candidate(vec![vec![1, 3], vec![3, 2]], 10), vec![1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);
}

-----------------------------
/// Given a grid with N rows and N columns (N >= 2) and a positive integer k, 
/// each cell of the grid contains a value. Every integer in the range [1, N * N]
/// inclusive appears exactly once on the cells of the grid.
/// You have to find the minimum path of length k in the grid. You can start
/// from any cell, and in each step you can move to any of the neighbor cells,
/// in other words, you can go to cells which share an edge with you current
/// cell.
/// Please note that a path of length k means visiting exactly k cells (not
/// necessarily distinct).
/// You CANNOT go off the grid.
/// A path A (of length k) is considered less than a path B (of length k) if
/// after making the ordered vectors of the values on the cells that A and B go
/// through (let's call them lst_A and lst_B), lst_A is lexicographically less
/// than lst_B, in other words, there exist an integer index i (1 <= i <= k)
/// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have
/// lst_A[j] = lst_B[j].
/// It is guaranteed that the answer is unique.
/// Return an ordered vector of the values on the cells that the minimum path go through.
/// Examples:    
/// >>> minPath(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3)
/// vec![1, 2, 1]
/// >>> minPath(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1)
/// vec![1]
fn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {

    let rows = grid.len();
    let cols = grid[0].len();
    let mut dp = vec![vec![vec![isize::MAX; cols + 1]; rows + 1]; k + 1];
    for r in 0..rows {
        for c in 0..cols {
            let mut v = vec![vec![isize::MAX; cols + 1]; rows + 1];
            for t in 0..k {
                v[t + 1][c] = grid[r][c];
            }
            dp[1][r][c] = v[1][c];
        }
    }

    for d in 2..=k {
        for r in 0..rows {
            for c in 0..cols {
                let mut v = vec![vec![isize::MAX; cols + 1]; rows + 1];
                for t in 0..d {
                    for i in -1..=1 {
                        for j in -1..=1 {
                            if i != 0 || j != 0 {
                                let x = r as isize + i;
                                let y = c as isize + j;
                                if x >= 0 && x < rows as isize && y >= 0 && y < cols as isize {
                                    v[t + 1][c] = dp[t][x as usize][y as usize].min(v[t][c]);
                                }
                            }
                        }
                    }
                }
                dp[d][r][c] = v[d][c];
            }
        }
    }
    let mut min_index = 0;
    for i in 1..k + 1 {
        if dp[k][0][0] > dp[i][0][0] {
            min_index = i;
        }
    }

    for r in 0..rows {
        for c in 0..cols {
            let mut v = vec![];
            for i in min_index..k + 1 {
                v.push(dp[i][r][c]);
            }
            return v;
        }
    }
    vec![]
}

fn main() {
    let candidate = minPath;
    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3), vec![1, 2, 1]);
    assert_eq!(candidate(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1), vec![1]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4], vec![5, 6, 7, 8], vec![9, 10, 11, 12], vec![13, 14, 15, 16]], 4), vec![1, 2, 1, 2]);
    assert_eq!(candidate(vec![vec![6, 4, 13, 10], vec![5, 7, 12, 1], vec![3, 16, 11, 15], vec![8, 14, 9, 2]], 7), vec![1, 10, 1, 10, 1, 10, 1]);
    assert_eq!(candidate(vec![vec![8, 14, 9, 2], vec![6, 4, 13, 15], vec![5, 7, 1, 12], vec![3, 10, 11, 16]], 5), vec![1, 7, 1, 7, 1]);
    assert_eq!(candidate(vec![vec![11, 8, 7, 2], vec![5, 16, 14, 4], vec![9, 3, 15, 6], vec![12, 13, 10, 1]], 9), vec![1, 6, 1, 6, 1, 6, 1, 6, 1]);
    assert_eq!(candidate(vec![vec![12, 13, 10, 1], vec![9, 3, 15, 6], vec![5, 16, 14, 4], vec![11, 8, 7, 2]], 12), vec![1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);
    assert_eq!(candidate(vec![vec![2, 7, 4], vec![3, 1, 5], vec![6, 8, 9]], 8), vec![1, 3, 1, 3, 1, 3, 1, 3]);
    assert_eq!(candidate(vec![vec![6, 1, 5], vec![3, 8, 9], vec![2, 7, 4]], 8), vec![1, 5, 1, 5, 1, 5, 1, 5]);
    assert_eq!(candidate(vec![vec![1, 2], vec![3, 4]], 10), vec![1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);
    assert_eq!(candidate(vec![vec![1, 3], vec![3, 2]], 10), vec![1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);
}

-----------------------------
/// Given a grid with N rows and N columns (N >= 2) and a positive integer k, 
/// each cell of the grid contains a value. Every integer in the range [1, N * N]
/// inclusive appears exactly once on the cells of the grid.
/// You have to find the minimum path of length k in the grid. You can start
/// from any cell, and in each step you can move to any of the neighbor cells,
/// in other words, you can go to cells which share an edge with you current
/// cell.
/// Please note that a path of length k means visiting exactly k cells (not
/// necessarily distinct).
/// You CANNOT go off the grid.
/// A path A (of length k) is considered less than a path B (of length k) if
/// after making the ordered vectors of the values on the cells that A and B go
/// through (let's call them lst_A and lst_B), lst_A is lexicographically less
/// than lst_B, in other words, there exist an integer index i (1 <= i <= k)
/// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have
/// lst_A[j] = lst_B[j].
/// It is guaranteed that the answer is unique.
/// Return an ordered vector of the values on the cells that the minimum path go through.
/// Examples:    
/// >>> minPath(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3)
/// vec![1, 2, 1]
/// >>> minPath(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1)
/// vec![1]
fn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {

    if grid.len() == 0 || grid[0].len() == 0 {
        return vec![];
    }
    let (n, m) = (grid.len(), grid[0].len());
    let mut result: Vec<isize> = vec![1; k as usize];
    let mut dp: Vec<Vec<Vec<isize>>> = vec![vec![vec![std::isize::MAX; m]; k as usize]; n];
    let mut dp_n = dp.clone();
    dp[0][0][0] = 0;
    for i in 0..n {
        for j in 0..m {
            let cur = dp[i][j][k as usize - 1];
            if cur < std::isize::MAX {
                result[0] = cur;
            }
        }
    }
    for i in 0..k as usize {
        for j in 0..n {
            for k in 0..m {
                let cur = dp[j][k][i];
                if cur < std::isize::MAX {
                    result[i as usize] = cur;
                }
                if j > 0 {
                    dp_n[j][k][i] = std::cmp::min(dp_n[j][k][i], dp[j - 1][k][i]);
                }
                if k > 0 {
                    dp_n[j][k][i] = std::cmp::min(dp_n[j][k][i], dp[j][k - 1][i]);
                }
                dp_n[j][k][i] = std::cmp::min(dp_n[j][k][i], dp[j][k][i - 1]);
                dp_n[j][k][i] = std::cmp::min(dp_n[j][k][i], dp[j][k][i + 1]);
                dp[j][k][i] = std::cmp::min(dp[j][k][i], grid[j][k] + dp_n[j][k][i]);
            }
        }
        dp = dp_n.clone();
    }
    result
}

fn main() {
    let candidate = minPath;
    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3), vec![1, 2, 1]);
    assert_eq!(candidate(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1), vec![1]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4], vec![5, 6, 7, 8], vec![9, 10, 11, 12], vec![13, 14, 15, 16]], 4), vec![1, 2, 1, 2]);
    assert_eq!(candidate(vec![vec![6, 4, 13, 10], vec![5, 7, 12, 1], vec![3, 16, 11, 15], vec![8, 14, 9, 2]], 7), vec![1, 10, 1, 10, 1, 10, 1]);
    assert_eq!(candidate(vec![vec![8, 14, 9, 2], vec![6, 4, 13, 15], vec![5, 7, 1, 12], vec![3, 10, 11, 16]], 5), vec![1, 7, 1, 7, 1]);
    assert_eq!(candidate(vec![vec![11, 8, 7, 2], vec![5, 16, 14, 4], vec![9, 3, 15, 6], vec![12, 13, 10, 1]], 9), vec![1, 6, 1, 6, 1, 6, 1, 6, 1]);
    assert_eq!(candidate(vec![vec![12, 13, 10, 1], vec![9, 3, 15, 6], vec![5, 16, 14, 4], vec![11, 8, 7, 2]], 12), vec![1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);
    assert_eq!(candidate(vec![vec![2, 7, 4], vec![3, 1, 5], vec![6, 8, 9]], 8), vec![1, 3, 1, 3, 1, 3, 1, 3]);
    assert_eq!(candidate(vec![vec![6, 1, 5], vec![3, 8, 9], vec![2, 7, 4]], 8), vec![1, 5, 1, 5, 1, 5, 1, 5]);
    assert_eq!(candidate(vec![vec![1, 2], vec![3, 4]], 10), vec![1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);
    assert_eq!(candidate(vec![vec![1, 3], vec![3, 2]], 10), vec![1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);
}

===============================
/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
/// the last couple centuries. However, what people don't know is Tribonacci sequence.
/// Tribonacci sequence is defined by the recurrence:
/// tri(1) = 3
/// tri(n) = 1 + n / 2, if n is even.
/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
/// For example:
/// tri(2) = 1 + (2 / 2) = 2
/// tri(4) = 3
/// tri(3) = tri(2) + tri(1) + tri(4)
/// = 2 + 3 + 3 = 8 
/// You are given a non-negative integer number n, you have to a return a vector of the 
/// first n + 1 numbers of the Tribonacci sequence.
/// Examples:
/// >>> tri(3)
/// vec![1, 3, 2, 8]
fn tri(n: isize) -> Vec<isize> {

===============================
-----------------------------
/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
/// the last couple centuries. However, what people don't know is Tribonacci sequence.
/// Tribonacci sequence is defined by the recurrence:
/// tri(1) = 3
/// tri(n) = 1 + n / 2, if n is even.
/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
/// For example:
/// tri(2) = 1 + (2 / 2) = 2
/// tri(4) = 3
/// tri(3) = tri(2) + tri(1) + tri(4)
/// = 2 + 3 + 3 = 8 
/// You are given a non-negative integer number n, you have to a return a vector of the 
/// first n + 1 numbers of the Tribonacci sequence.
/// Examples:
/// >>> tri(3)
/// vec![1, 3, 2, 8]
fn tri(n: isize) -> Vec<isize> {

    if n == 0 {
        vec![]
    } else if n == 1 {
        vec![1]
    } else if n == 2 {
        vec![1, 3, 2]
    } else {
        let mut sequence = vec![1, 3, 2];
        for _ in 2..n {
            let mut a = 2;
            let mut b = 3;
            let mut c = 1;
            let tmp = a;
            a = b;
            b = c;
            c = tmp + a + b;
            sequence.push(c);
        }
        sequence
    }
}

fn main() {
    let candidate = tri;
    assert_eq!(candidate(3), vec![1, 3, 2, 8]);
    assert_eq!(candidate(4), vec![1, 3, 2, 8, 3]);
    assert_eq!(candidate(5), vec![1, 3, 2, 8, 3, 15]);
    assert_eq!(candidate(6), vec![1, 3, 2, 8, 3, 15, 4]);
    assert_eq!(candidate(7), vec![1, 3, 2, 8, 3, 15, 4, 24]);
    assert_eq!(candidate(8), vec![1, 3, 2, 8, 3, 15, 4, 24, 5]);
    assert_eq!(candidate(9), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);
    assert_eq!(candidate(20), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]);
    assert_eq!(candidate(0), vec![1]);
    assert_eq!(candidate(1), vec![1, 3]);
}

-----------------------------
/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
/// the last couple centuries. However, what people don't know is Tribonacci sequence.
/// Tribonacci sequence is defined by the recurrence:
/// tri(1) = 3
/// tri(n) = 1 + n / 2, if n is even.
/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
/// For example:
/// tri(2) = 1 + (2 / 2) = 2
/// tri(4) = 3
/// tri(3) = tri(2) + tri(1) + tri(4)
/// = 2 + 3 + 3 = 8 
/// You are given a non-negative integer number n, you have to a return a vector of the 
/// first n + 1 numbers of the Tribonacci sequence.
/// Examples:
/// >>> tri(3)
/// vec![1, 3, 2, 8]
fn tri(n: isize) -> Vec<isize> {

    let mut vec = vec![0; n as usize + 1];
    vec[0] = 1;
    if n == 0 {
        return vec
    }
    vec[1] = n;
    if n == 1 {
        return vec
    }
    if n % 2 == 0 {
        vec[2] = 2;
    } else {
        vec[2] = n;
    }
    for i in 3..(n + 1) as usize {
        if i % 2 == 0 {
            vec[i] = vec[i - 2] + vec[i - 1];
        } else {
            vec[i] = vec[i - 1] + vec[i - 3] + vec[i - 2];
        }
    }
    vec
}

fn main() {
    let candidate = tri;
    assert_eq!(candidate(3), vec![1, 3, 2, 8]);
    assert_eq!(candidate(4), vec![1, 3, 2, 8, 3]);
    assert_eq!(candidate(5), vec![1, 3, 2, 8, 3, 15]);
    assert_eq!(candidate(6), vec![1, 3, 2, 8, 3, 15, 4]);
    assert_eq!(candidate(7), vec![1, 3, 2, 8, 3, 15, 4, 24]);
    assert_eq!(candidate(8), vec![1, 3, 2, 8, 3, 15, 4, 24, 5]);
    assert_eq!(candidate(9), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);
    assert_eq!(candidate(20), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]);
    assert_eq!(candidate(0), vec![1]);
    assert_eq!(candidate(1), vec![1, 3]);
}

-----------------------------
/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
/// the last couple centuries. However, what people don't know is Tribonacci sequence.
/// Tribonacci sequence is defined by the recurrence:
/// tri(1) = 3
/// tri(n) = 1 + n / 2, if n is even.
/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
/// For example:
/// tri(2) = 1 + (2 / 2) = 2
/// tri(4) = 3
/// tri(3) = tri(2) + tri(1) + tri(4)
/// = 2 + 3 + 3 = 8 
/// You are given a non-negative integer number n, you have to a return a vector of the 
/// first n + 1 numbers of the Tribonacci sequence.
/// Examples:
/// >>> tri(3)
/// vec![1, 3, 2, 8]
fn tri(n: isize) -> Vec<isize> {

    let mut a = 0;
    let mut b = 1;
    let mut c = 2;
    let mut res = vec![a, b, c];
    for _ in 0..n {
        a = b;
        b = c;
        c = a + b + c;
        res.push(c);
    }
    res
}

fn main() {
    let candidate = tri;
    assert_eq!(candidate(3), vec![1, 3, 2, 8]);
    assert_eq!(candidate(4), vec![1, 3, 2, 8, 3]);
    assert_eq!(candidate(5), vec![1, 3, 2, 8, 3, 15]);
    assert_eq!(candidate(6), vec![1, 3, 2, 8, 3, 15, 4]);
    assert_eq!(candidate(7), vec![1, 3, 2, 8, 3, 15, 4, 24]);
    assert_eq!(candidate(8), vec![1, 3, 2, 8, 3, 15, 4, 24, 5]);
    assert_eq!(candidate(9), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);
    assert_eq!(candidate(20), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]);
    assert_eq!(candidate(0), vec![1]);
    assert_eq!(candidate(1), vec![1, 3]);
}

-----------------------------
/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
/// the last couple centuries. However, what people don't know is Tribonacci sequence.
/// Tribonacci sequence is defined by the recurrence:
/// tri(1) = 3
/// tri(n) = 1 + n / 2, if n is even.
/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
/// For example:
/// tri(2) = 1 + (2 / 2) = 2
/// tri(4) = 3
/// tri(3) = tri(2) + tri(1) + tri(4)
/// = 2 + 3 + 3 = 8 
/// You are given a non-negative integer number n, you have to a return a vector of the 
/// first n + 1 numbers of the Tribonacci sequence.
/// Examples:
/// >>> tri(3)
/// vec![1, 3, 2, 8]
fn tri(n: isize) -> Vec<isize> {

    let mut vec = vec![1, 3, 2];
    if n <= 3 {
        return vec;
    }
    for i in 0..n-3 {
        vec.push(vec[i] + vec[i+1] + vec[i+2]);
    }
    vec
}

fn main() {
    let candidate = tri;
    assert_eq!(candidate(3), vec![1, 3, 2, 8]);
    assert_eq!(candidate(4), vec![1, 3, 2, 8, 3]);
    assert_eq!(candidate(5), vec![1, 3, 2, 8, 3, 15]);
    assert_eq!(candidate(6), vec![1, 3, 2, 8, 3, 15, 4]);
    assert_eq!(candidate(7), vec![1, 3, 2, 8, 3, 15, 4, 24]);
    assert_eq!(candidate(8), vec![1, 3, 2, 8, 3, 15, 4, 24, 5]);
    assert_eq!(candidate(9), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);
    assert_eq!(candidate(20), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]);
    assert_eq!(candidate(0), vec![1]);
    assert_eq!(candidate(1), vec![1, 3]);
}

-----------------------------
/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
/// the last couple centuries. However, what people don't know is Tribonacci sequence.
/// Tribonacci sequence is defined by the recurrence:
/// tri(1) = 3
/// tri(n) = 1 + n / 2, if n is even.
/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
/// For example:
/// tri(2) = 1 + (2 / 2) = 2
/// tri(4) = 3
/// tri(3) = tri(2) + tri(1) + tri(4)
/// = 2 + 3 + 3 = 8 
/// You are given a non-negative integer number n, you have to a return a vector of the 
/// first n + 1 numbers of the Tribonacci sequence.
/// Examples:
/// >>> tri(3)
/// vec![1, 3, 2, 8]
fn tri(n: isize) -> Vec<isize> {

    let mut n = n;
    if n == 0 { return vec![1]; }
    let mut vec: Vec<isize> = vec![1, 3];
    if n == 1 { return vec; }
    if n == 2 { return vec![1, 3, 2]; }

    for i in 3..=n {
        let mut temp: isize = 0;
        if i % 2 == 0 {
            temp = 1 + (i as f64 / 2.0).floor() as isize;
        } else {
            temp = vec.get(i - 1).unwrap() + vec.get(i - 2).unwrap() + vec.get(i - 3).unwrap();
        }
        vec.push(temp);
    }
    return vec;
}

fn main() {
    let candidate = tri;
    assert_eq!(candidate(3), vec![1, 3, 2, 8]);
    assert_eq!(candidate(4), vec![1, 3, 2, 8, 3]);
    assert_eq!(candidate(5), vec![1, 3, 2, 8, 3, 15]);
    assert_eq!(candidate(6), vec![1, 3, 2, 8, 3, 15, 4]);
    assert_eq!(candidate(7), vec![1, 3, 2, 8, 3, 15, 4, 24]);
    assert_eq!(candidate(8), vec![1, 3, 2, 8, 3, 15, 4, 24, 5]);
    assert_eq!(candidate(9), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);
    assert_eq!(candidate(20), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]);
    assert_eq!(candidate(0), vec![1]);
    assert_eq!(candidate(1), vec![1, 3]);
}

===============================
/// Given a positive integer n, return the product of the odd digits.
/// Return 0 if all digits are even.
/// For example:
/// >>> digits(1)
/// 1
/// >>> digits(4)
/// 0
/// >>> digits(235)
/// 15
fn digits(n: isize) -> isize {

===============================
-----------------------------
/// Given a positive integer n, return the product of the odd digits.
/// Return 0 if all digits are even.
/// For example:
/// >>> digits(1)
/// 1
/// >>> digits(4)
/// 0
/// >>> digits(235)
/// 15
fn digits(n: isize) -> isize {

    n.to_string().chars().filter(|c| c.is_ascii_digit() && c.to_digit(10).unwrap() % 2 != 0).fold(0, |acc, c| { acc * 10 + c.to_digit(10).unwrap() })
}

fn main() {
    let candidate = digits;
    assert_eq!(candidate(5), 5);
    assert_eq!(candidate(54), 5);
    assert_eq!(candidate(120), 1);
    assert_eq!(candidate(5014), 5);
    assert_eq!(candidate(98765), 315);
    assert_eq!(candidate(5576543), 2625);
    assert_eq!(candidate(2468), 0);
}

-----------------------------
/// Given a positive integer n, return the product of the odd digits.
/// Return 0 if all digits are even.
/// For example:
/// >>> digits(1)
/// 1
/// >>> digits(4)
/// 0
/// >>> digits(235)
/// 15
fn digits(n: isize) -> isize {

    let n_abs = n.abs();
    let digits = n_abs.to_string();

    let mut prod = 1;
    for digit in digits.chars() {
        if digit.is_digit(10) {
            let digit = digit.to_digit(10).unwrap();
            if digit % 2 == 1 {
                prod *= digit;
            }
        }
    }
    if prod == 0 {
        return 0;
    }
    prod
}

fn main() {
    let candidate = digits;
    assert_eq!(candidate(5), 5);
    assert_eq!(candidate(54), 5);
    assert_eq!(candidate(120), 1);
    assert_eq!(candidate(5014), 5);
    assert_eq!(candidate(98765), 315);
    assert_eq!(candidate(5576543), 2625);
    assert_eq!(candidate(2468), 0);
}

-----------------------------
/// Given a positive integer n, return the product of the odd digits.
/// Return 0 if all digits are even.
/// For example:
/// >>> digits(1)
/// 1
/// >>> digits(4)
/// 0
/// >>> digits(235)
/// 15
fn digits(n: isize) -> isize {

    if n < 0 {
        return 0;
    }
    let mut res = 1;
    let mut n = n;
    while n > 0 {
        let digit = n % 10;
        if digit % 2 == 1 {
            res *= digit;
        }
        n /= 10;
    }
    res
}

fn main() {
    let candidate = digits;
    assert_eq!(candidate(5), 5);
    assert_eq!(candidate(54), 5);
    assert_eq!(candidate(120), 1);
    assert_eq!(candidate(5014), 5);
    assert_eq!(candidate(98765), 315);
    assert_eq!(candidate(5576543), 2625);
    assert_eq!(candidate(2468), 0);
}

-----------------------------
/// Given a positive integer n, return the product of the odd digits.
/// Return 0 if all digits are even.
/// For example:
/// >>> digits(1)
/// 1
/// >>> digits(4)
/// 0
/// >>> digits(235)
/// 15
fn digits(n: isize) -> isize {

    if n == 0 {
        return 0;
    }
    let mut product = 1;
    let mut is_even = true;
    let mut number = n;
    while number > 0 {
        let remainder = number % 10;
        number = number / 10;
        if remainder % 2 == 1 {
            is_even = false;
            product = product * remainder;
        }
    }
    if is_even {
        return 0;
    } else {
        return product;
    }
}

fn main() {
    let candidate = digits;
    assert_eq!(candidate(5), 5);
    assert_eq!(candidate(54), 5);
    assert_eq!(candidate(120), 1);
    assert_eq!(candidate(5014), 5);
    assert_eq!(candidate(98765), 315);
    assert_eq!(candidate(5576543), 2625);
    assert_eq!(candidate(2468), 0);
}

-----------------------------
/// Given a positive integer n, return the product of the odd digits.
/// Return 0 if all digits are even.
/// For example:
/// >>> digits(1)
/// 1
/// >>> digits(4)
/// 0
/// >>> digits(235)
/// 15
fn digits(n: isize) -> isize {

    let mut result = 1;
    let mut digit = n % 10;
    while digit > 0 {
        if digit % 2 == 1 {
            result *= digit;
        }
        n /= 10;
        digit = n % 10;
    }
    result
}

fn main() {
    let candidate = digits;
    assert_eq!(candidate(5), 5);
    assert_eq!(candidate(54), 5);
    assert_eq!(candidate(120), 1);
    assert_eq!(candidate(5014), 5);
    assert_eq!(candidate(98765), 315);
    assert_eq!(candidate(5576543), 2625);
    assert_eq!(candidate(2468), 0);
}

===============================
/// Create a function that takes a string as input which contains only square brackets.
/// The function should return true if and only if there is a valid subsequence of brackets 
/// where at least one bracket in the subsequence is nested.
/// >>> is_nested(String::from("[[]]"))
/// true
/// >>> is_nested(String::from("[]]]]]]][[[[[]"))
/// false
/// >>> is_nested(String::from("[][]"))
/// false
/// >>> is_nested(String::from("[]"))
/// false
/// >>> is_nested(String::from("[[][]]"))
/// true
/// >>> is_nested(String::from("[[]][["))
/// true
fn is_nested(string: String) -> bool {

===============================
-----------------------------
/// Create a function that takes a string as input which contains only square brackets.
/// The function should return true if and only if there is a valid subsequence of brackets 
/// where at least one bracket in the subsequence is nested.
/// >>> is_nested(String::from("[[]]"))
/// true
/// >>> is_nested(String::from("[]]]]]]][[[[[]"))
/// false
/// >>> is_nested(String::from("[][]"))
/// false
/// >>> is_nested(String::from("[]"))
/// false
/// >>> is_nested(String::from("[[][]]"))
/// true
/// >>> is_nested(String::from("[[]][["))
/// true
fn is_nested(string: String) -> bool {

    let mut stack = Vec::new();
    for char in string.chars() {
        match char {
            '[' => stack.push(char),
            ']' => {
                if stack.pop().unwrap() == '[' {
                    continue;
                } else {
                    return false;
                }
            }
            _ => continue,
        }
    }
    stack.len() == 0
}

fn main() {
    let candidate = is_nested;
    assert_eq!(candidate(String::from("[[]]")), true);
    assert_eq!(candidate(String::from("[]]]]]]][[[[[]")), false);
    assert_eq!(candidate(String::from("[][]")), false);
    assert_eq!(candidate(String::from("[]")), false);
    assert_eq!(candidate(String::from("[[[[]]]]")), true);
    assert_eq!(candidate(String::from("[]]]]]]]]]]")), false);
    assert_eq!(candidate(String::from("[][][[]]")), true);
    assert_eq!(candidate(String::from("[[]")), false);
    assert_eq!(candidate(String::from("[]]")), false);
    assert_eq!(candidate(String::from("[[]][[")), true);
    assert_eq!(candidate(String::from("[[][]]")), true);
    assert_eq!(candidate(String::from("")), false);
    assert_eq!(candidate(String::from("[[[[[[[[")), false);
    assert_eq!(candidate(String::from("]]]]]]]]")), false);
}

-----------------------------
/// Create a function that takes a string as input which contains only square brackets.
/// The function should return true if and only if there is a valid subsequence of brackets 
/// where at least one bracket in the subsequence is nested.
/// >>> is_nested(String::from("[[]]"))
/// true
/// >>> is_nested(String::from("[]]]]]]][[[[[]"))
/// false
/// >>> is_nested(String::from("[][]"))
/// false
/// >>> is_nested(String::from("[]"))
/// false
/// >>> is_nested(String::from("[[][]]"))
/// true
/// >>> is_nested(String::from("[[]][["))
/// true
fn is_nested(string: String) -> bool {

    let length = string.len();
    if length == 0 { return false; }

    let mut stack: Vec<char> = Vec::new();
    let mut end = false;
    let mut index = 0;

    for i in 0..length {
        if string.chars().nth(i).unwrap() == '[' {
            stack.push('[');
        } else {
            if stack.pop().unwrap() != '[' {
                return false;
            } else {
                end = true;
                break;
            }
        }
    }
    for i in index..length {
        if string.chars().nth(i).unwrap() == '[' {
            stack.push('[');
        } else {
            if stack.pop().unwrap() != '[' {
                return false;
            }
        }
    }
    if end { return true; }
    return false;
}

fn main() {
    let candidate = is_nested;
    assert_eq!(candidate(String::from("[[]]")), true);
    assert_eq!(candidate(String::from("[]]]]]]][[[[[]")), false);
    assert_eq!(candidate(String::from("[][]")), false);
    assert_eq!(candidate(String::from("[]")), false);
    assert_eq!(candidate(String::from("[[[[]]]]")), true);
    assert_eq!(candidate(String::from("[]]]]]]]]]]")), false);
    assert_eq!(candidate(String::from("[][][[]]")), true);
    assert_eq!(candidate(String::from("[[]")), false);
    assert_eq!(candidate(String::from("[]]")), false);
    assert_eq!(candidate(String::from("[[]][[")), true);
    assert_eq!(candidate(String::from("[[][]]")), true);
    assert_eq!(candidate(String::from("")), false);
    assert_eq!(candidate(String::from("[[[[[[[[")), false);
    assert_eq!(candidate(String::from("]]]]]]]]")), false);
}

-----------------------------
/// Create a function that takes a string as input which contains only square brackets.
/// The function should return true if and only if there is a valid subsequence of brackets 
/// where at least one bracket in the subsequence is nested.
/// >>> is_nested(String::from("[[]]"))
/// true
/// >>> is_nested(String::from("[]]]]]]][[[[[]"))
/// false
/// >>> is_nested(String::from("[][]"))
/// false
/// >>> is_nested(String::from("[]"))
/// false
/// >>> is_nested(String::from("[[][]]"))
/// true
/// >>> is_nested(String::from("[[]][["))
/// true
fn is_nested(string: String) -> bool {

    if string.len() <= 1 {
        return false;
    }
    let mut opening = Vec::new();
    let mut closing = Vec::new();
    for c in string.chars() {
        match c {
            '[' => {
                opening.push(c);
            }
            ']' => {
                if opening.pop() == Some('[') {
                    closing.push(c);
                } else {
                    return false;
                }
            }
            _ => {}
        }
    }

    return opening.len() == 0 && closing.len() == 0;
}

fn main() {
    let candidate = is_nested;
    assert_eq!(candidate(String::from("[[]]")), true);
    assert_eq!(candidate(String::from("[]]]]]]][[[[[]")), false);
    assert_eq!(candidate(String::from("[][]")), false);
    assert_eq!(candidate(String::from("[]")), false);
    assert_eq!(candidate(String::from("[[[[]]]]")), true);
    assert_eq!(candidate(String::from("[]]]]]]]]]]")), false);
    assert_eq!(candidate(String::from("[][][[]]")), true);
    assert_eq!(candidate(String::from("[[]")), false);
    assert_eq!(candidate(String::from("[]]")), false);
    assert_eq!(candidate(String::from("[[]][[")), true);
    assert_eq!(candidate(String::from("[[][]]")), true);
    assert_eq!(candidate(String::from("")), false);
    assert_eq!(candidate(String::from("[[[[[[[[")), false);
    assert_eq!(candidate(String::from("]]]]]]]]")), false);
}

-----------------------------
/// Create a function that takes a string as input which contains only square brackets.
/// The function should return true if and only if there is a valid subsequence of brackets 
/// where at least one bracket in the subsequence is nested.
/// >>> is_nested(String::from("[[]]"))
/// true
/// >>> is_nested(String::from("[]]]]]]][[[[[]"))
/// false
/// >>> is_nested(String::from("[][]"))
/// false
/// >>> is_nested(String::from("[]"))
/// false
/// >>> is_nested(String::from("[[][]]"))
/// true
/// >>> is_nested(String::from("[[]][["))
/// true
fn is_nested(string: String) -> bool {

    // If the string is an empty string or contains any character other than "[" or "]".
    if string.len() == 0 || string.chars().any(|c| c != '[' && c != ']') {
        return false;
    }

    // If the string contains a character "[" but not a character "]".
    if string.chars().any(|c| c == '[' && c != ']') {
        return false;
    }

    // If the string contains a character "]" but not a character "["
    if string.chars().any(|c| c == ']' && c != '[') {
        return false;
    }

    // The string contains a subsequence of brackets where at least one bracket in the subsequence is nested.
    true
}

fn main() {
    let candidate = is_nested;
    assert_eq!(candidate(String::from("[[]]")), true);
    assert_eq!(candidate(String::from("[]]]]]]][[[[[]")), false);
    assert_eq!(candidate(String::from("[][]")), false);
    assert_eq!(candidate(String::from("[]")), false);
    assert_eq!(candidate(String::from("[[[[]]]]")), true);
    assert_eq!(candidate(String::from("[]]]]]]]]]]")), false);
    assert_eq!(candidate(String::from("[][][[]]")), true);
    assert_eq!(candidate(String::from("[[]")), false);
    assert_eq!(candidate(String::from("[]]")), false);
    assert_eq!(candidate(String::from("[[]][[")), true);
    assert_eq!(candidate(String::from("[[][]]")), true);
    assert_eq!(candidate(String::from("")), false);
    assert_eq!(candidate(String::from("[[[[[[[[")), false);
    assert_eq!(candidate(String::from("]]]]]]]]")), false);
}

-----------------------------
/// Create a function that takes a string as input which contains only square brackets.
/// The function should return true if and only if there is a valid subsequence of brackets 
/// where at least one bracket in the subsequence is nested.
/// >>> is_nested(String::from("[[]]"))
/// true
/// >>> is_nested(String::from("[]]]]]]][[[[[]"))
/// false
/// >>> is_nested(String::from("[][]"))
/// false
/// >>> is_nested(String::from("[]"))
/// false
/// >>> is_nested(String::from("[[][]]"))
/// true
/// >>> is_nested(String::from("[[]][["))
/// true
fn is_nested(string: String) -> bool {

    let mut string_iterator = string.chars();
    let mut counter = 0;
    let mut temp = String::from("");
    let mut nested_brackets = Vec::new();
    let mut check = true;
    let mut result = true;

    while check {
        if string_iterator.next().unwrap() == '[' {
            counter += 1;
            temp.push('[');
            if temp.len() == 1 {
                nested_brackets.push(String::from(""));
            }
            nested_brackets[nested_brackets.len() - 1].push('[');
        }
        if string_iterator.next().unwrap() == ']' {
            counter -= 1;
            temp.push(']');
            if temp.len() == 1 {
                nested_brackets.push(String::from(""));
            }
            nested_brackets[nested_brackets.len() - 1].push(']');
            if nested_brackets[nested_brackets.len() - 1].len() >= 2 {
                if nested_brackets[nested_brackets.len() - 1].chars().nth(0).unwrap() == '[' {
                    nested_brackets[nested_brackets.len() - 1].remove(0);
                } else {
                    check = false;
                    result = false;
                }
            }
        }
    }
    if counter != 0 || !check {
        result = false;
    }
    return result;
}

fn main() {
    let candidate = is_nested;
    assert_eq!(candidate(String::from("[[]]")), true);
    assert_eq!(candidate(String::from("[]]]]]]][[[[[]")), false);
    assert_eq!(candidate(String::from("[][]")), false);
    assert_eq!(candidate(String::from("[]")), false);
    assert_eq!(candidate(String::from("[[[[]]]]")), true);
    assert_eq!(candidate(String::from("[]]]]]]]]]]")), false);
    assert_eq!(candidate(String::from("[][][[]]")), true);
    assert_eq!(candidate(String::from("[[]")), false);
    assert_eq!(candidate(String::from("[]]")), false);
    assert_eq!(candidate(String::from("[[]][[")), true);
    assert_eq!(candidate(String::from("[[][]]")), true);
    assert_eq!(candidate(String::from("")), false);
    assert_eq!(candidate(String::from("[[[[[[[[")), false);
    assert_eq!(candidate(String::from("]]]]]]]]")), false);
}

===============================
/// You are given a vector of numbers.
/// You need to return the sum of squared numbers in the given vector,
/// round each element in the vector to the upper int(Ceiling) first.
/// Examples:
/// >>> lst(vec![1.0, 2.0, 3.0])
/// 14
/// >>> lst(vec![1.0, 4.0, 9.0])
/// 98
/// >>> lst(vec![1.0, 3.0, 5.0, 7.0])
/// 84
/// >>> lst(vec![1.4, 4.2, 0.0])
/// 29
/// >>> lst(vec![-2.4, 1.0, 1.0])
/// 6
fn sum_squares(lst: Vec<f64>) -> isize {

===============================
-----------------------------
/// You are given a vector of numbers.
/// You need to return the sum of squared numbers in the given vector,
/// round each element in the vector to the upper int(Ceiling) first.
/// Examples:
/// >>> lst(vec![1.0, 2.0, 3.0])
/// 14
/// >>> lst(vec![1.0, 4.0, 9.0])
/// 98
/// >>> lst(vec![1.0, 3.0, 5.0, 7.0])
/// 84
/// >>> lst(vec![1.4, 4.2, 0.0])
/// 29
/// >>> lst(vec![-2.4, 1.0, 1.0])
/// 6
fn sum_squares(lst: Vec<f64>) -> isize {

    lst.iter().map(|&x| (x as isize).pow(2)).sum()
}

fn main() {
    let candidate = sum_squares;
    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);
    assert_eq!(candidate(vec![1.0, 3.0, 5.0, 7.0]), 84);
    assert_eq!(candidate(vec![1.4, 4.2, 0.0]), 29);
    assert_eq!(candidate(vec![-2.4, 1.0, 1.0]), 6);
    assert_eq!(candidate(vec![100.0, 1.0, 15.0, 2.0]), 10230);
    assert_eq!(candidate(vec![10000.0, 10000.0]), 200000000);
    assert_eq!(candidate(vec![-1.4, 4.6, 6.3]), 75);
    assert_eq!(candidate(vec![-1.4, 17.9, 18.9, 19.9]), 1086);
    assert_eq!(candidate(vec![0.0]), 0);
    assert_eq!(candidate(vec![-1.0]), 1);
    assert_eq!(candidate(vec![-1.0, 1.0, 0.0]), 2);
}

-----------------------------
/// You are given a vector of numbers.
/// You need to return the sum of squared numbers in the given vector,
/// round each element in the vector to the upper int(Ceiling) first.
/// Examples:
/// >>> lst(vec![1.0, 2.0, 3.0])
/// 14
/// >>> lst(vec![1.0, 4.0, 9.0])
/// 98
/// >>> lst(vec![1.0, 3.0, 5.0, 7.0])
/// 84
/// >>> lst(vec![1.4, 4.2, 0.0])
/// 29
/// >>> lst(vec![-2.4, 1.0, 1.0])
/// 6
fn sum_squares(lst: Vec<f64>) -> isize {

    lst.iter().map(|&x| (x.ceil() as isize).pow(2)).sum()
}

fn main() {
    let candidate = sum_squares;
    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);
    assert_eq!(candidate(vec![1.0, 3.0, 5.0, 7.0]), 84);
    assert_eq!(candidate(vec![1.4, 4.2, 0.0]), 29);
    assert_eq!(candidate(vec![-2.4, 1.0, 1.0]), 6);
    assert_eq!(candidate(vec![100.0, 1.0, 15.0, 2.0]), 10230);
    assert_eq!(candidate(vec![10000.0, 10000.0]), 200000000);
    assert_eq!(candidate(vec![-1.4, 4.6, 6.3]), 75);
    assert_eq!(candidate(vec![-1.4, 17.9, 18.9, 19.9]), 1086);
    assert_eq!(candidate(vec![0.0]), 0);
    assert_eq!(candidate(vec![-1.0]), 1);
    assert_eq!(candidate(vec![-1.0, 1.0, 0.0]), 2);
}

-----------------------------
/// You are given a vector of numbers.
/// You need to return the sum of squared numbers in the given vector,
/// round each element in the vector to the upper int(Ceiling) first.
/// Examples:
/// >>> lst(vec![1.0, 2.0, 3.0])
/// 14
/// >>> lst(vec![1.0, 4.0, 9.0])
/// 98
/// >>> lst(vec![1.0, 3.0, 5.0, 7.0])
/// 84
/// >>> lst(vec![1.4, 4.2, 0.0])
/// 29
/// >>> lst(vec![-2.4, 1.0, 1.0])
/// 6
fn sum_squares(lst: Vec<f64>) -> isize {

    let mut vect = lst.into_iter().map(|x| x.ceil() as isize).collect::<Vec<isize>>();
    vect.sort();
    let mut ret = 0;
    for item in vect {
        ret += item * item;
    }
    ret as isize
}

fn main() {
    let candidate = sum_squares;
    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);
    assert_eq!(candidate(vec![1.0, 3.0, 5.0, 7.0]), 84);
    assert_eq!(candidate(vec![1.4, 4.2, 0.0]), 29);
    assert_eq!(candidate(vec![-2.4, 1.0, 1.0]), 6);
    assert_eq!(candidate(vec![100.0, 1.0, 15.0, 2.0]), 10230);
    assert_eq!(candidate(vec![10000.0, 10000.0]), 200000000);
    assert_eq!(candidate(vec![-1.4, 4.6, 6.3]), 75);
    assert_eq!(candidate(vec![-1.4, 17.9, 18.9, 19.9]), 1086);
    assert_eq!(candidate(vec![0.0]), 0);
    assert_eq!(candidate(vec![-1.0]), 1);
    assert_eq!(candidate(vec![-1.0, 1.0, 0.0]), 2);
}

-----------------------------
/// You are given a vector of numbers.
/// You need to return the sum of squared numbers in the given vector,
/// round each element in the vector to the upper int(Ceiling) first.
/// Examples:
/// >>> lst(vec![1.0, 2.0, 3.0])
/// 14
/// >>> lst(vec![1.0, 4.0, 9.0])
/// 98
/// >>> lst(vec![1.0, 3.0, 5.0, 7.0])
/// 84
/// >>> lst(vec![1.4, 4.2, 0.0])
/// 29
/// >>> lst(vec![-2.4, 1.0, 1.0])
/// 6
fn sum_squares(lst: Vec<f64>) -> isize {

    lst.iter().map(|x| x.ceil() as isize).fold(0, |acc, x| acc + x*x)
}

fn main() {
    let candidate = sum_squares;
    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);
    assert_eq!(candidate(vec![1.0, 3.0, 5.0, 7.0]), 84);
    assert_eq!(candidate(vec![1.4, 4.2, 0.0]), 29);
    assert_eq!(candidate(vec![-2.4, 1.0, 1.0]), 6);
    assert_eq!(candidate(vec![100.0, 1.0, 15.0, 2.0]), 10230);
    assert_eq!(candidate(vec![10000.0, 10000.0]), 200000000);
    assert_eq!(candidate(vec![-1.4, 4.6, 6.3]), 75);
    assert_eq!(candidate(vec![-1.4, 17.9, 18.9, 19.9]), 1086);
    assert_eq!(candidate(vec![0.0]), 0);
    assert_eq!(candidate(vec![-1.0]), 1);
    assert_eq!(candidate(vec![-1.0, 1.0, 0.0]), 2);
}

-----------------------------
/// You are given a vector of numbers.
/// You need to return the sum of squared numbers in the given vector,
/// round each element in the vector to the upper int(Ceiling) first.
/// Examples:
/// >>> lst(vec![1.0, 2.0, 3.0])
/// 14
/// >>> lst(vec![1.0, 4.0, 9.0])
/// 98
/// >>> lst(vec![1.0, 3.0, 5.0, 7.0])
/// 84
/// >>> lst(vec![1.4, 4.2, 0.0])
/// 29
/// >>> lst(vec![-2.4, 1.0, 1.0])
/// 6
fn sum_squares(lst: Vec<f64>) -> isize {

    let mut rst = 0;
    for x in lst {
        rst += (x as isize).pow(2);
    }
    rst
}

fn main() {
    let candidate = sum_squares;
    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);
    assert_eq!(candidate(vec![1.0, 3.0, 5.0, 7.0]), 84);
    assert_eq!(candidate(vec![1.4, 4.2, 0.0]), 29);
    assert_eq!(candidate(vec![-2.4, 1.0, 1.0]), 6);
    assert_eq!(candidate(vec![100.0, 1.0, 15.0, 2.0]), 10230);
    assert_eq!(candidate(vec![10000.0, 10000.0]), 200000000);
    assert_eq!(candidate(vec![-1.4, 4.6, 6.3]), 75);
    assert_eq!(candidate(vec![-1.4, 17.9, 18.9, 19.9]), 1086);
    assert_eq!(candidate(vec![0.0]), 0);
    assert_eq!(candidate(vec![-1.0]), 1);
    assert_eq!(candidate(vec![-1.0, 1.0, 0.0]), 2);
}

===============================
/// Create a function that returns true if the last character
/// of a given string is an alphabetical character and is not
/// a part of a word, and false otherwise.
/// Note: "word" is a group of characters separated by space.
/// Examples:
/// >>> check_if_last_char_is_a_letter(String::from("apple pie"))
/// false
/// >>> check_if_last_char_is_a_letter(String::from("apple pi e"))
/// true
/// >>> check_if_last_char_is_a_letter(String::from("apple pi e "))
/// false
/// >>> check_if_last_char_is_a_letter(String::from(""))
/// false
fn check_if_last_char_is_a_letter(txt: String) -> bool {

===============================
-----------------------------
/// Create a function that returns true if the last character
/// of a given string is an alphabetical character and is not
/// a part of a word, and false otherwise.
/// Note: "word" is a group of characters separated by space.
/// Examples:
/// >>> check_if_last_char_is_a_letter(String::from("apple pie"))
/// false
/// >>> check_if_last_char_is_a_letter(String::from("apple pi e"))
/// true
/// >>> check_if_last_char_is_a_letter(String::from("apple pi e "))
/// false
/// >>> check_if_last_char_is_a_letter(String::from(""))
/// false
fn check_if_last_char_is_a_letter(txt: String) -> bool {

    if txt.len() == 0 {
        return false;
    }

    let last = txt.chars().last().unwrap();
    let is_alpha = matches!(last, 'a'..='z' | 'A'..='Z');
    if is_alpha {
        return is_last_char_part_of_word(txt);
    }

    return false;
}

fn main() {
    let candidate = check_if_last_char_is_a_letter;
    assert_eq!(candidate(String::from("apple")), false);
    assert_eq!(candidate(String::from("apple pi e")), true);
    assert_eq!(candidate(String::from("eeeee")), false);
    assert_eq!(candidate(String::from("A")), true);
    assert_eq!(candidate(String::from("Pumpkin pie ")), false);
    assert_eq!(candidate(String::from("Pumpkin pie 1")), false);
    assert_eq!(candidate(String::from("")), false);
    assert_eq!(candidate(String::from("eeeee e ")), false);
    assert_eq!(candidate(String::from("apple pie")), false);
    assert_eq!(candidate(String::from("apple pi e ")), false);
}

-----------------------------
/// Create a function that returns true if the last character
/// of a given string is an alphabetical character and is not
/// a part of a word, and false otherwise.
/// Note: "word" is a group of characters separated by space.
/// Examples:
/// >>> check_if_last_char_is_a_letter(String::from("apple pie"))
/// false
/// >>> check_if_last_char_is_a_letter(String::from("apple pi e"))
/// true
/// >>> check_if_last_char_is_a_letter(String::from("apple pi e "))
/// false
/// >>> check_if_last_char_is_a_letter(String::from(""))
/// false
fn check_if_last_char_is_a_letter(txt: String) -> bool {

    if txt.is_empty() {
        return false;
    }

    let last_char = txt.chars().last().unwrap();
    if !last_char.is_alphabetic() {
        return false;
    }

    let mut chunks: Vec<&str> = txt.split_whitespace().collect();

    if let Some(chunk) = chunks.last() {
        if chunk.chars().count() == 1 {
            return true;
        }
    }

    false
}

fn main() {
    let candidate = check_if_last_char_is_a_letter;
    assert_eq!(candidate(String::from("apple")), false);
    assert_eq!(candidate(String::from("apple pi e")), true);
    assert_eq!(candidate(String::from("eeeee")), false);
    assert_eq!(candidate(String::from("A")), true);
    assert_eq!(candidate(String::from("Pumpkin pie ")), false);
    assert_eq!(candidate(String::from("Pumpkin pie 1")), false);
    assert_eq!(candidate(String::from("")), false);
    assert_eq!(candidate(String::from("eeeee e ")), false);
    assert_eq!(candidate(String::from("apple pie")), false);
    assert_eq!(candidate(String::from("apple pi e ")), false);
}

-----------------------------
/// Create a function that returns true if the last character
/// of a given string is an alphabetical character and is not
/// a part of a word, and false otherwise.
/// Note: "word" is a group of characters separated by space.
/// Examples:
/// >>> check_if_last_char_is_a_letter(String::from("apple pie"))
/// false
/// >>> check_if_last_char_is_a_letter(String::from("apple pi e"))
/// true
/// >>> check_if_last_char_is_a_letter(String::from("apple pi e "))
/// false
/// >>> check_if_last_char_is_a_letter(String::from(""))
/// false
fn check_if_last_char_is_a_letter(txt: String) -> bool {

    let ch = txt.chars().last();
    match ch {
        Some(c) => c.is_alphabetic() && !txt.ends_with(" "),
        None => false,
    }
}

fn main() {
    let candidate = check_if_last_char_is_a_letter;
    assert_eq!(candidate(String::from("apple")), false);
    assert_eq!(candidate(String::from("apple pi e")), true);
    assert_eq!(candidate(String::from("eeeee")), false);
    assert_eq!(candidate(String::from("A")), true);
    assert_eq!(candidate(String::from("Pumpkin pie ")), false);
    assert_eq!(candidate(String::from("Pumpkin pie 1")), false);
    assert_eq!(candidate(String::from("")), false);
    assert_eq!(candidate(String::from("eeeee e ")), false);
    assert_eq!(candidate(String::from("apple pie")), false);
    assert_eq!(candidate(String::from("apple pi e ")), false);
}

-----------------------------
/// Create a function that returns true if the last character
/// of a given string is an alphabetical character and is not
/// a part of a word, and false otherwise.
/// Note: "word" is a group of characters separated by space.
/// Examples:
/// >>> check_if_last_char_is_a_letter(String::from("apple pie"))
/// false
/// >>> check_if_last_char_is_a_letter(String::from("apple pi e"))
/// true
/// >>> check_if_last_char_is_a_letter(String::from("apple pi e "))
/// false
/// >>> check_if_last_char_is_a_letter(String::from(""))
/// false
fn check_if_last_char_is_a_letter(txt: String) -> bool {

    if txt.len() == 0 {
        return false;
    }
    let last_char = txt.chars().last().unwrap();
    let is_last_char_letter = last_char.is_alphabetic();
    let is_last_char_part_of_word = txt.chars().count() > 1 && !last_char.is_whitespace();
    is_last_char_letter && !is_last_char_part_of_word
}

fn main() {
    let candidate = check_if_last_char_is_a_letter;
    assert_eq!(candidate(String::from("apple")), false);
    assert_eq!(candidate(String::from("apple pi e")), true);
    assert_eq!(candidate(String::from("eeeee")), false);
    assert_eq!(candidate(String::from("A")), true);
    assert_eq!(candidate(String::from("Pumpkin pie ")), false);
    assert_eq!(candidate(String::from("Pumpkin pie 1")), false);
    assert_eq!(candidate(String::from("")), false);
    assert_eq!(candidate(String::from("eeeee e ")), false);
    assert_eq!(candidate(String::from("apple pie")), false);
    assert_eq!(candidate(String::from("apple pi e ")), false);
}

-----------------------------
/// Create a function that returns true if the last character
/// of a given string is an alphabetical character and is not
/// a part of a word, and false otherwise.
/// Note: "word" is a group of characters separated by space.
/// Examples:
/// >>> check_if_last_char_is_a_letter(String::from("apple pie"))
/// false
/// >>> check_if_last_char_is_a_letter(String::from("apple pi e"))
/// true
/// >>> check_if_last_char_is_a_letter(String::from("apple pi e "))
/// false
/// >>> check_if_last_char_is_a_letter(String::from(""))
/// false
fn check_if_last_char_is_a_letter(txt: String) -> bool {

    // TODO: implement this function
    unimplemented!();
}

fn main() {
    let candidate = check_if_last_char_is_a_letter;
    assert_eq!(candidate(String::from("apple")), false);
    assert_eq!(candidate(String::from("apple pi e")), true);
    assert_eq!(candidate(String::from("eeeee")), false);
    assert_eq!(candidate(String::from("A")), true);
    assert_eq!(candidate(String::from("Pumpkin pie ")), false);
    assert_eq!(candidate(String::from("Pumpkin pie 1")), false);
    assert_eq!(candidate(String::from("")), false);
    assert_eq!(candidate(String::from("eeeee e ")), false);
    assert_eq!(candidate(String::from("apple pie")), false);
    assert_eq!(candidate(String::from("apple pi e ")), false);
}

===============================
/// Create a function which returns the largest index of an element which
/// is not greater than or equal to the element immediately preceding it. If
/// no such element exists then return -1. The given vector will not contain
/// duplicate values.
/// Examples:
/// >>> can_arrange(vec![1, 2, 4, 3, 5])
/// 3
/// >>> can_arrange(vec![1, 2, 3])
/// -1
fn can_arrange(arr: Vec<isize>) -> isize {

===============================
-----------------------------
/// Create a function which returns the largest index of an element which
/// is not greater than or equal to the element immediately preceding it. If
/// no such element exists then return -1. The given vector will not contain
/// duplicate values.
/// Examples:
/// >>> can_arrange(vec![1, 2, 4, 3, 5])
/// 3
/// >>> can_arrange(vec![1, 2, 3])
/// -1
fn can_arrange(arr: Vec<isize>) -> isize {

    // Brute force approach: O(n^2)
    /*
    let mut max = -1;
    for i in 0..arr.len() {
        let mut flag = false;
        for j in (i+1)..arr.len() {
            if arr[i] <= arr[j] {
                flag = true;
            }
        }
        if flag {
            max = i;
        }
    }
    if max < 0 {
        -1
    } else {
        max
    }
    */

    // Optimized approach: O(n log n)
    arr.sort();
    let mut res = 0;
    let mut j = 1;
    while j < arr.len() {
        if arr[j] > arr[res] {
            res = j;
        }
        j += 1;
    }

    if arr[res] < arr[0] {
        -1
    } else {
        res
    }
}

fn main() {
    let candidate = can_arrange;
    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);
    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);
    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);
    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);
    assert_eq!(candidate(Vec::<isize>::new()), -1);
}

-----------------------------
/// Create a function which returns the largest index of an element which
/// is not greater than or equal to the element immediately preceding it. If
/// no such element exists then return -1. The given vector will not contain
/// duplicate values.
/// Examples:
/// >>> can_arrange(vec![1, 2, 4, 3, 5])
/// 3
/// >>> can_arrange(vec![1, 2, 3])
/// -1
fn can_arrange(arr: Vec<isize>) -> isize {

    if arr.len() <= 2 {
        return -1;
    }

    let mut next_max = arr[arr.len() - 1];
    let mut index = arr.len() as isize - 1;
    for i in (arr.len() - 2..0).rev() {
        if arr[i] < next_max {
            next_max = arr[i];
            index = i as isize;
        }
    }
    index
}

fn main() {
    let candidate = can_arrange;
    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);
    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);
    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);
    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);
    assert_eq!(candidate(Vec::<isize>::new()), -1);
}

-----------------------------
/// Create a function which returns the largest index of an element which
/// is not greater than or equal to the element immediately preceding it. If
/// no such element exists then return -1. The given vector will not contain
/// duplicate values.
/// Examples:
/// >>> can_arrange(vec![1, 2, 4, 3, 5])
/// 3
/// >>> can_arrange(vec![1, 2, 3])
/// -1
fn can_arrange(arr: Vec<isize>) -> isize {

    if arr.len() == 1 {
        return -1;
    }

    let mut i: isize = 0;

    for j in 0..arr.len() {
        let mut j_is_larger_than_i = false;
        for k in i..j {
            if arr[j as usize] >= arr[k as usize] {
                j_is_larger_than_i = true;
                break;
            }
        }

        if j_is_larger_than_i {
            continue;
        }

        i = j;
    }

    if i == arr.len() as isize - 1 {
        return -1;
    }

    i
}

fn main() {
    let candidate = can_arrange;
    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);
    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);
    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);
    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);
    assert_eq!(candidate(Vec::<isize>::new()), -1);
}

-----------------------------
/// Create a function which returns the largest index of an element which
/// is not greater than or equal to the element immediately preceding it. If
/// no such element exists then return -1. The given vector will not contain
/// duplicate values.
/// Examples:
/// >>> can_arrange(vec![1, 2, 4, 3, 5])
/// 3
/// >>> can_arrange(vec![1, 2, 3])
/// -1
fn can_arrange(arr: Vec<isize>) -> isize {

    if arr.len() <= 1 {
        return -1;
    }
    let mut result = -1;
    let mut current_max = -1;
    let mut current_min = std::isize::MAX;
    for i in 0..arr.len() {
        if arr[i] <= current_min {
            current_max = i;
            current_min = arr[i];
        }
        if arr[i] >= current_max {
            result = i;
        }
    }
    if current_min == std::isize::MAX {
        -1
    } else {
        result
    }
}

fn main() {
    let candidate = can_arrange;
    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);
    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);
    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);
    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);
    assert_eq!(candidate(Vec::<isize>::new()), -1);
}

-----------------------------
/// Create a function which returns the largest index of an element which
/// is not greater than or equal to the element immediately preceding it. If
/// no such element exists then return -1. The given vector will not contain
/// duplicate values.
/// Examples:
/// >>> can_arrange(vec![1, 2, 4, 3, 5])
/// 3
/// >>> can_arrange(vec![1, 2, 3])
/// -1
fn can_arrange(arr: Vec<isize>) -> isize {

    let mut arr: Vec<isize> = arr;
    let mut left = 0;
    let mut right = 0;

    arr.sort();
    for i in 0..arr.len() {
        let mut j = i;
        while j > 0 {
            if arr[i] < arr[j - 1] {
                arr[i] = arr[j - 1];
            } else {
                break;
            }
            j -= 1;
        }
    }

    for i in 0..arr.len() {
        if arr[i] == i as isize {
            return i as isize;
        }
        if arr[i] > i as isize {
            left = i as isize;
            break;
        }
    }

    for i in (0..arr.len()).rev() {
        if arr[i] == i as isize {
            return i as isize;
        }
        if arr[i] < i as isize {
            right = i as isize;
            break;
        }
    }

    if left == 0 && right == 0 {
        return -1;
    }
    if left > 0 && right > 0 {
        return -1;
    }
    if left == 0 {
        return right;
    }
    if right == 0 {
        return left;
    }
    -1
}

fn main() {
    let candidate = can_arrange;
    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);
    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);
    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);
    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);
    assert_eq!(candidate(Vec::<isize>::new()), -1);
}

===============================
/// Create a function that returns a tuple (a, b), where 'a' is
/// the largest of negative integers, and 'b' is the smallest
/// of positive integers in a vector.
/// If there is no negative or positive integers, return them as None.
/// Examples:
/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])
/// (None, Some(1))
/// >>> largest_smallest_integers(vec![])
/// (None, None)
/// >>> largest_smallest_integers(vec![0])
/// (None, None)
fn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {

===============================
-----------------------------
/// Create a function that returns a tuple (a, b), where 'a' is
/// the largest of negative integers, and 'b' is the smallest
/// of positive integers in a vector.
/// If there is no negative or positive integers, return them as None.
/// Examples:
/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])
/// (None, Some(1))
/// >>> largest_smallest_integers(vec![])
/// (None, None)
/// >>> largest_smallest_integers(vec![0])
/// (None, None)
fn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {

    let mut negative = None;
    let mut positive = None;
    for &val in &lst {
        match val {
            x if x > 0 => {
                if positive.is_none() || positive.unwrap() < x {
                    positive = Some(x);
                }
            }
            x if x < 0 => {
                if negative.is_none() || negative.unwrap() > x {
                    negative = Some(x);
                }
            }
            _ => (),
        }
    }
    (negative, positive)
}

fn main() {
    let candidate = largest_smallest_integers;
    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));
    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None, Some(1)));
    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2), Some(1)));
    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7), Some(2)));
    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9), Some(2)));
    assert_eq!(candidate(Vec::<isize>::new()), (None, None));
    assert_eq!(candidate(vec![0]), (None, None));
    assert_eq!(candidate(vec![-1, -3, -5, -6]), (Some(-1), None));
    assert_eq!(candidate(vec![-1, -3, -5, -6, 0]), (Some(-1), None));
    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]), (Some(-3), Some(1)));
    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]), (Some(-3), Some(1)));
}

-----------------------------
/// Create a function that returns a tuple (a, b), where 'a' is
/// the largest of negative integers, and 'b' is the smallest
/// of positive integers in a vector.
/// If there is no negative or positive integers, return them as None.
/// Examples:
/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])
/// (None, Some(1))
/// >>> largest_smallest_integers(vec![])
/// (None, None)
/// >>> largest_smallest_integers(vec![0])
/// (None, None)
fn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {

    // TODO: implement me
    (None, None)
}

fn main() {
    let candidate = largest_smallest_integers;
    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));
    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None, Some(1)));
    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2), Some(1)));
    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7), Some(2)));
    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9), Some(2)));
    assert_eq!(candidate(Vec::<isize>::new()), (None, None));
    assert_eq!(candidate(vec![0]), (None, None));
    assert_eq!(candidate(vec![-1, -3, -5, -6]), (Some(-1), None));
    assert_eq!(candidate(vec![-1, -3, -5, -6, 0]), (Some(-1), None));
    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]), (Some(-3), Some(1)));
    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]), (Some(-3), Some(1)));
}

-----------------------------
/// Create a function that returns a tuple (a, b), where 'a' is
/// the largest of negative integers, and 'b' is the smallest
/// of positive integers in a vector.
/// If there is no negative or positive integers, return them as None.
/// Examples:
/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])
/// (None, Some(1))
/// >>> largest_smallest_integers(vec![])
/// (None, None)
/// >>> largest_smallest_integers(vec![0])
/// (None, None)
fn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {

    if lst.len() == 0 {
        return (None, None)
    }

    let mut largest_negative = None;
    let mut smallest_positive = None;

    for &val in &lst {
        match val {
            _ if val > 0 => {
                if let Some(smallest_positive_num) = smallest_positive {
                    if val < smallest_positive_num {
                        smallest_positive = Some(val);
                    }
                }
                else {
                    smallest_positive = Some(val);
                }
            }
            _ if val < 0 => {
                if let Some(largest_negative_num) = largest_negative {
                    if val > largest_negative_num {
                        largest_negative = Some(val);
                    }
                }
                else {
                    largest_negative = Some(val);
                }
            }
            _ => ()
        }
    }
    (largest_negative, smallest_positive)
}

fn main() {
    let candidate = largest_smallest_integers;
    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));
    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None, Some(1)));
    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2), Some(1)));
    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7), Some(2)));
    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9), Some(2)));
    assert_eq!(candidate(Vec::<isize>::new()), (None, None));
    assert_eq!(candidate(vec![0]), (None, None));
    assert_eq!(candidate(vec![-1, -3, -5, -6]), (Some(-1), None));
    assert_eq!(candidate(vec![-1, -3, -5, -6, 0]), (Some(-1), None));
    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]), (Some(-3), Some(1)));
    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]), (Some(-3), Some(1)));
}

-----------------------------
/// Create a function that returns a tuple (a, b), where 'a' is
/// the largest of negative integers, and 'b' is the smallest
/// of positive integers in a vector.
/// If there is no negative or positive integers, return them as None.
/// Examples:
/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])
/// (None, Some(1))
/// >>> largest_smallest_integers(vec![])
/// (None, None)
/// >>> largest_smallest_integers(vec![0])
/// (None, None)
fn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {

    let mut largest: Option<isize> = None;
    let mut smallest: Option<isize> = None;

    for &x in lst.iter() {
        if x < 0 {
            if smallest.is_some() && x < smallest.unwrap() {
                continue;
            } else {
                smallest = Some(x)
            }
        } else if largest.is_none() || x > largest.unwrap() {
            largest = Some(x);
        }
    }

    (largest, smallest)
}

fn main() {
    let candidate = largest_smallest_integers;
    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));
    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None, Some(1)));
    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2), Some(1)));
    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7), Some(2)));
    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9), Some(2)));
    assert_eq!(candidate(Vec::<isize>::new()), (None, None));
    assert_eq!(candidate(vec![0]), (None, None));
    assert_eq!(candidate(vec![-1, -3, -5, -6]), (Some(-1), None));
    assert_eq!(candidate(vec![-1, -3, -5, -6, 0]), (Some(-1), None));
    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]), (Some(-3), Some(1)));
    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]), (Some(-3), Some(1)));
}

-----------------------------
/// Create a function that returns a tuple (a, b), where 'a' is
/// the largest of negative integers, and 'b' is the smallest
/// of positive integers in a vector.
/// If there is no negative or positive integers, return them as None.
/// Examples:
/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])
/// (None, Some(1))
/// >>> largest_smallest_integers(vec![])
/// (None, None)
/// >>> largest_smallest_integers(vec![0])
/// (None, None)
fn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {

    let mut largest = None;
    let mut smallest = None;
    for i in lst {
        if i >= 0 {
            if smallest == None {
                smallest = Some(i);
            } else {
                if i > smallest.unwrap() {
                    smallest = Some(i);
                }
            }
        } else if largest == None {
            largest = Some(i);
        } else {
            if i < largest.unwrap() {
                largest = Some(i);
            }
        }
    }
    (largest, smallest)
}

fn main() {
    let candidate = largest_smallest_integers;
    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));
    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None, Some(1)));
    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2), Some(1)));
    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7), Some(2)));
    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9), Some(2)));
    assert_eq!(candidate(Vec::<isize>::new()), (None, None));
    assert_eq!(candidate(vec![0]), (None, None));
    assert_eq!(candidate(vec![-1, -3, -5, -6]), (Some(-1), None));
    assert_eq!(candidate(vec![-1, -3, -5, -6, 0]), (Some(-1), None));
    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]), (Some(-3), Some(1)));
    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]), (Some(-3), Some(1)));
}

===============================
/// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
/// Example
/// >>> is_equal_to_sum_even(4)
/// false
/// >>> is_equal_to_sum_even(6)
/// false
/// >>> is_equal_to_sum_even(8)
/// true
fn is_equal_to_sum_even(n: isize) -> bool {

===============================
-----------------------------
/// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
/// Example
/// >>> is_equal_to_sum_even(4)
/// false
/// >>> is_equal_to_sum_even(6)
/// false
/// >>> is_equal_to_sum_even(8)
/// true
fn is_equal_to_sum_even(n: isize) -> bool {

    return n % 4 == 0;
}

fn main() {
    let candidate = is_equal_to_sum_even;
    assert_eq!(candidate(4), false);
    assert_eq!(candidate(6), false);
    assert_eq!(candidate(8), true);
    assert_eq!(candidate(10), true);
    assert_eq!(candidate(11), false);
    assert_eq!(candidate(12), true);
    assert_eq!(candidate(13), false);
    assert_eq!(candidate(16), true);
}

-----------------------------
/// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
/// Example
/// >>> is_equal_to_sum_even(4)
/// false
/// >>> is_equal_to_sum_even(6)
/// false
/// >>> is_equal_to_sum_even(8)
/// true
fn is_equal_to_sum_even(n: isize) -> bool {

    let x = (n + 1) / 2;
    let y = (n + 2) / 2;
    let z = (n + 3) / 2;
    let t = (n + 4) / 2;
    let a = (n + 1) % 2;
    let b = (n + 2) % 2;
    let c = (n + 3) % 2;
    let d = (n + 4) % 2;
    match (a, b, c, d) {
        (1, 0, 1, 0) => x + y == n,
        (1, 0, 0, 1) => x + z == n,
        (1, 0, 1, 1) => x + y + z == n,
        (1, 0, 0, 0) => x + t == n,
        (1, 1, 0, 1) => x + y + t == n,
        (1, 1, 0, 0) => x + y + z + t == n,
        (1, 1, 1, 0) => x + y + z == n,
        (1, 1, 1, 1) => x + y == n,
        _ => false,
    }
}

fn main() {
    let candidate = is_equal_to_sum_even;
    assert_eq!(candidate(4), false);
    assert_eq!(candidate(6), false);
    assert_eq!(candidate(8), true);
    assert_eq!(candidate(10), true);
    assert_eq!(candidate(11), false);
    assert_eq!(candidate(12), true);
    assert_eq!(candidate(13), false);
    assert_eq!(candidate(16), true);
}

-----------------------------
/// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
/// Example
/// >>> is_equal_to_sum_even(4)
/// false
/// >>> is_equal_to_sum_even(6)
/// false
/// >>> is_equal_to_sum_even(8)
/// true
fn is_equal_to_sum_even(n: isize) -> bool {

    let n = n as usize;
    if n < 6 {
        false
    } else {
        let mut a = n - 4;
        let mut b = n - 2;
        let mut c = n - 6;
        let mut d = n - 8;
        loop {
            if a == 0 || b == 0 || c == 0 || d == 0 {
                break;
            }
            let sum = 2 * a + 2 * b + 2 * c + 2 * d;
            if sum == n {
                return true;
            } else if sum > n {
                d -= 1;
            } else {
                c -= 1;
            }
        }
        false
    }
}

fn main() {
    let candidate = is_equal_to_sum_even;
    assert_eq!(candidate(4), false);
    assert_eq!(candidate(6), false);
    assert_eq!(candidate(8), true);
    assert_eq!(candidate(10), true);
    assert_eq!(candidate(11), false);
    assert_eq!(candidate(12), true);
    assert_eq!(candidate(13), false);
    assert_eq!(candidate(16), true);
}

-----------------------------
/// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
/// Example
/// >>> is_equal_to_sum_even(4)
/// false
/// >>> is_equal_to_sum_even(6)
/// false
/// >>> is_equal_to_sum_even(8)
/// true
fn is_equal_to_sum_even(n: isize) -> bool {

    if n <= 0 || n % 2 != 0 {
        return false;
    }
    let sum_of_two_squares = (n * (n - 2)).abs() / 2;
    let difference = n * (n + 2);
    if sum_of_two_squares * 2 == difference {
        true
    } else {
        false
    }
}

fn main() {
    let candidate = is_equal_to_sum_even;
    assert_eq!(candidate(4), false);
    assert_eq!(candidate(6), false);
    assert_eq!(candidate(8), true);
    assert_eq!(candidate(10), true);
    assert_eq!(candidate(11), false);
    assert_eq!(candidate(12), true);
    assert_eq!(candidate(13), false);
    assert_eq!(candidate(16), true);
}

-----------------------------
/// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
/// Example
/// >>> is_equal_to_sum_even(4)
/// false
/// >>> is_equal_to_sum_even(6)
/// false
/// >>> is_equal_to_sum_even(8)
/// true
fn is_equal_to_sum_even(n: isize) -> bool {

    if n == 0 {
        return false;
    }
    if n % 2 == 1 {
        return false;
    }
    for a in 1..n {
        for b in a + 1..n {
            for c in b + 1..n {
                let d = n - a - b - c;
                if d > b && d % 2 == 0 && (a + b + c + d) == n {
                    return true;
                }
            }
        }
    }
    false
}

fn main() {
    let candidate = is_equal_to_sum_even;
    assert_eq!(candidate(4), false);
    assert_eq!(candidate(6), false);
    assert_eq!(candidate(8), true);
    assert_eq!(candidate(10), true);
    assert_eq!(candidate(11), false);
    assert_eq!(candidate(12), true);
    assert_eq!(candidate(13), false);
    assert_eq!(candidate(16), true);
}

===============================
/// The Brazilian factorial is defined as:
/// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
/// where n > 0
/// For example:
/// >>> special_factorial(4)
/// 288
/// The function will receive an integer as input and should return the special
/// factorial of this integer.
fn special_factorial(n: isize) -> isize {

===============================
-----------------------------
/// The Brazilian factorial is defined as:
/// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
/// where n > 0
/// For example:
/// >>> special_factorial(4)
/// 288
/// The function will receive an integer as input and should return the special
/// factorial of this integer.
fn special_factorial(n: isize) -> isize {

    if n < 0 {
        return -1;
    }
    let mut result: isize = 1;
    for i in 1..=n {
        result *= (i as isize);
        for j in 2..=n {
            result *= (j as isize);
        }
    }
    result
}

fn main() {
    let candidate = special_factorial;
    assert_eq!(candidate(4), 288);
    assert_eq!(candidate(5), 34560);
    assert_eq!(candidate(7), 125411328000);
    assert_eq!(candidate(1), 1);
}

-----------------------------
/// The Brazilian factorial is defined as:
/// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
/// where n > 0
/// For example:
/// >>> special_factorial(4)
/// 288
/// The function will receive an integer as input and should return the special
/// factorial of this integer.
fn special_factorial(n: isize) -> isize {

    let mut num: isize = 1;
    for i in 1..=n {
        num *= i * brazilian_factorial(n - i);
    }
    num
}

fn main() {
    let candidate = special_factorial;
    assert_eq!(candidate(4), 288);
    assert_eq!(candidate(5), 34560);
    assert_eq!(candidate(7), 125411328000);
    assert_eq!(candidate(1), 1);
}

-----------------------------
/// The Brazilian factorial is defined as:
/// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
/// where n > 0
/// For example:
/// >>> special_factorial(4)
/// 288
/// The function will receive an integer as input and should return the special
/// factorial of this integer.
fn special_factorial(n: isize) -> isize {

    if n < 0 {
        return 0;
    } else if n == 0 {
        return 1;
    } else {
        let mut ret = n;
        for i in 1..n {
            ret = ret * (i - 1);
        }
        return ret;
    }
}

fn main() {
    let candidate = special_factorial;
    assert_eq!(candidate(4), 288);
    assert_eq!(candidate(5), 34560);
    assert_eq!(candidate(7), 125411328000);
    assert_eq!(candidate(1), 1);
}

-----------------------------
/// The Brazilian factorial is defined as:
/// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
/// where n > 0
/// For example:
/// >>> special_factorial(4)
/// 288
/// The function will receive an integer as input and should return the special
/// factorial of this integer.
fn special_factorial(n: isize) -> isize {

    if n <= 0 {
        return 1;
    }
    let mut result = n;
    for i in 2..=n {
        result *= i;
    }
    result
}

fn main() {
    let candidate = special_factorial;
    assert_eq!(candidate(4), 288);
    assert_eq!(candidate(5), 34560);
    assert_eq!(candidate(7), 125411328000);
    assert_eq!(candidate(1), 1);
}

-----------------------------
/// The Brazilian factorial is defined as:
/// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
/// where n > 0
/// For example:
/// >>> special_factorial(4)
/// 288
/// The function will receive an integer as input and should return the special
/// factorial of this integer.
fn special_factorial(n: isize) -> isize {

    (1..=n).fold(1, |acc, i| acc * i * (n - i + 1))
}

fn main() {
    let candidate = special_factorial;
    assert_eq!(candidate(4), 288);
    assert_eq!(candidate(5), 34560);
    assert_eq!(candidate(7), 125411328000);
    assert_eq!(candidate(1), 1);
}

===============================
/// Given a string text, replace all spaces in it with underscores, 
/// and if a string has more than 2 consecutive spaces, 
/// then replace all consecutive spaces with - 
/// >>> fix_spaces(String::from(" Example"))
/// String::from("Example")
/// >>> fix_spaces(String::from(" Example 1"))
/// String::from("Example_1")
/// >>> fix_spaces(String::from(" Example 2"))
/// String::from("_Example_2")
/// >>> fix_spaces(String::from(" Example 3"))
/// String::from("_Example-3")
fn fix_spaces(text: String) -> String {

===============================
-----------------------------
/// Given a string text, replace all spaces in it with underscores, 
/// and if a string has more than 2 consecutive spaces, 
/// then replace all consecutive spaces with - 
/// >>> fix_spaces(String::from(" Example"))
/// String::from("Example")
/// >>> fix_spaces(String::from(" Example 1"))
/// String::from("Example_1")
/// >>> fix_spaces(String::from(" Example 2"))
/// String::from("_Example_2")
/// >>> fix_spaces(String::from(" Example 3"))
/// String::from("_Example-3")
fn fix_spaces(text: String) -> String {

    text.split_whitespace()
        .fold(String::from(""), |a, b| a + b.to_uppercase().replace(" ", "_"))
}

fn main() {
    let candidate = fix_spaces;
    assert_eq!(candidate(String::from("Example")), String::from("Example"));
    assert_eq!(candidate(String::from("Mudasir Hanif ")), String::from("Mudasir_Hanif_"));
    assert_eq!(candidate(String::from("Yellow Yellow  Dirty  Fellow")), String::from("Yellow_Yellow__Dirty__Fellow"));
    assert_eq!(candidate(String::from("Exa   mple")), String::from("Exa-mple"));
    assert_eq!(candidate(String::from("   Exa 1 2 2 mple")), String::from("-Exa_1_2_2_mple"));
}

-----------------------------
/// Given a string text, replace all spaces in it with underscores, 
/// and if a string has more than 2 consecutive spaces, 
/// then replace all consecutive spaces with - 
/// >>> fix_spaces(String::from(" Example"))
/// String::from("Example")
/// >>> fix_spaces(String::from(" Example 1"))
/// String::from("Example_1")
/// >>> fix_spaces(String::from(" Example 2"))
/// String::from("_Example_2")
/// >>> fix_spaces(String::from(" Example 3"))
/// String::from("_Example-3")
fn fix_spaces(text: String) -> String {

    let mut result = String::new();
    for i in 0..text.len() {
        let is_space = text.chars().nth(i).unwrap().is_ascii_whitespace();
        if is_space {
            let (count, _): (i32, String) = text.chars().skip(i).take_while(|c| c.is_ascii_whitespace()).fold((0, result), |(count, mut text), c| {
                if count > 2 {
                    text.push('-');
                } else {
                    text.push('_');
                }
                (count + 1, text)
            });
            let text = result + &text;
            result = text.replace(' ', "");
        } else {
            result.push(text.chars().nth(i).unwrap());
        }
    }
    result
}

fn main() {
    let candidate = fix_spaces;
    assert_eq!(candidate(String::from("Example")), String::from("Example"));
    assert_eq!(candidate(String::from("Mudasir Hanif ")), String::from("Mudasir_Hanif_"));
    assert_eq!(candidate(String::from("Yellow Yellow  Dirty  Fellow")), String::from("Yellow_Yellow__Dirty__Fellow"));
    assert_eq!(candidate(String::from("Exa   mple")), String::from("Exa-mple"));
    assert_eq!(candidate(String::from("   Exa 1 2 2 mple")), String::from("-Exa_1_2_2_mple"));
}

-----------------------------
/// Given a string text, replace all spaces in it with underscores, 
/// and if a string has more than 2 consecutive spaces, 
/// then replace all consecutive spaces with - 
/// >>> fix_spaces(String::from(" Example"))
/// String::from("Example")
/// >>> fix_spaces(String::from(" Example 1"))
/// String::from("Example_1")
/// >>> fix_spaces(String::from(" Example 2"))
/// String::from("_Example_2")
/// >>> fix_spaces(String::from(" Example 3"))
/// String::from("_Example-3")
fn fix_spaces(text: String) -> String {

    let mut result = String::with_capacity(text.len());
    for c in text.chars() {
        match c {
            ' ' if result.len() == 0 => result.push('_'),
            ' ' => result.push('-'),
            _ => result.push(c),
        }
    }
    if result.ends_with('_') {
        result.pop();
    }
    result
}

fn main() {
    let candidate = fix_spaces;
    assert_eq!(candidate(String::from("Example")), String::from("Example"));
    assert_eq!(candidate(String::from("Mudasir Hanif ")), String::from("Mudasir_Hanif_"));
    assert_eq!(candidate(String::from("Yellow Yellow  Dirty  Fellow")), String::from("Yellow_Yellow__Dirty__Fellow"));
    assert_eq!(candidate(String::from("Exa   mple")), String::from("Exa-mple"));
    assert_eq!(candidate(String::from("   Exa 1 2 2 mple")), String::from("-Exa_1_2_2_mple"));
}

-----------------------------
/// Given a string text, replace all spaces in it with underscores, 
/// and if a string has more than 2 consecutive spaces, 
/// then replace all consecutive spaces with - 
/// >>> fix_spaces(String::from(" Example"))
/// String::from("Example")
/// >>> fix_spaces(String::from(" Example 1"))
/// String::from("Example_1")
/// >>> fix_spaces(String::from(" Example 2"))
/// String::from("_Example_2")
/// >>> fix_spaces(String::from(" Example 3"))
/// String::from("_Example-3")
fn fix_spaces(text: String) -> String {

    let mut result: String = "".to_string();
    for ch in text.chars() {
        if ch == ' ' {
            if result.ends_with('-') {
                result.push('-');
            } else {
                result.push('_');
            }
        } else {
            result.push(ch);
        }
    }
    result
}

fn main() {
    let candidate = fix_spaces;
    assert_eq!(candidate(String::from("Example")), String::from("Example"));
    assert_eq!(candidate(String::from("Mudasir Hanif ")), String::from("Mudasir_Hanif_"));
    assert_eq!(candidate(String::from("Yellow Yellow  Dirty  Fellow")), String::from("Yellow_Yellow__Dirty__Fellow"));
    assert_eq!(candidate(String::from("Exa   mple")), String::from("Exa-mple"));
    assert_eq!(candidate(String::from("   Exa 1 2 2 mple")), String::from("-Exa_1_2_2_mple"));
}

-----------------------------
/// Given a string text, replace all spaces in it with underscores, 
/// and if a string has more than 2 consecutive spaces, 
/// then replace all consecutive spaces with - 
/// >>> fix_spaces(String::from(" Example"))
/// String::from("Example")
/// >>> fix_spaces(String::from(" Example 1"))
/// String::from("Example_1")
/// >>> fix_spaces(String::from(" Example 2"))
/// String::from("_Example_2")
/// >>> fix_spaces(String::from(" Example 3"))
/// String::from("_Example-3")
fn fix_spaces(text: String) -> String {

    // Return the text with all spaces replaced with underscores.
    text.replace(" ", "_").replace("  ", "-").to_string()
}

fn main() {
    let candidate = fix_spaces;
    assert_eq!(candidate(String::from("Example")), String::from("Example"));
    assert_eq!(candidate(String::from("Mudasir Hanif ")), String::from("Mudasir_Hanif_"));
    assert_eq!(candidate(String::from("Yellow Yellow  Dirty  Fellow")), String::from("Yellow_Yellow__Dirty__Fellow"));
    assert_eq!(candidate(String::from("Exa   mple")), String::from("Exa-mple"));
    assert_eq!(candidate(String::from("   Exa 1 2 2 mple")), String::from("-Exa_1_2_2_mple"));
}

===============================
/// Create a function which takes a string representing a file's name, and returns
/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.
/// A file's name is considered to be valid if and only if all the following conditions 
/// are met:
/// - There should not be more than three digits ('0'-'9') in the file's name.
/// - The file's name contains exactly one dot '.'
/// - The substring before the dot should not be empty, and it starts with a letter from 
/// the latin alphapet ('a'-'z' and 'A'-'Z').
/// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
/// Examples:
/// >>> file_name_check(String::from("example.txt"))
/// String::from("Yes")
/// >>> file_name_check(String::from("1example.dll"))
/// String::from("No")
fn file_name_check(file_name: String) -> String {

===============================
-----------------------------
/// Create a function which takes a string representing a file's name, and returns
/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.
/// A file's name is considered to be valid if and only if all the following conditions 
/// are met:
/// - There should not be more than three digits ('0'-'9') in the file's name.
/// - The file's name contains exactly one dot '.'
/// - The substring before the dot should not be empty, and it starts with a letter from 
/// the latin alphapet ('a'-'z' and 'A'-'Z').
/// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
/// Examples:
/// >>> file_name_check(String::from("example.txt"))
/// String::from("Yes")
/// >>> file_name_check(String::from("1example.dll"))
/// String::from("No")
fn file_name_check(file_name: String) -> String {

    let re = Regex::new(r"[0-9]{4,}").unwrap();
    let re2 = Regex::new(r"^[a-zA-Z]").unwrap();
    let re3 = Regex::new(r"[a-zA-Z].txt$|[a-zA-Z].exe$|[a-zA-Z].dll$").unwrap();
    if re.is_match(&file_name) {
        return String::from("No");
    }
    if !re2.is_match(&file_name) {
        return String::from("No");
    }
    if !re3.is_match(&file_name) {
        return String::from("No");
    }
    String::from("Yes")
}

fn main() {
    let candidate = file_name_check;
    assert_eq!(candidate(String::from("example.txt")), String::from("Yes"));
    assert_eq!(candidate(String::from("1example.dll")), String::from("No"));
    assert_eq!(candidate(String::from("s1sdf3.asd")), String::from("No"));
    assert_eq!(candidate(String::from("K.dll")), String::from("Yes"));
    assert_eq!(candidate(String::from("MY16FILE3.exe")), String::from("Yes"));
    assert_eq!(candidate(String::from("His12FILE94.exe")), String::from("No"));
    assert_eq!(candidate(String::from("_Y.txt")), String::from("No"));
    assert_eq!(candidate(String::from("?aREYA.exe")), String::from("No"));
    assert_eq!(candidate(String::from("/this_is_valid.dll")), String::from("No"));
    assert_eq!(candidate(String::from("this_is_valid.wow")), String::from("No"));
    assert_eq!(candidate(String::from("this_is_valid.txt")), String::from("Yes"));
    assert_eq!(candidate(String::from("this_is_valid.txtexe")), String::from("No"));
    assert_eq!(candidate(String::from("#this2_i4s_5valid.ten")), String::from("No"));
    assert_eq!(candidate(String::from("@this1_is6_valid.exe")), String::from("No"));
    assert_eq!(candidate(String::from("this_is_12valid.6exe4.txt")), String::from("No"));
    assert_eq!(candidate(String::from("all.exe.txt")), String::from("No"));
    assert_eq!(candidate(String::from("I563_No.exe")), String::from("Yes"));
    assert_eq!(candidate(String::from("Is3youfault.txt")), String::from("Yes"));
    assert_eq!(candidate(String::from("no_one#knows.dll")), String::from("Yes"));
    assert_eq!(candidate(String::from("1I563_Yes3.exe")), String::from("No"));
    assert_eq!(candidate(String::from("I563_Yes3.txtt")), String::from("No"));
    assert_eq!(candidate(String::from("final..txt")), String::from("No"));
    assert_eq!(candidate(String::from("final132")), String::from("No"));
    assert_eq!(candidate(String::from("_f4indsartal132.")), String::from("No"));
    assert_eq!(candidate(String::from(".txt")), String::from("No"));
    assert_eq!(candidate(String::from("s.")), String::from("No"));
}

-----------------------------
/// Create a function which takes a string representing a file's name, and returns
/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.
/// A file's name is considered to be valid if and only if all the following conditions 
/// are met:
/// - There should not be more than three digits ('0'-'9') in the file's name.
/// - The file's name contains exactly one dot '.'
/// - The substring before the dot should not be empty, and it starts with a letter from 
/// the latin alphapet ('a'-'z' and 'A'-'Z').
/// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
/// Examples:
/// >>> file_name_check(String::from("example.txt"))
/// String::from("Yes")
/// >>> file_name_check(String::from("1example.dll"))
/// String::from("No")
fn file_name_check(file_name: String) -> String {

    return "No".to_string();
}

fn main() {
    let candidate = file_name_check;
    assert_eq!(candidate(String::from("example.txt")), String::from("Yes"));
    assert_eq!(candidate(String::from("1example.dll")), String::from("No"));
    assert_eq!(candidate(String::from("s1sdf3.asd")), String::from("No"));
    assert_eq!(candidate(String::from("K.dll")), String::from("Yes"));
    assert_eq!(candidate(String::from("MY16FILE3.exe")), String::from("Yes"));
    assert_eq!(candidate(String::from("His12FILE94.exe")), String::from("No"));
    assert_eq!(candidate(String::from("_Y.txt")), String::from("No"));
    assert_eq!(candidate(String::from("?aREYA.exe")), String::from("No"));
    assert_eq!(candidate(String::from("/this_is_valid.dll")), String::from("No"));
    assert_eq!(candidate(String::from("this_is_valid.wow")), String::from("No"));
    assert_eq!(candidate(String::from("this_is_valid.txt")), String::from("Yes"));
    assert_eq!(candidate(String::from("this_is_valid.txtexe")), String::from("No"));
    assert_eq!(candidate(String::from("#this2_i4s_5valid.ten")), String::from("No"));
    assert_eq!(candidate(String::from("@this1_is6_valid.exe")), String::from("No"));
    assert_eq!(candidate(String::from("this_is_12valid.6exe4.txt")), String::from("No"));
    assert_eq!(candidate(String::from("all.exe.txt")), String::from("No"));
    assert_eq!(candidate(String::from("I563_No.exe")), String::from("Yes"));
    assert_eq!(candidate(String::from("Is3youfault.txt")), String::from("Yes"));
    assert_eq!(candidate(String::from("no_one#knows.dll")), String::from("Yes"));
    assert_eq!(candidate(String::from("1I563_Yes3.exe")), String::from("No"));
    assert_eq!(candidate(String::from("I563_Yes3.txtt")), String::from("No"));
    assert_eq!(candidate(String::from("final..txt")), String::from("No"));
    assert_eq!(candidate(String::from("final132")), String::from("No"));
    assert_eq!(candidate(String::from("_f4indsartal132.")), String::from("No"));
    assert_eq!(candidate(String::from(".txt")), String::from("No"));
    assert_eq!(candidate(String::from("s.")), String::from("No"));
}

-----------------------------
/// Create a function which takes a string representing a file's name, and returns
/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.
/// A file's name is considered to be valid if and only if all the following conditions 
/// are met:
/// - There should not be more than three digits ('0'-'9') in the file's name.
/// - The file's name contains exactly one dot '.'
/// - The substring before the dot should not be empty, and it starts with a letter from 
/// the latin alphapet ('a'-'z' and 'A'-'Z').
/// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
/// Examples:
/// >>> file_name_check(String::from("example.txt"))
/// String::from("Yes")
/// >>> file_name_check(String::from("1example.dll"))
/// String::from("No")
fn file_name_check(file_name: String) -> String {

    // let mut name_parts: Vec<String> = file_name.split(".").map(|s| String::from(s)).collect();
    // let name_parts: Vec<String> = file_name.split(".").map(|s| String::from(s)).collect();
    // let mut name_parts: Vec<&str> = file_name.split(".").collect();
    // let mut name_parts = file_name.split(".").collect::<Vec<&str>>();
    let mut name_parts: Vec<&str> = file_name.split(".").collect::<Vec<&str>>();
    if name_parts.len() > 3 {
        return String::from("No");
    }
    if name_parts[0].chars().count() > 3 {
        return String::from("No");
    }
    if name_parts.len() == 3 && name_parts[2].chars().count() > 3 {
        return String::from("No");
    }
    if name_parts[0].chars().count() == 0 {
        return String::from("No");
    }
    if !name_parts[0].chars().next().unwrap().is_alphabetic() {
        return String::from("No");
    }
    match name_parts[1] {
        "exe" | "dll" | "txt" => {}
        _ => return String::from("No"),
    }
    return String::from("Yes");
}

fn main() {
    let candidate = file_name_check;
    assert_eq!(candidate(String::from("example.txt")), String::from("Yes"));
    assert_eq!(candidate(String::from("1example.dll")), String::from("No"));
    assert_eq!(candidate(String::from("s1sdf3.asd")), String::from("No"));
    assert_eq!(candidate(String::from("K.dll")), String::from("Yes"));
    assert_eq!(candidate(String::from("MY16FILE3.exe")), String::from("Yes"));
    assert_eq!(candidate(String::from("His12FILE94.exe")), String::from("No"));
    assert_eq!(candidate(String::from("_Y.txt")), String::from("No"));
    assert_eq!(candidate(String::from("?aREYA.exe")), String::from("No"));
    assert_eq!(candidate(String::from("/this_is_valid.dll")), String::from("No"));
    assert_eq!(candidate(String::from("this_is_valid.wow")), String::from("No"));
    assert_eq!(candidate(String::from("this_is_valid.txt")), String::from("Yes"));
    assert_eq!(candidate(String::from("this_is_valid.txtexe")), String::from("No"));
    assert_eq!(candidate(String::from("#this2_i4s_5valid.ten")), String::from("No"));
    assert_eq!(candidate(String::from("@this1_is6_valid.exe")), String::from("No"));
    assert_eq!(candidate(String::from("this_is_12valid.6exe4.txt")), String::from("No"));
    assert_eq!(candidate(String::from("all.exe.txt")), String::from("No"));
    assert_eq!(candidate(String::from("I563_No.exe")), String::from("Yes"));
    assert_eq!(candidate(String::from("Is3youfault.txt")), String::from("Yes"));
    assert_eq!(candidate(String::from("no_one#knows.dll")), String::from("Yes"));
    assert_eq!(candidate(String::from("1I563_Yes3.exe")), String::from("No"));
    assert_eq!(candidate(String::from("I563_Yes3.txtt")), String::from("No"));
    assert_eq!(candidate(String::from("final..txt")), String::from("No"));
    assert_eq!(candidate(String::from("final132")), String::from("No"));
    assert_eq!(candidate(String::from("_f4indsartal132.")), String::from("No"));
    assert_eq!(candidate(String::from(".txt")), String::from("No"));
    assert_eq!(candidate(String::from("s.")), String::from("No"));
}

-----------------------------
/// Create a function which takes a string representing a file's name, and returns
/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.
/// A file's name is considered to be valid if and only if all the following conditions 
/// are met:
/// - There should not be more than three digits ('0'-'9') in the file's name.
/// - The file's name contains exactly one dot '.'
/// - The substring before the dot should not be empty, and it starts with a letter from 
/// the latin alphapet ('a'-'z' and 'A'-'Z').
/// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
/// Examples:
/// >>> file_name_check(String::from("example.txt"))
/// String::from("Yes")
/// >>> file_name_check(String::from("1example.dll"))
/// String::from("No")
fn file_name_check(file_name: String) -> String {

    let mut validity = false;

    for (i, c) in file_name.chars().enumerate() {
        if c.is_ascii_digit() && file_name.chars().filter(|&x| x.is_ascii_digit()).count() > 3 {
            return String::from("No");
        }

        if c.is_ascii_alphanumeric() && i == 0 {
            validity = true;
        }
    }

    if validity {
        match &file_name[file_name.len() - 4..file_name.len()] {
            "txt" | "exe" | "dll" => String::from("Yes"),
            _ => String::from("No"),
        }
    } else {
        String::from("No")
    }
}

fn main() {
    let candidate = file_name_check;
    assert_eq!(candidate(String::from("example.txt")), String::from("Yes"));
    assert_eq!(candidate(String::from("1example.dll")), String::from("No"));
    assert_eq!(candidate(String::from("s1sdf3.asd")), String::from("No"));
    assert_eq!(candidate(String::from("K.dll")), String::from("Yes"));
    assert_eq!(candidate(String::from("MY16FILE3.exe")), String::from("Yes"));
    assert_eq!(candidate(String::from("His12FILE94.exe")), String::from("No"));
    assert_eq!(candidate(String::from("_Y.txt")), String::from("No"));
    assert_eq!(candidate(String::from("?aREYA.exe")), String::from("No"));
    assert_eq!(candidate(String::from("/this_is_valid.dll")), String::from("No"));
    assert_eq!(candidate(String::from("this_is_valid.wow")), String::from("No"));
    assert_eq!(candidate(String::from("this_is_valid.txt")), String::from("Yes"));
    assert_eq!(candidate(String::from("this_is_valid.txtexe")), String::from("No"));
    assert_eq!(candidate(String::from("#this2_i4s_5valid.ten")), String::from("No"));
    assert_eq!(candidate(String::from("@this1_is6_valid.exe")), String::from("No"));
    assert_eq!(candidate(String::from("this_is_12valid.6exe4.txt")), String::from("No"));
    assert_eq!(candidate(String::from("all.exe.txt")), String::from("No"));
    assert_eq!(candidate(String::from("I563_No.exe")), String::from("Yes"));
    assert_eq!(candidate(String::from("Is3youfault.txt")), String::from("Yes"));
    assert_eq!(candidate(String::from("no_one#knows.dll")), String::from("Yes"));
    assert_eq!(candidate(String::from("1I563_Yes3.exe")), String::from("No"));
    assert_eq!(candidate(String::from("I563_Yes3.txtt")), String::from("No"));
    assert_eq!(candidate(String::from("final..txt")), String::from("No"));
    assert_eq!(candidate(String::from("final132")), String::from("No"));
    assert_eq!(candidate(String::from("_f4indsartal132.")), String::from("No"));
    assert_eq!(candidate(String::from(".txt")), String::from("No"));
    assert_eq!(candidate(String::from("s.")), String::from("No"));
}

-----------------------------
/// Create a function which takes a string representing a file's name, and returns
/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.
/// A file's name is considered to be valid if and only if all the following conditions 
/// are met:
/// - There should not be more than three digits ('0'-'9') in the file's name.
/// - The file's name contains exactly one dot '.'
/// - The substring before the dot should not be empty, and it starts with a letter from 
/// the latin alphapet ('a'-'z' and 'A'-'Z').
/// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
/// Examples:
/// >>> file_name_check(String::from("example.txt"))
/// String::from("Yes")
/// >>> file_name_check(String::from("1example.dll"))
/// String::from("No")
fn file_name_check(file_name: String) -> String {

    let file_name_chars = file_name.chars().collect::<Vec<char>>();
    if file_name_chars.len() > 12 {
        return String::from("No");
    }
    let mut dot_count: i8 = 0;
    let mut chars_with_dot: Vec<char> = vec![];
    let mut chars_before_dot: Vec<char> = vec![];
    let mut chars_after_dot: Vec<char> = vec![];
    for (index, char) in file_name_chars.iter().enumerate() {
        match char {
            '.' => {
                if dot_count > 0 {
                    return String::from("No");
                }
                dot_count += 1;
            }
            '0'..='9' => {
                if chars_with_dot.len() > 0 {
                    return String::from("No");
                }
                if chars_before_dot.len() > 3 {
                    return String::from("No");
                }
            }
            _ => {
                if dot_count == 0 {
                    chars_before_dot.push(*char);
                } else {
                    chars_after_dot.push(*char);
                }
            }
        }
    }

    if chars_after_dot.len() == 0 {
        return String::from("No");
    }
    let chars_after_dot_str = chars_after_dot.iter().collect::<String>();
    if chars_after_dot_str != "dll" && chars_after_dot_str != "exe" && chars_after_dot_str != "txt" {
        return String::from("No");
    }

    String::from("Yes")
}

fn main() {
    let candidate = file_name_check;
    assert_eq!(candidate(String::from("example.txt")), String::from("Yes"));
    assert_eq!(candidate(String::from("1example.dll")), String::from("No"));
    assert_eq!(candidate(String::from("s1sdf3.asd")), String::from("No"));
    assert_eq!(candidate(String::from("K.dll")), String::from("Yes"));
    assert_eq!(candidate(String::from("MY16FILE3.exe")), String::from("Yes"));
    assert_eq!(candidate(String::from("His12FILE94.exe")), String::from("No"));
    assert_eq!(candidate(String::from("_Y.txt")), String::from("No"));
    assert_eq!(candidate(String::from("?aREYA.exe")), String::from("No"));
    assert_eq!(candidate(String::from("/this_is_valid.dll")), String::from("No"));
    assert_eq!(candidate(String::from("this_is_valid.wow")), String::from("No"));
    assert_eq!(candidate(String::from("this_is_valid.txt")), String::from("Yes"));
    assert_eq!(candidate(String::from("this_is_valid.txtexe")), String::from("No"));
    assert_eq!(candidate(String::from("#this2_i4s_5valid.ten")), String::from("No"));
    assert_eq!(candidate(String::from("@this1_is6_valid.exe")), String::from("No"));
    assert_eq!(candidate(String::from("this_is_12valid.6exe4.txt")), String::from("No"));
    assert_eq!(candidate(String::from("all.exe.txt")), String::from("No"));
    assert_eq!(candidate(String::from("I563_No.exe")), String::from("Yes"));
    assert_eq!(candidate(String::from("Is3youfault.txt")), String::from("Yes"));
    assert_eq!(candidate(String::from("no_one#knows.dll")), String::from("Yes"));
    assert_eq!(candidate(String::from("1I563_Yes3.exe")), String::from("No"));
    assert_eq!(candidate(String::from("I563_Yes3.txtt")), String::from("No"));
    assert_eq!(candidate(String::from("final..txt")), String::from("No"));
    assert_eq!(candidate(String::from("final132")), String::from("No"));
    assert_eq!(candidate(String::from("_f4indsartal132.")), String::from("No"));
    assert_eq!(candidate(String::from(".txt")), String::from("No"));
    assert_eq!(candidate(String::from("s.")), String::from("No"));
}

===============================
/// "
/// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a 
/// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not 
/// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. 
/// Examples:
/// >>> lst
/// vec![1, 2, 3]
/// >>> lst
/// vec![]
/// >>> lst
/// vec![-1, -5, 2, -1, -5]
fn sum_squares(lst: Vec<isize>) -> isize {

===============================
-----------------------------
/// "
/// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a 
/// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not 
/// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. 
/// Examples:
/// >>> lst
/// vec![1, 2, 3]
/// >>> lst
/// vec![]
/// >>> lst
/// vec![-1, -5, 2, -1, -5]
fn sum_squares(lst: Vec<isize>) -> isize {

    let mut sum = 0;
    for (index, value) in lst.iter().enumerate() {
        if index % 3 == 0 && index % 4 != 0 {
            sum += value.pow(2);
        }
        if index % 4 == 0 && index % 3 != 0 {
            sum += value.pow(3);
        }
    }

    sum
}

fn main() {
    let candidate = sum_squares;
    assert_eq!(candidate(vec![1, 2, 3]), 6);
    assert_eq!(candidate(vec![1, 4, 9]), 14);
    assert_eq!(candidate(Vec::<isize>::new()), 0);
    assert_eq!(candidate(vec![1, 1, 1, 1, 1, 1, 1, 1, 1]), 9);
    assert_eq!(candidate(vec![-1, -1, -1, -1, -1, -1, -1, -1, -1]), -3);
    assert_eq!(candidate(vec![0]), 0);
    assert_eq!(candidate(vec![-1, -5, 2, -1, -5]), -126);
    assert_eq!(candidate(vec![-56, -99, 1, 0, -2]), 3030);
    assert_eq!(candidate(vec![-1, 0, 0, 0, 0, 0, 0, 0, -1]), 0);
    assert_eq!(candidate(vec![-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]), -14196);
    assert_eq!(candidate(vec![-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]), -1448);
}

-----------------------------
/// "
/// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a 
/// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not 
/// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. 
/// Examples:
/// >>> lst
/// vec![1, 2, 3]
/// >>> lst
/// vec![]
/// >>> lst
/// vec![-1, -5, 2, -1, -5]
fn sum_squares(lst: Vec<isize>) -> isize {

    let mut sum = 0;

    for (i, element) in lst.iter().enumerate() {
        if i % 3 == 0 {
            sum += element.pow(2);
        }

        if i % 4 == 0 && i % 3 != 0 {
            sum += element.pow(3);
        }
    }

    sum
}

fn main() {
    let candidate = sum_squares;
    assert_eq!(candidate(vec![1, 2, 3]), 6);
    assert_eq!(candidate(vec![1, 4, 9]), 14);
    assert_eq!(candidate(Vec::<isize>::new()), 0);
    assert_eq!(candidate(vec![1, 1, 1, 1, 1, 1, 1, 1, 1]), 9);
    assert_eq!(candidate(vec![-1, -1, -1, -1, -1, -1, -1, -1, -1]), -3);
    assert_eq!(candidate(vec![0]), 0);
    assert_eq!(candidate(vec![-1, -5, 2, -1, -5]), -126);
    assert_eq!(candidate(vec![-56, -99, 1, 0, -2]), 3030);
    assert_eq!(candidate(vec![-1, 0, 0, 0, 0, 0, 0, 0, -1]), 0);
    assert_eq!(candidate(vec![-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]), -14196);
    assert_eq!(candidate(vec![-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]), -1448);
}

-----------------------------
/// "
/// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a 
/// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not 
/// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. 
/// Examples:
/// >>> lst
/// vec![1, 2, 3]
/// >>> lst
/// vec![]
/// >>> lst
/// vec![-1, -5, 2, -1, -5]
fn sum_squares(lst: Vec<isize>) -> isize {

    //let mut new_lst: Vec<isize> = Vec::new();
    let mut new_lst: Vec<isize> = lst.clone();
    let mut i = 0;
    for x in lst {
        if (i % 3) == 0 && (i % 4) != 0 {
            new_lst[i] = x * x;
            //new_lst.push(x * x);
        } else if (i % 4) == 0 && (i % 3) != 0 {
            new_lst[i] = x * x * x;
            //new_lst.push(x * x * x);
        }
        i += 1;
    }
    println!("{:?}", new_lst);
    let mut sum = 0;
    for x in new_lst {
        sum += x;
    }
    sum
}

fn main() {
    let candidate = sum_squares;
    assert_eq!(candidate(vec![1, 2, 3]), 6);
    assert_eq!(candidate(vec![1, 4, 9]), 14);
    assert_eq!(candidate(Vec::<isize>::new()), 0);
    assert_eq!(candidate(vec![1, 1, 1, 1, 1, 1, 1, 1, 1]), 9);
    assert_eq!(candidate(vec![-1, -1, -1, -1, -1, -1, -1, -1, -1]), -3);
    assert_eq!(candidate(vec![0]), 0);
    assert_eq!(candidate(vec![-1, -5, 2, -1, -5]), -126);
    assert_eq!(candidate(vec![-56, -99, 1, 0, -2]), 3030);
    assert_eq!(candidate(vec![-1, 0, 0, 0, 0, 0, 0, 0, -1]), 0);
    assert_eq!(candidate(vec![-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]), -14196);
    assert_eq!(candidate(vec![-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]), -1448);
}

-----------------------------
/// "
/// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a 
/// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not 
/// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. 
/// Examples:
/// >>> lst
/// vec![1, 2, 3]
/// >>> lst
/// vec![]
/// >>> lst
/// vec![-1, -5, 2, -1, -5]
fn sum_squares(lst: Vec<isize>) -> isize {

    let mut sum = 0;

    for (idx, num) in lst.iter().enumerate() {
        let square = |x| x * x;
        let cube = |x| x * x * x;

        match (idx % 4, idx % 3) {
            (0, 0) => sum += square(*num),
            (0, _) => sum += cube(*num),
            _ => {}
        }
    }

    sum
}

fn main() {
    let candidate = sum_squares;
    assert_eq!(candidate(vec![1, 2, 3]), 6);
    assert_eq!(candidate(vec![1, 4, 9]), 14);
    assert_eq!(candidate(Vec::<isize>::new()), 0);
    assert_eq!(candidate(vec![1, 1, 1, 1, 1, 1, 1, 1, 1]), 9);
    assert_eq!(candidate(vec![-1, -1, -1, -1, -1, -1, -1, -1, -1]), -3);
    assert_eq!(candidate(vec![0]), 0);
    assert_eq!(candidate(vec![-1, -5, 2, -1, -5]), -126);
    assert_eq!(candidate(vec![-56, -99, 1, 0, -2]), 3030);
    assert_eq!(candidate(vec![-1, 0, 0, 0, 0, 0, 0, 0, -1]), 0);
    assert_eq!(candidate(vec![-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]), -14196);
    assert_eq!(candidate(vec![-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]), -1448);
}

-----------------------------
/// "
/// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a 
/// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not 
/// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. 
/// Examples:
/// >>> lst
/// vec![1, 2, 3]
/// >>> lst
/// vec![]
/// >>> lst
/// vec![-1, -5, 2, -1, -5]
fn sum_squares(lst: Vec<isize>) -> isize {

    let mut sum = 0;
    for (i, v) in lst.iter().enumerate() {
        if i % 3 == 0 && i % 4 != 0 {
            sum += v * v
        }
        if i % 3 == 1 && i % 4 != 1 {
            sum += v * v * v
        }
        if i % 3 == 2 && i % 4 != 2 {
            sum += v * v * v * v
        }
    }
    sum
}

fn main() {
    let candidate = sum_squares;
    assert_eq!(candidate(vec![1, 2, 3]), 6);
    assert_eq!(candidate(vec![1, 4, 9]), 14);
    assert_eq!(candidate(Vec::<isize>::new()), 0);
    assert_eq!(candidate(vec![1, 1, 1, 1, 1, 1, 1, 1, 1]), 9);
    assert_eq!(candidate(vec![-1, -1, -1, -1, -1, -1, -1, -1, -1]), -3);
    assert_eq!(candidate(vec![0]), 0);
    assert_eq!(candidate(vec![-1, -5, 2, -1, -5]), -126);
    assert_eq!(candidate(vec![-56, -99, 1, 0, -2]), 3030);
    assert_eq!(candidate(vec![-1, 0, 0, 0, 0, 0, 0, 0, -1]), 0);
    assert_eq!(candidate(vec![-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]), -14196);
    assert_eq!(candidate(vec![-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]), -1448);
}

===============================
/// You are given a string representing a sentence,
/// the sentence contains some words separated by a space,
/// and you have to return a string that contains the words from the original sentence,
/// whose lengths are prime numbers,
/// the order of the words in the new string should be the same as the original one.
/// Example 1:
/// >>> words_in_sentence(String::from("This is a test"))
/// String::from("is")
/// Example 2:
/// >>> words_in_sentence(String::from("lets go for swimming"))
/// String::from("go for")
/// Constraints:
/// * 1 <= len(sentence) <= 100
/// * sentence contains only letters
fn words_in_sentence(sentence: String) -> String {

===============================
-----------------------------
/// You are given a string representing a sentence,
/// the sentence contains some words separated by a space,
/// and you have to return a string that contains the words from the original sentence,
/// whose lengths are prime numbers,
/// the order of the words in the new string should be the same as the original one.
/// Example 1:
/// >>> words_in_sentence(String::from("This is a test"))
/// String::from("is")
/// Example 2:
/// >>> words_in_sentence(String::from("lets go for swimming"))
/// String::from("go for")
/// Constraints:
/// * 1 <= len(sentence) <= 100
/// * sentence contains only letters
fn words_in_sentence(sentence: String) -> String {

    // write your code here
    let mut prime_words = String::new();

    let words: Vec<&str> = sentence.split_ascii_whitespace().collect();

    for word in words {
        if word.chars().nth(0).unwrap().is_ascii_alphabetic()
            && word
                .chars()
                .nth(word.len() - 1)
                .unwrap()
                .is_ascii_alphabetic()
                && is_prime(word.len())
        {
            if prime_words.len() > 0 {
                prime_words.push_str(" ");
            }

            prime_words.push_str(word);
        }
    }

    prime_words
}

fn main() {
    let candidate = words_in_sentence;
    assert_eq!(candidate(String::from("This is a test")), String::from("is"));
    assert_eq!(candidate(String::from("lets go for swimming")), String::from("go for"));
    assert_eq!(candidate(String::from("there is no place available here")), String::from("there is no place"));
    assert_eq!(candidate(String::from("Hi I am Hussein")), String::from("Hi am Hussein"));
    assert_eq!(candidate(String::from("go for it")), String::from("go for it"));
    assert_eq!(candidate(String::from("here")), String::from(""));
    assert_eq!(candidate(String::from("here is")), String::from("is"));
}

-----------------------------
/// You are given a string representing a sentence,
/// the sentence contains some words separated by a space,
/// and you have to return a string that contains the words from the original sentence,
/// whose lengths are prime numbers,
/// the order of the words in the new string should be the same as the original one.
/// Example 1:
/// >>> words_in_sentence(String::from("This is a test"))
/// String::from("is")
/// Example 2:
/// >>> words_in_sentence(String::from("lets go for swimming"))
/// String::from("go for")
/// Constraints:
/// * 1 <= len(sentence) <= 100
/// * sentence contains only letters
fn words_in_sentence(sentence: String) -> String {

    let mut res = String::from("");
    let words = sentence.split(" ");
    for word in words {
        if word.len() > 0 && word.chars().nth(0).unwrap().is_alphabetic() {
            if word.len() > 1 && word.len() <= 100 && word.len() > 1 {
                if is_prime(word.len() as u32) {
                    res.push_str(word);
                    res.push_str(" ");
                }
            }
        }
    }
    res.trim().to_string()
}

fn main() {
    let candidate = words_in_sentence;
    assert_eq!(candidate(String::from("This is a test")), String::from("is"));
    assert_eq!(candidate(String::from("lets go for swimming")), String::from("go for"));
    assert_eq!(candidate(String::from("there is no place available here")), String::from("there is no place"));
    assert_eq!(candidate(String::from("Hi I am Hussein")), String::from("Hi am Hussein"));
    assert_eq!(candidate(String::from("go for it")), String::from("go for it"));
    assert_eq!(candidate(String::from("here")), String::from(""));
    assert_eq!(candidate(String::from("here is")), String::from("is"));
}

-----------------------------
/// You are given a string representing a sentence,
/// the sentence contains some words separated by a space,
/// and you have to return a string that contains the words from the original sentence,
/// whose lengths are prime numbers,
/// the order of the words in the new string should be the same as the original one.
/// Example 1:
/// >>> words_in_sentence(String::from("This is a test"))
/// String::from("is")
/// Example 2:
/// >>> words_in_sentence(String::from("lets go for swimming"))
/// String::from("go for")
/// Constraints:
/// * 1 <= len(sentence) <= 100
/// * sentence contains only letters
fn words_in_sentence(sentence: String) -> String {

    let sentence_words: Vec<&str> = sentence.split(" ").collect();
    let mut new_sentence_words = Vec::new();
    for word in sentence_words {
        if is_prime(word.len()) {
            new_sentence_words.push(word);
        }
    }
    let mut new_sentence = String::new();
    for word in new_sentence_words {
        new_sentence.push_str(word);
        new_sentence.push_str(" ");
    }
    new_sentence.pop();
    new_sentence
}

fn main() {
    let candidate = words_in_sentence;
    assert_eq!(candidate(String::from("This is a test")), String::from("is"));
    assert_eq!(candidate(String::from("lets go for swimming")), String::from("go for"));
    assert_eq!(candidate(String::from("there is no place available here")), String::from("there is no place"));
    assert_eq!(candidate(String::from("Hi I am Hussein")), String::from("Hi am Hussein"));
    assert_eq!(candidate(String::from("go for it")), String::from("go for it"));
    assert_eq!(candidate(String::from("here")), String::from(""));
    assert_eq!(candidate(String::from("here is")), String::from("is"));
}

-----------------------------
/// You are given a string representing a sentence,
/// the sentence contains some words separated by a space,
/// and you have to return a string that contains the words from the original sentence,
/// whose lengths are prime numbers,
/// the order of the words in the new string should be the same as the original one.
/// Example 1:
/// >>> words_in_sentence(String::from("This is a test"))
/// String::from("is")
/// Example 2:
/// >>> words_in_sentence(String::from("lets go for swimming"))
/// String::from("go for")
/// Constraints:
/// * 1 <= len(sentence) <= 100
/// * sentence contains only letters
fn words_in_sentence(sentence: String) -> String {

    // write code here
    let mut words: Vec<String> = sentence.split(" ").map(|x| x.to_string()).collect();

    for _ in 0..words.len() {
        for word in words.clone() {
            if !is_prime(word.len()) {
                words.remove(words.iter().position(|x| x == &word).unwrap());
            }
        }
    }

    if words.is_empty() {
        return "".to_string();
    }

    words.join(" ")
}

fn main() {
    let candidate = words_in_sentence;
    assert_eq!(candidate(String::from("This is a test")), String::from("is"));
    assert_eq!(candidate(String::from("lets go for swimming")), String::from("go for"));
    assert_eq!(candidate(String::from("there is no place available here")), String::from("there is no place"));
    assert_eq!(candidate(String::from("Hi I am Hussein")), String::from("Hi am Hussein"));
    assert_eq!(candidate(String::from("go for it")), String::from("go for it"));
    assert_eq!(candidate(String::from("here")), String::from(""));
    assert_eq!(candidate(String::from("here is")), String::from("is"));
}

-----------------------------
/// You are given a string representing a sentence,
/// the sentence contains some words separated by a space,
/// and you have to return a string that contains the words from the original sentence,
/// whose lengths are prime numbers,
/// the order of the words in the new string should be the same as the original one.
/// Example 1:
/// >>> words_in_sentence(String::from("This is a test"))
/// String::from("is")
/// Example 2:
/// >>> words_in_sentence(String::from("lets go for swimming"))
/// String::from("go for")
/// Constraints:
/// * 1 <= len(sentence) <= 100
/// * sentence contains only letters
fn words_in_sentence(sentence: String) -> String {

    // the trick is to take the slice of the string only for the words,
    // so the first word ends on the first space,
    // then we search for the next space and take the slice between the first and the second space,
    // and so on.

    let words: Vec<&str> = sentence.split(' ').collect();

    let mut res = String::new();
    for word in words {
        if is_prime(word.len()) {
            res.push_str(word);
            res.push(' ');
        }
    }

    res.pop(); // remove the last space

    res
}

fn main() {
    let candidate = words_in_sentence;
    assert_eq!(candidate(String::from("This is a test")), String::from("is"));
    assert_eq!(candidate(String::from("lets go for swimming")), String::from("go for"));
    assert_eq!(candidate(String::from("there is no place available here")), String::from("there is no place"));
    assert_eq!(candidate(String::from("Hi I am Hussein")), String::from("Hi am Hussein"));
    assert_eq!(candidate(String::from("go for it")), String::from("go for it"));
    assert_eq!(candidate(String::from("here")), String::from(""));
    assert_eq!(candidate(String::from("here is")), String::from("is"));
}

===============================
/// Your task is to implement a function that will simplify the expression
/// x * n. The function returns true if x * n evaluates to a whole number and false
/// otherwise. Both x and n, are string representation of a fraction, and have the following format,
/// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
/// You can assume that x, and n are valid fractions, and do not have zero as denominator.
/// >>> simplify(String::from("1/5"), String::from("5/1"))
/// true
/// >>> simplify(String::from("1/6"), String::from("2/1"))
/// false
/// >>> simplify(String::from("7/10"), String::from("10/2"))
/// false
fn simplify(x: String, n: String) -> bool {

===============================
-----------------------------
/// Your task is to implement a function that will simplify the expression
/// x * n. The function returns true if x * n evaluates to a whole number and false
/// otherwise. Both x and n, are string representation of a fraction, and have the following format,
/// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
/// You can assume that x, and n are valid fractions, and do not have zero as denominator.
/// >>> simplify(String::from("1/5"), String::from("5/1"))
/// true
/// >>> simplify(String::from("1/6"), String::from("2/1"))
/// false
/// >>> simplify(String::from("7/10"), String::from("10/2"))
/// false
fn simplify(x: String, n: String) -> bool {

    if x.parse::<i64>().unwrap() as f64 * n.parse::<i64>().unwrap() as f64
        == x.parse::<f64>().unwrap() * n.parse::<f64>().unwrap()
    {
        return true;
    }
    false
}

fn main() {
    let candidate = simplify;
    assert_eq!(candidate(String::from("1/5"), String::from("5/1")), true);
    assert_eq!(candidate(String::from("1/6"), String::from("2/1")), false);
    assert_eq!(candidate(String::from("5/1"), String::from("3/1")), true);
    assert_eq!(candidate(String::from("7/10"), String::from("10/2")), false);
    assert_eq!(candidate(String::from("2/10"), String::from("50/10")), true);
    assert_eq!(candidate(String::from("7/2"), String::from("4/2")), true);
    assert_eq!(candidate(String::from("11/6"), String::from("6/1")), true);
    assert_eq!(candidate(String::from("2/3"), String::from("5/2")), false);
    assert_eq!(candidate(String::from("5/2"), String::from("3/5")), false);
    assert_eq!(candidate(String::from("2/4"), String::from("8/4")), true);
    assert_eq!(candidate(String::from("2/4"), String::from("4/2")), true);
    assert_eq!(candidate(String::from("1/5"), String::from("5/1")), true);
    assert_eq!(candidate(String::from("1/5"), String::from("1/5")), false);
}

-----------------------------
/// Your task is to implement a function that will simplify the expression
/// x * n. The function returns true if x * n evaluates to a whole number and false
/// otherwise. Both x and n, are string representation of a fraction, and have the following format,
/// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
/// You can assume that x, and n are valid fractions, and do not have zero as denominator.
/// >>> simplify(String::from("1/5"), String::from("5/1"))
/// true
/// >>> simplify(String::from("1/6"), String::from("2/1"))
/// false
/// >>> simplify(String::from("7/10"), String::from("10/2"))
/// false
fn simplify(x: String, n: String) -> bool {

    let a = x.split('/').collect::<Vec<_>>();
    let b = n.split('/').collect::<Vec<_>>();
    let a: (i32, i32) = (a[0].parse().unwrap(), a[1].parse().unwrap());
    let b: (i32, i32) = (b[0].parse().unwrap(), b[1].parse().unwrap());
    let x = a.0 as f32 / a.1 as f32;
    let n = b.0 as f32 / b.1 as f32;
    (x * n).trunc() as i32 == x * n as i32
}

fn main() {
    let candidate = simplify;
    assert_eq!(candidate(String::from("1/5"), String::from("5/1")), true);
    assert_eq!(candidate(String::from("1/6"), String::from("2/1")), false);
    assert_eq!(candidate(String::from("5/1"), String::from("3/1")), true);
    assert_eq!(candidate(String::from("7/10"), String::from("10/2")), false);
    assert_eq!(candidate(String::from("2/10"), String::from("50/10")), true);
    assert_eq!(candidate(String::from("7/2"), String::from("4/2")), true);
    assert_eq!(candidate(String::from("11/6"), String::from("6/1")), true);
    assert_eq!(candidate(String::from("2/3"), String::from("5/2")), false);
    assert_eq!(candidate(String::from("5/2"), String::from("3/5")), false);
    assert_eq!(candidate(String::from("2/4"), String::from("8/4")), true);
    assert_eq!(candidate(String::from("2/4"), String::from("4/2")), true);
    assert_eq!(candidate(String::from("1/5"), String::from("5/1")), true);
    assert_eq!(candidate(String::from("1/5"), String::from("1/5")), false);
}

-----------------------------
/// Your task is to implement a function that will simplify the expression
/// x * n. The function returns true if x * n evaluates to a whole number and false
/// otherwise. Both x and n, are string representation of a fraction, and have the following format,
/// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
/// You can assume that x, and n are valid fractions, and do not have zero as denominator.
/// >>> simplify(String::from("1/5"), String::from("5/1"))
/// true
/// >>> simplify(String::from("1/6"), String::from("2/1"))
/// false
/// >>> simplify(String::from("7/10"), String::from("10/2"))
/// false
fn simplify(x: String, n: String) -> bool {

    let (x_num, x_den) = parse(x);
    let (n_num, n_den) = parse(n);

    if n_num == 0 {
        return true;
    }

    let (res_num, res_den) = (x_num * n_num, x_den * n_den);

    if res_num % res_den == 0 {
        true
    } else {
        false
    }
}

fn main() {
    let candidate = simplify;
    assert_eq!(candidate(String::from("1/5"), String::from("5/1")), true);
    assert_eq!(candidate(String::from("1/6"), String::from("2/1")), false);
    assert_eq!(candidate(String::from("5/1"), String::from("3/1")), true);
    assert_eq!(candidate(String::from("7/10"), String::from("10/2")), false);
    assert_eq!(candidate(String::from("2/10"), String::from("50/10")), true);
    assert_eq!(candidate(String::from("7/2"), String::from("4/2")), true);
    assert_eq!(candidate(String::from("11/6"), String::from("6/1")), true);
    assert_eq!(candidate(String::from("2/3"), String::from("5/2")), false);
    assert_eq!(candidate(String::from("5/2"), String::from("3/5")), false);
    assert_eq!(candidate(String::from("2/4"), String::from("8/4")), true);
    assert_eq!(candidate(String::from("2/4"), String::from("4/2")), true);
    assert_eq!(candidate(String::from("1/5"), String::from("5/1")), true);
    assert_eq!(candidate(String::from("1/5"), String::from("1/5")), false);
}

-----------------------------
/// Your task is to implement a function that will simplify the expression
/// x * n. The function returns true if x * n evaluates to a whole number and false
/// otherwise. Both x and n, are string representation of a fraction, and have the following format,
/// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
/// You can assume that x, and n are valid fractions, and do not have zero as denominator.
/// >>> simplify(String::from("1/5"), String::from("5/1"))
/// true
/// >>> simplify(String::from("1/6"), String::from("2/1"))
/// false
/// >>> simplify(String::from("7/10"), String::from("10/2"))
/// false
fn simplify(x: String, n: String) -> bool {

    let x = x.parse::<f32>().unwrap();
    let n = n.parse::<f32>().unwrap();
    let whole_number = f32::floor(x * n);
    whole_number == 0.0 || whole_number == x * n
}

fn main() {
    let candidate = simplify;
    assert_eq!(candidate(String::from("1/5"), String::from("5/1")), true);
    assert_eq!(candidate(String::from("1/6"), String::from("2/1")), false);
    assert_eq!(candidate(String::from("5/1"), String::from("3/1")), true);
    assert_eq!(candidate(String::from("7/10"), String::from("10/2")), false);
    assert_eq!(candidate(String::from("2/10"), String::from("50/10")), true);
    assert_eq!(candidate(String::from("7/2"), String::from("4/2")), true);
    assert_eq!(candidate(String::from("11/6"), String::from("6/1")), true);
    assert_eq!(candidate(String::from("2/3"), String::from("5/2")), false);
    assert_eq!(candidate(String::from("5/2"), String::from("3/5")), false);
    assert_eq!(candidate(String::from("2/4"), String::from("8/4")), true);
    assert_eq!(candidate(String::from("2/4"), String::from("4/2")), true);
    assert_eq!(candidate(String::from("1/5"), String::from("5/1")), true);
    assert_eq!(candidate(String::from("1/5"), String::from("1/5")), false);
}

-----------------------------
/// Your task is to implement a function that will simplify the expression
/// x * n. The function returns true if x * n evaluates to a whole number and false
/// otherwise. Both x and n, are string representation of a fraction, and have the following format,
/// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
/// You can assume that x, and n are valid fractions, and do not have zero as denominator.
/// >>> simplify(String::from("1/5"), String::from("5/1"))
/// true
/// >>> simplify(String::from("1/6"), String::from("2/1"))
/// false
/// >>> simplify(String::from("7/10"), String::from("10/2"))
/// false
fn simplify(x: String, n: String) -> bool {

    let mut split_x = x.split("/");
    let mut split_n = n.split("/");
    let mut x_num = split_x.next().unwrap().parse::<u32>().unwrap();
    let mut x_den = split_x.next().unwrap().parse::<u32>().unwrap();
    let mut n_num = split_n.next().unwrap().parse::<u32>().unwrap();
    let mut n_den = split_n.next().unwrap().parse::<u32>().unwrap();
    if x_den == 0 || n_den == 0 {
        return false;
    }

    x_num *= n_den;
    x_den *= n_num;

    if x_num == x_den {
        true
    } else {
        false
    }
}

fn main() {
    let candidate = simplify;
    assert_eq!(candidate(String::from("1/5"), String::from("5/1")), true);
    assert_eq!(candidate(String::from("1/6"), String::from("2/1")), false);
    assert_eq!(candidate(String::from("5/1"), String::from("3/1")), true);
    assert_eq!(candidate(String::from("7/10"), String::from("10/2")), false);
    assert_eq!(candidate(String::from("2/10"), String::from("50/10")), true);
    assert_eq!(candidate(String::from("7/2"), String::from("4/2")), true);
    assert_eq!(candidate(String::from("11/6"), String::from("6/1")), true);
    assert_eq!(candidate(String::from("2/3"), String::from("5/2")), false);
    assert_eq!(candidate(String::from("5/2"), String::from("3/5")), false);
    assert_eq!(candidate(String::from("2/4"), String::from("8/4")), true);
    assert_eq!(candidate(String::from("2/4"), String::from("4/2")), true);
    assert_eq!(candidate(String::from("1/5"), String::from("5/1")), true);
    assert_eq!(candidate(String::from("1/5"), String::from("1/5")), false);
}

===============================
/// Write a function which sorts the given vector of integers
/// in ascending order according to the sum of their digits.
/// Note: if there are several items with similar sum of their digits,
/// order them based on their index in original vector.
/// For example:
/// >>> order_by_points(vec![1, 11, -1, -11, -12])
/// vec![-1, -11, 1, -12, 11]
/// >>> order_by_points(vec![])
/// Vec::<isize>::new()
fn order_by_points(nums: Vec<isize>) -> Vec<isize> {

===============================
-----------------------------
/// Write a function which sorts the given vector of integers
/// in ascending order according to the sum of their digits.
/// Note: if there are several items with similar sum of their digits,
/// order them based on their index in original vector.
/// For example:
/// >>> order_by_points(vec![1, 11, -1, -11, -12])
/// vec![-1, -11, 1, -12, 11]
/// >>> order_by_points(vec![])
/// Vec::<isize>::new()
fn order_by_points(nums: Vec<isize>) -> Vec<isize> {

    let mut nums = nums;
    let mut result = Vec::<isize>::new();
    while nums.len() > 0 {
        let mut max_num = nums[0];
        let mut max_num_i = 0;
        for (i, &num) in nums.iter().enumerate() {
            if num == max_num {
                if result.contains(&num) {
                    continue;
                }
                max_num_i = i;
            } else if num > max_num {
                max_num = num;
                max_num_i = i;
            }
        }
        result.push(nums[max_num_i]);
        nums.remove(max_num_i);
    }
    result
}

fn main() {
    let candidate = order_by_points;
    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);
    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);
    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);
}

-----------------------------
/// Write a function which sorts the given vector of integers
/// in ascending order according to the sum of their digits.
/// Note: if there are several items with similar sum of their digits,
/// order them based on their index in original vector.
/// For example:
/// >>> order_by_points(vec![1, 11, -1, -11, -12])
/// vec![-1, -11, 1, -12, 11]
/// >>> order_by_points(vec![])
/// Vec::<isize>::new()
fn order_by_points(nums: Vec<isize>) -> Vec<isize> {

    if nums.is_empty() {
        return nums;
    }

    let nums_len = nums.len();
    let mut sum_by_nums: Vec<(usize, usize)> = (0..nums_len)
        .map(|index| (index, sum_digits(nums[index])))
        .collect();
    sum_by_nums.sort_by(|a, b| {
        if a.1 != b.1 {
            a.1.cmp(&b.1)
        } else {
            a.0.cmp(&b.0)
        }
    });
    sum_by_nums
        .into_iter()
        .map(|(index, _)| nums[index])
        .collect()
}

fn main() {
    let candidate = order_by_points;
    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);
    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);
    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);
}

-----------------------------
/// Write a function which sorts the given vector of integers
/// in ascending order according to the sum of their digits.
/// Note: if there are several items with similar sum of their digits,
/// order them based on their index in original vector.
/// For example:
/// >>> order_by_points(vec![1, 11, -1, -11, -12])
/// vec![-1, -11, 1, -12, 11]
/// >>> order_by_points(vec![])
/// Vec::<isize>::new()
fn order_by_points(nums: Vec<isize>) -> Vec<isize> {

    if nums.is_empty() {
        return vec![];
    }

    let mut result = nums;
    result.sort_by(|a, b| {
        let sum_a = a.to_string().chars().map(|i| i as isize - '0' as isize).sum::<isize>();
        let sum_b = b.to_string().chars().map(|i| i as isize - '0' as isize).sum::<isize>();
        sum_a.cmp(&sum_b)
            .then_with(|| a.cmp(b))
            .then_with(|| nums.iter().position(|&x| x == *a).unwrap_or(0).cmp(&nums.iter().position(|&x| x == *b).unwrap_or(0)))
    });

    result
}

fn main() {
    let candidate = order_by_points;
    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);
    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);
    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);
}

-----------------------------
/// Write a function which sorts the given vector of integers
/// in ascending order according to the sum of their digits.
/// Note: if there are several items with similar sum of their digits,
/// order them based on their index in original vector.
/// For example:
/// >>> order_by_points(vec![1, 11, -1, -11, -12])
/// vec![-1, -11, 1, -12, 11]
/// >>> order_by_points(vec![])
/// Vec::<isize>::new()
fn order_by_points(nums: Vec<isize>) -> Vec<isize> {

    let mut v: Vec<isize> = nums.iter().map(|i| i.abs()).collect();
    let mut m = vec![0; v.len()];
    let mut o = vec![];
    let mut a = vec![];
    for i in 0..v.len() {
        m[i] = digit_sum(&v[i]);
        a.push(i);
    }
    m.sort();
    for i in m {
        o.push(v[a[i]]);
    }
    o
}

fn main() {
    let candidate = order_by_points;
    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);
    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);
    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);
}

-----------------------------
/// Write a function which sorts the given vector of integers
/// in ascending order according to the sum of their digits.
/// Note: if there are several items with similar sum of their digits,
/// order them based on their index in original vector.
/// For example:
/// >>> order_by_points(vec![1, 11, -1, -11, -12])
/// vec![-1, -11, 1, -12, 11]
/// >>> order_by_points(vec![])
/// Vec::<isize>::new()
fn order_by_points(nums: Vec<isize>) -> Vec<isize> {

    if nums.is_empty() {
        return nums;
    }
    let mut sum_points: Vec<(isize, usize)> = vec![];
    for (i, num) in nums.iter().enumerate() {
        sum_points.push((sum_of_digits(num), i));
    }
    let mut sorted = sum_points;
    sorted.sort_by(|a, b| b.0.cmp(&a.0));
    let mut result = vec![];
    for item in sorted.into_iter() {
        result.push(nums[item.1]);
    }
    result
}

fn main() {
    let candidate = order_by_points;
    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);
    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);
    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);
}

===============================
/// Write a function that takes a vector of numbers as input and returns 
/// the number of elements in the vector that are greater than 10 and both 
/// first and last digits of a number are odd (1, 3, 5, 7, 9).
/// For example:
/// >>> specialFilter(vec![15, -73, 14, -15])
/// 1
/// >>> specialFilter(vec![33, -2, -3, 45, 21, 109])
/// 2
fn specialFilter(nums: Vec<isize>) -> isize {

===============================
-----------------------------
/// Write a function that takes a vector of numbers as input and returns 
/// the number of elements in the vector that are greater than 10 and both 
/// first and last digits of a number are odd (1, 3, 5, 7, 9).
/// For example:
/// >>> specialFilter(vec![15, -73, 14, -15])
/// 1
/// >>> specialFilter(vec![33, -2, -3, 45, 21, 109])
/// 2
fn specialFilter(nums: Vec<isize>) -> isize {

    let mut answer = 0;
    for i in nums {
        let n = i.abs();
        if (n > 10) && ((n % 10) % 2 == 1) && ((n / 10) % 2 == 1) {
            answer += 1;
        }
    }
    answer
}

fn main() {
    let candidate = specialFilter;
    assert_eq!(candidate(vec![5, -2, 1, -5]), 0);
    assert_eq!(candidate(vec![15, -73, 14, -15]), 1);
    assert_eq!(candidate(vec![33, -2, -3, 45, 21, 109]), 2);
    assert_eq!(candidate(vec![43, -12, 93, 125, 121, 109]), 4);
    assert_eq!(candidate(vec![71, -2, -33, 75, 21, 19]), 3);
    assert_eq!(candidate(vec![1]), 0);
    assert_eq!(candidate(Vec::<isize>::new()), 0);
}

-----------------------------
/// Write a function that takes a vector of numbers as input and returns 
/// the number of elements in the vector that are greater than 10 and both 
/// first and last digits of a number are odd (1, 3, 5, 7, 9).
/// For example:
/// >>> specialFilter(vec![15, -73, 14, -15])
/// 1
/// >>> specialFilter(vec![33, -2, -3, 45, 21, 109])
/// 2
fn specialFilter(nums: Vec<isize>) -> isize {

    // Write an expression that iterates through nums and
    // returns 1 if the first and last digits are both odd and
    // num is greater than 10. 
    // Return 0 if nums is empty, and return the sum otherwise.
    // HINT: use filter() and map()
    let odd_nums: Vec<bool> = nums.iter()
        .filter(|&x| *x > 10)
        .map(|&x| x % 10)
        .filter(|&x| (x % 2) == 1)
        .map(|x| x == 1)
        .collect();

    odd_nums.iter().fold(0, |acc, &x| { acc + x })
}

fn main() {
    let candidate = specialFilter;
    assert_eq!(candidate(vec![5, -2, 1, -5]), 0);
    assert_eq!(candidate(vec![15, -73, 14, -15]), 1);
    assert_eq!(candidate(vec![33, -2, -3, 45, 21, 109]), 2);
    assert_eq!(candidate(vec![43, -12, 93, 125, 121, 109]), 4);
    assert_eq!(candidate(vec![71, -2, -33, 75, 21, 19]), 3);
    assert_eq!(candidate(vec![1]), 0);
    assert_eq!(candidate(Vec::<isize>::new()), 0);
}

-----------------------------
/// Write a function that takes a vector of numbers as input and returns 
/// the number of elements in the vector that are greater than 10 and both 
/// first and last digits of a number are odd (1, 3, 5, 7, 9).
/// For example:
/// >>> specialFilter(vec![15, -73, 14, -15])
/// 1
/// >>> specialFilter(vec![33, -2, -3, 45, 21, 109])
/// 2
fn specialFilter(nums: Vec<isize>) -> isize {

    nums.iter().filter(|&num| num > &10 && (num % 2) == 1).count() as isize
}

fn main() {
    let candidate = specialFilter;
    assert_eq!(candidate(vec![5, -2, 1, -5]), 0);
    assert_eq!(candidate(vec![15, -73, 14, -15]), 1);
    assert_eq!(candidate(vec![33, -2, -3, 45, 21, 109]), 2);
    assert_eq!(candidate(vec![43, -12, 93, 125, 121, 109]), 4);
    assert_eq!(candidate(vec![71, -2, -33, 75, 21, 19]), 3);
    assert_eq!(candidate(vec![1]), 0);
    assert_eq!(candidate(Vec::<isize>::new()), 0);
}

-----------------------------
/// Write a function that takes a vector of numbers as input and returns 
/// the number of elements in the vector that are greater than 10 and both 
/// first and last digits of a number are odd (1, 3, 5, 7, 9).
/// For example:
/// >>> specialFilter(vec![15, -73, 14, -15])
/// 1
/// >>> specialFilter(vec![33, -2, -3, 45, 21, 109])
/// 2
fn specialFilter(nums: Vec<isize>) -> isize {

    // write your code here
    nums.into_iter().filter(|&n| {
        n > 10 && (n % 10 != 0) && (n % 10 != 5) && (n % 10 != 1) && ((n / 10) % 2 != 0)
    }).count() as isize
}

fn main() {
    let candidate = specialFilter;
    assert_eq!(candidate(vec![5, -2, 1, -5]), 0);
    assert_eq!(candidate(vec![15, -73, 14, -15]), 1);
    assert_eq!(candidate(vec![33, -2, -3, 45, 21, 109]), 2);
    assert_eq!(candidate(vec![43, -12, 93, 125, 121, 109]), 4);
    assert_eq!(candidate(vec![71, -2, -33, 75, 21, 19]), 3);
    assert_eq!(candidate(vec![1]), 0);
    assert_eq!(candidate(Vec::<isize>::new()), 0);
}

-----------------------------
/// Write a function that takes a vector of numbers as input and returns 
/// the number of elements in the vector that are greater than 10 and both 
/// first and last digits of a number are odd (1, 3, 5, 7, 9).
/// For example:
/// >>> specialFilter(vec![15, -73, 14, -15])
/// 1
/// >>> specialFilter(vec![33, -2, -3, 45, 21, 109])
/// 2
fn specialFilter(nums: Vec<isize>) -> isize {

    let mut count = 0;
    for i in nums {
        if i > 10 {
            let num = i.abs();
            if num % 10 == 1 || num % 10 == 3 || num % 10 == 5 || num % 10 == 7 || num % 10 == 9 {
                if num % 100 != 11 && num % 100 != 13 && num % 100 != 15 && num % 100 != 17 && num % 100 != 19 {
                    if num / 10 % 10 == 1 || num / 10 % 10 == 3 || num / 10 % 10 == 5 || num / 10 % 10 == 7 || num / 10 % 10 == 9 {
                        if num / 100 != 11 && num / 100 != 13 && num / 100 != 15 && num / 100 != 17 && num / 100 != 19 {
                            count += 1;
                        }
                    }
                }
            }
        }
    }

    return count;
}

fn main() {
    let candidate = specialFilter;
    assert_eq!(candidate(vec![5, -2, 1, -5]), 0);
    assert_eq!(candidate(vec![15, -73, 14, -15]), 1);
    assert_eq!(candidate(vec![33, -2, -3, 45, 21, 109]), 2);
    assert_eq!(candidate(vec![43, -12, 93, 125, 121, 109]), 4);
    assert_eq!(candidate(vec![71, -2, -33, 75, 21, 19]), 3);
    assert_eq!(candidate(vec![1]), 0);
    assert_eq!(candidate(Vec::<isize>::new()), 0);
}

===============================
/// You are given a positive integer n. You have to create an integer vector a of length n.
/// For each i (1  i  n), the value of a[i] = i * i - i + 1.
/// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
/// and a[i] + a[j] + a[k] is a multiple of 3.
/// Example :
/// >>> get_max_triples(5)
/// 1
/// Explanation: 
/// a = [1, 3, 7, 13, 21]
/// The only valid triple is (1, 7, 13).
fn get_max_triples(n: isize) -> isize {

===============================
-----------------------------
/// You are given a positive integer n. You have to create an integer vector a of length n.
/// For each i (1  i  n), the value of a[i] = i * i - i + 1.
/// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
/// and a[i] + a[j] + a[k] is a multiple of 3.
/// Example :
/// >>> get_max_triples(5)
/// 1
/// Explanation: 
/// a = [1, 3, 7, 13, 21]
/// The only valid triple is (1, 7, 13).
fn get_max_triples(n: isize) -> isize {

    if n <= 3 {
        return n;
    }
    let mut count = 0;
    for i in 1..n {
        for j in i + 1..n {
            for k in j + 1..n {
                if i * i * 3 - i * 3 + 1 == j * j * 3 - j * 3 + 1 + k * k * 3 - k * 3 + 1 {
                    count += 1;
                }
            }
        }
    }
    count
}

fn main() {
    let candidate = get_max_triples;
    assert_eq!(candidate(5), 1);
    assert_eq!(candidate(6), 4);
    assert_eq!(candidate(10), 36);
    assert_eq!(candidate(100), 53361);
}

-----------------------------
/// You are given a positive integer n. You have to create an integer vector a of length n.
/// For each i (1  i  n), the value of a[i] = i * i - i + 1.
/// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
/// and a[i] + a[j] + a[k] is a multiple of 3.
/// Example :
/// >>> get_max_triples(5)
/// 1
/// Explanation: 
/// a = [1, 3, 7, 13, 21]
/// The only valid triple is (1, 7, 13).
fn get_max_triples(n: isize) -> isize {

    let mut count = 0;
    for i in 0..n-2 {
        for j in i+1..n-1 {
            let mut k = j+1;
            while k < n {
                if (i*i - i + 1 + j*j - j + 1 + k*k - k + 1) % 3 == 0 {
                    count += 1;
                }
                k += 1;
            }
        }
    }
    count
}

fn main() {
    let candidate = get_max_triples;
    assert_eq!(candidate(5), 1);
    assert_eq!(candidate(6), 4);
    assert_eq!(candidate(10), 36);
    assert_eq!(candidate(100), 53361);
}

-----------------------------
/// You are given a positive integer n. You have to create an integer vector a of length n.
/// For each i (1  i  n), the value of a[i] = i * i - i + 1.
/// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
/// and a[i] + a[j] + a[k] is a multiple of 3.
/// Example :
/// >>> get_max_triples(5)
/// 1
/// Explanation: 
/// a = [1, 3, 7, 13, 21]
/// The only valid triple is (1, 7, 13).
fn get_max_triples(n: isize) -> isize {

    let mut a = Vec::with_capacity(n as usize);
    for i in 0..n {
        a.push(i * i - i + 1);
    }
    let mut count = 0;
    for i in 1..n {
        for j in (i+1)..n {
            if a[i] + a[j] % 3 == 0 {
                for k in (j+1)..n {
                    if a[i] + a[j] + a[k] % 3 == 0 {
                        count += 1;
                    }
                }
            }
        }
    }
    return count;
}

fn main() {
    let candidate = get_max_triples;
    assert_eq!(candidate(5), 1);
    assert_eq!(candidate(6), 4);
    assert_eq!(candidate(10), 36);
    assert_eq!(candidate(100), 53361);
}

-----------------------------
/// You are given a positive integer n. You have to create an integer vector a of length n.
/// For each i (1  i  n), the value of a[i] = i * i - i + 1.
/// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
/// and a[i] + a[j] + a[k] is a multiple of 3.
/// Example :
/// >>> get_max_triples(5)
/// 1
/// Explanation: 
/// a = [1, 3, 7, 13, 21]
/// The only valid triple is (1, 7, 13).
fn get_max_triples(n: isize) -> isize {

    todo!()
}

fn main() {
    let candidate = get_max_triples;
    assert_eq!(candidate(5), 1);
    assert_eq!(candidate(6), 4);
    assert_eq!(candidate(10), 36);
    assert_eq!(candidate(100), 53361);
}

-----------------------------
/// You are given a positive integer n. You have to create an integer vector a of length n.
/// For each i (1  i  n), the value of a[i] = i * i - i + 1.
/// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
/// and a[i] + a[j] + a[k] is a multiple of 3.
/// Example :
/// >>> get_max_triples(5)
/// 1
/// Explanation: 
/// a = [1, 3, 7, 13, 21]
/// The only valid triple is (1, 7, 13).
fn get_max_triples(n: isize) -> isize {

    let n = n as usize;

    let mut max_sum = 0;
    let mut current_sum = 0;

    for i in 0..n {
        for j in i+1..n {
            current_sum = a[i] + a[j];
            if current_sum % 3 == 0 {
                max_sum += 1;
            }
        }
    }

    max_sum
}

fn main() {
    let candidate = get_max_triples;
    assert_eq!(candidate(5), 1);
    assert_eq!(candidate(6), 4);
    assert_eq!(candidate(10), 36);
    assert_eq!(candidate(100), 53361);
}

===============================
/// Write a function that accepts a vector of strings as a parameter,
/// deletes the strings that have odd lengths from it,
/// and returns the resulted vector with a sorted order,
/// The vector is always a vector of strings and never a vector of numbers,
/// and it may contain duplicates.
/// The order of the vector should be ascending by length of each word, and you
/// should return the vector sorted by that rule.
/// If two words have the same length, sort the vector alphabetically.
/// The function should return a vector of strings in sorted order.
/// You may assume that all words will have the same length.
/// For example:
/// >>> list_sort(vec![String::from("aa"), String::from("a"), String::from("aaa")])
/// vec![String::from("aa")]
/// >>> list_sort(vec![String::from("ab"), String::from("a"), String::from("aaa"), String::from("cd")])
/// vec![String::from("ab"), String::from("cd")]
fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {

===============================
-----------------------------
/// Write a function that accepts a vector of strings as a parameter,
/// deletes the strings that have odd lengths from it,
/// and returns the resulted vector with a sorted order,
/// The vector is always a vector of strings and never a vector of numbers,
/// and it may contain duplicates.
/// The order of the vector should be ascending by length of each word, and you
/// should return the vector sorted by that rule.
/// If two words have the same length, sort the vector alphabetically.
/// The function should return a vector of strings in sorted order.
/// You may assume that all words will have the same length.
/// For example:
/// >>> list_sort(vec![String::from("aa"), String::from("a"), String::from("aaa")])
/// vec![String::from("aa")]
/// >>> list_sort(vec![String::from("ab"), String::from("a"), String::from("aaa"), String::from("cd")])
/// vec![String::from("ab"), String::from("cd")]
fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {

    let mut result: Vec<String> = Vec::new();
    let mut s: String = String::new();
    for i in lst {
        s.push_str(&i);
        s.push(' ');
    }
    let mut s_split: Vec<&str> = s.split(' ').collect();
    s_split.sort();
    let mut v: Vec<String> = Vec::new();
    for i in s_split {
        v.push(i.to_string());
    }
    result.push(v[0].clone());
    for i in &v[1..] {
        if i.len() != result.last().unwrap().len() {
            result.push(i.clone());
        }
    }
    result
}

fn main() {
    let candidate = sorted_list_sum;
    assert_eq!(candidate(vec![String::from("aa"), String::from("a"), String::from("aaa")]), vec![String::from("aa")]);
    assert_eq!(candidate(vec![String::from("school"), String::from("AI"), String::from("asdf"), String::from("b")]), vec![String::from("AI"), String::from("asdf"), String::from("school")]);
    assert_eq!(candidate(vec![String::from("d"), String::from("b"), String::from("c"), String::from("a")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("d"), String::from("dcba"), String::from("abcd"), String::from("a")]), vec![String::from("abcd"), String::from("dcba")]);
    assert_eq!(candidate(vec![String::from("AI"), String::from("ai"), String::from("au")]), vec![String::from("AI"), String::from("ai"), String::from("au")]);
    assert_eq!(candidate(vec![String::from("a"), String::from("b"), String::from("b"), String::from("c"), String::from("c"), String::from("a")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("aaaa"), String::from("bbbb"), String::from("dd"), String::from("cc")]), vec![String::from("cc"), String::from("dd"), String::from("aaaa"), String::from("bbbb")]);
}

-----------------------------
/// Write a function that accepts a vector of strings as a parameter,
/// deletes the strings that have odd lengths from it,
/// and returns the resulted vector with a sorted order,
/// The vector is always a vector of strings and never a vector of numbers,
/// and it may contain duplicates.
/// The order of the vector should be ascending by length of each word, and you
/// should return the vector sorted by that rule.
/// If two words have the same length, sort the vector alphabetically.
/// The function should return a vector of strings in sorted order.
/// You may assume that all words will have the same length.
/// For example:
/// >>> list_sort(vec![String::from("aa"), String::from("a"), String::from("aaa")])
/// vec![String::from("aa")]
/// >>> list_sort(vec![String::from("ab"), String::from("a"), String::from("aaa"), String::from("cd")])
/// vec![String::from("ab"), String::from("cd")]
fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {

    let mut tmp = vec![];
    let mut new_lst = lst;
    for i in 0..new_lst.len() {
        if new_lst[i].len() % 2 == 0 {
            tmp.push(new_lst[i].clone());
        }
    }
    tmp.sort();
    return tmp;
}

fn main() {
    let candidate = sorted_list_sum;
    assert_eq!(candidate(vec![String::from("aa"), String::from("a"), String::from("aaa")]), vec![String::from("aa")]);
    assert_eq!(candidate(vec![String::from("school"), String::from("AI"), String::from("asdf"), String::from("b")]), vec![String::from("AI"), String::from("asdf"), String::from("school")]);
    assert_eq!(candidate(vec![String::from("d"), String::from("b"), String::from("c"), String::from("a")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("d"), String::from("dcba"), String::from("abcd"), String::from("a")]), vec![String::from("abcd"), String::from("dcba")]);
    assert_eq!(candidate(vec![String::from("AI"), String::from("ai"), String::from("au")]), vec![String::from("AI"), String::from("ai"), String::from("au")]);
    assert_eq!(candidate(vec![String::from("a"), String::from("b"), String::from("b"), String::from("c"), String::from("c"), String::from("a")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("aaaa"), String::from("bbbb"), String::from("dd"), String::from("cc")]), vec![String::from("cc"), String::from("dd"), String::from("aaaa"), String::from("bbbb")]);
}

-----------------------------
/// Write a function that accepts a vector of strings as a parameter,
/// deletes the strings that have odd lengths from it,
/// and returns the resulted vector with a sorted order,
/// The vector is always a vector of strings and never a vector of numbers,
/// and it may contain duplicates.
/// The order of the vector should be ascending by length of each word, and you
/// should return the vector sorted by that rule.
/// If two words have the same length, sort the vector alphabetically.
/// The function should return a vector of strings in sorted order.
/// You may assume that all words will have the same length.
/// For example:
/// >>> list_sort(vec![String::from("aa"), String::from("a"), String::from("aaa")])
/// vec![String::from("aa")]
/// >>> list_sort(vec![String::from("ab"), String::from("a"), String::from("aaa"), String::from("cd")])
/// vec![String::from("ab"), String::from("cd")]
fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {

    let mut list: Vec<String> = Vec::new();
    let mut sorted_list: Vec<String> = Vec::new();
    let mut counter = 0;
    for _ in 0..lst.len() {
        if counter % 2 != 0 {
            sorted_list.push(lst[counter].clone());
        }
        counter += 1;
    }
    sorted_list.sort();
    sorted_list
}

fn main() {
    let candidate = sorted_list_sum;
    assert_eq!(candidate(vec![String::from("aa"), String::from("a"), String::from("aaa")]), vec![String::from("aa")]);
    assert_eq!(candidate(vec![String::from("school"), String::from("AI"), String::from("asdf"), String::from("b")]), vec![String::from("AI"), String::from("asdf"), String::from("school")]);
    assert_eq!(candidate(vec![String::from("d"), String::from("b"), String::from("c"), String::from("a")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("d"), String::from("dcba"), String::from("abcd"), String::from("a")]), vec![String::from("abcd"), String::from("dcba")]);
    assert_eq!(candidate(vec![String::from("AI"), String::from("ai"), String::from("au")]), vec![String::from("AI"), String::from("ai"), String::from("au")]);
    assert_eq!(candidate(vec![String::from("a"), String::from("b"), String::from("b"), String::from("c"), String::from("c"), String::from("a")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("aaaa"), String::from("bbbb"), String::from("dd"), String::from("cc")]), vec![String::from("cc"), String::from("dd"), String::from("aaaa"), String::from("bbbb")]);
}

-----------------------------
/// Write a function that accepts a vector of strings as a parameter,
/// deletes the strings that have odd lengths from it,
/// and returns the resulted vector with a sorted order,
/// The vector is always a vector of strings and never a vector of numbers,
/// and it may contain duplicates.
/// The order of the vector should be ascending by length of each word, and you
/// should return the vector sorted by that rule.
/// If two words have the same length, sort the vector alphabetically.
/// The function should return a vector of strings in sorted order.
/// You may assume that all words will have the same length.
/// For example:
/// >>> list_sort(vec![String::from("aa"), String::from("a"), String::from("aaa")])
/// vec![String::from("aa")]
/// >>> list_sort(vec![String::from("ab"), String::from("a"), String::from("aaa"), String::from("cd")])
/// vec![String::from("ab"), String::from("cd")]
fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {

    let mut vec: Vec<String> = Vec::new();
    for i in &lst {
        if i.len() % 2 == 0 {
            vec.push(i.clone());
        }
    }
    vec.sort();
    vec
}

fn main() {
    let candidate = sorted_list_sum;
    assert_eq!(candidate(vec![String::from("aa"), String::from("a"), String::from("aaa")]), vec![String::from("aa")]);
    assert_eq!(candidate(vec![String::from("school"), String::from("AI"), String::from("asdf"), String::from("b")]), vec![String::from("AI"), String::from("asdf"), String::from("school")]);
    assert_eq!(candidate(vec![String::from("d"), String::from("b"), String::from("c"), String::from("a")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("d"), String::from("dcba"), String::from("abcd"), String::from("a")]), vec![String::from("abcd"), String::from("dcba")]);
    assert_eq!(candidate(vec![String::from("AI"), String::from("ai"), String::from("au")]), vec![String::from("AI"), String::from("ai"), String::from("au")]);
    assert_eq!(candidate(vec![String::from("a"), String::from("b"), String::from("b"), String::from("c"), String::from("c"), String::from("a")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("aaaa"), String::from("bbbb"), String::from("dd"), String::from("cc")]), vec![String::from("cc"), String::from("dd"), String::from("aaaa"), String::from("bbbb")]);
}

-----------------------------
/// Write a function that accepts a vector of strings as a parameter,
/// deletes the strings that have odd lengths from it,
/// and returns the resulted vector with a sorted order,
/// The vector is always a vector of strings and never a vector of numbers,
/// and it may contain duplicates.
/// The order of the vector should be ascending by length of each word, and you
/// should return the vector sorted by that rule.
/// If two words have the same length, sort the vector alphabetically.
/// The function should return a vector of strings in sorted order.
/// You may assume that all words will have the same length.
/// For example:
/// >>> list_sort(vec![String::from("aa"), String::from("a"), String::from("aaa")])
/// vec![String::from("aa")]
/// >>> list_sort(vec![String::from("ab"), String::from("a"), String::from("aaa"), String::from("cd")])
/// vec![String::from("ab"), String::from("cd")]
fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {

    let mut sorted_list: Vec<String> = lst;

    sorted_list.sort_by(|a, b| {
        if a.len() == b.len() {
            return a.cmp(&b);
        }
        a.len().cmp(&b.len())
    });
    let mut result: Vec<String> = Vec::new();

    for item in sorted_list {
        if item.len() % 2 == 0 {
            result.push(item);
        }
    }

    result
}

fn main() {
    let candidate = sorted_list_sum;
    assert_eq!(candidate(vec![String::from("aa"), String::from("a"), String::from("aaa")]), vec![String::from("aa")]);
    assert_eq!(candidate(vec![String::from("school"), String::from("AI"), String::from("asdf"), String::from("b")]), vec![String::from("AI"), String::from("asdf"), String::from("school")]);
    assert_eq!(candidate(vec![String::from("d"), String::from("b"), String::from("c"), String::from("a")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("d"), String::from("dcba"), String::from("abcd"), String::from("a")]), vec![String::from("abcd"), String::from("dcba")]);
    assert_eq!(candidate(vec![String::from("AI"), String::from("ai"), String::from("au")]), vec![String::from("AI"), String::from("ai"), String::from("au")]);
    assert_eq!(candidate(vec![String::from("a"), String::from("b"), String::from("b"), String::from("c"), String::from("c"), String::from("a")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from("aaaa"), String::from("bbbb"), String::from("dd"), String::from("cc")]), vec![String::from("cc"), String::from("dd"), String::from("aaaa"), String::from("bbbb")]);
}

===============================
/// A simple program which should return the value of x if n is 
/// a prime number and should return the value of y otherwise.
/// Examples:
/// >>> x_or_y(7, 34, 12)
/// 34
/// >>> x_or_y(15, 8, 5)
/// 5
fn x_or_y(n: isize, x: isize, y: isize) -> isize {

===============================
-----------------------------
/// A simple program which should return the value of x if n is 
/// a prime number and should return the value of y otherwise.
/// Examples:
/// >>> x_or_y(7, 34, 12)
/// 34
/// >>> x_or_y(15, 8, 5)
/// 5
fn x_or_y(n: isize, x: isize, y: isize) -> isize {

    if is_prime(n) {
        return x;
    } else {
        return y;
    }
}

fn main() {
    let candidate = x_or_y;
    assert_eq!(candidate(7, 34, 12), 34);
    assert_eq!(candidate(15, 8, 5), 5);
    assert_eq!(candidate(3, 33, 5212), 33);
    assert_eq!(candidate(1259, 3, 52), 3);
    assert_eq!(candidate(7919, -1, 12), -1);
    assert_eq!(candidate(3609, 1245, 583), 583);
    assert_eq!(candidate(91, 56, 129), 129);
    assert_eq!(candidate(6, 34, 1234), 1234);
    assert_eq!(candidate(1, 2, 0), 0);
    assert_eq!(candidate(2, 2, 0), 2);
}

-----------------------------
/// A simple program which should return the value of x if n is 
/// a prime number and should return the value of y otherwise.
/// Examples:
/// >>> x_or_y(7, 34, 12)
/// 34
/// >>> x_or_y(15, 8, 5)
/// 5
fn x_or_y(n: isize, x: isize, y: isize) -> isize {

    if n % 2 == 0 {
        x
    } else {
        y
    }
}

fn main() {
    let candidate = x_or_y;
    assert_eq!(candidate(7, 34, 12), 34);
    assert_eq!(candidate(15, 8, 5), 5);
    assert_eq!(candidate(3, 33, 5212), 33);
    assert_eq!(candidate(1259, 3, 52), 3);
    assert_eq!(candidate(7919, -1, 12), -1);
    assert_eq!(candidate(3609, 1245, 583), 583);
    assert_eq!(candidate(91, 56, 129), 129);
    assert_eq!(candidate(6, 34, 1234), 1234);
    assert_eq!(candidate(1, 2, 0), 0);
    assert_eq!(candidate(2, 2, 0), 2);
}

-----------------------------
/// A simple program which should return the value of x if n is 
/// a prime number and should return the value of y otherwise.
/// Examples:
/// >>> x_or_y(7, 34, 12)
/// 34
/// >>> x_or_y(15, 8, 5)
/// 5
fn x_or_y(n: isize, x: isize, y: isize) -> isize {

    if is_prime(n) {
        return x;
    } else {
        return y;
    }
}

fn main() {
    let candidate = x_or_y;
    assert_eq!(candidate(7, 34, 12), 34);
    assert_eq!(candidate(15, 8, 5), 5);
    assert_eq!(candidate(3, 33, 5212), 33);
    assert_eq!(candidate(1259, 3, 52), 3);
    assert_eq!(candidate(7919, -1, 12), -1);
    assert_eq!(candidate(3609, 1245, 583), 583);
    assert_eq!(candidate(91, 56, 129), 129);
    assert_eq!(candidate(6, 34, 1234), 1234);
    assert_eq!(candidate(1, 2, 0), 0);
    assert_eq!(candidate(2, 2, 0), 2);
}

-----------------------------
/// A simple program which should return the value of x if n is 
/// a prime number and should return the value of y otherwise.
/// Examples:
/// >>> x_or_y(7, 34, 12)
/// 34
/// >>> x_or_y(15, 8, 5)
/// 5
fn x_or_y(n: isize, x: isize, y: isize) -> isize {

    if n%2 == 0 {
        y
    } else {
        x
    }
}

fn main() {
    let candidate = x_or_y;
    assert_eq!(candidate(7, 34, 12), 34);
    assert_eq!(candidate(15, 8, 5), 5);
    assert_eq!(candidate(3, 33, 5212), 33);
    assert_eq!(candidate(1259, 3, 52), 3);
    assert_eq!(candidate(7919, -1, 12), -1);
    assert_eq!(candidate(3609, 1245, 583), 583);
    assert_eq!(candidate(91, 56, 129), 129);
    assert_eq!(candidate(6, 34, 1234), 1234);
    assert_eq!(candidate(1, 2, 0), 0);
    assert_eq!(candidate(2, 2, 0), 2);
}

-----------------------------
/// A simple program which should return the value of x if n is 
/// a prime number and should return the value of y otherwise.
/// Examples:
/// >>> x_or_y(7, 34, 12)
/// 34
/// >>> x_or_y(15, 8, 5)
/// 5
fn x_or_y(n: isize, x: isize, y: isize) -> isize {

    if is_prime(n) { x } else { y }
}

fn main() {
    let candidate = x_or_y;
    assert_eq!(candidate(7, 34, 12), 34);
    assert_eq!(candidate(15, 8, 5), 5);
    assert_eq!(candidate(3, 33, 5212), 33);
    assert_eq!(candidate(1259, 3, 52), 3);
    assert_eq!(candidate(7919, -1, 12), -1);
    assert_eq!(candidate(3609, 1245, 583), 583);
    assert_eq!(candidate(91, 56, 129), 129);
    assert_eq!(candidate(6, 34, 1234), 1234);
    assert_eq!(candidate(1, 2, 0), 0);
    assert_eq!(candidate(2, 2, 0), 2);
}

===============================
/// Given a vector of numbers, return the sum of squares of the numbers
/// in the vector that are odd. Ignore numbers that are negative or not integers.
/// >>> double_the_difference(vec![1, 3, 2, 0])
/// 10
/// >>> double_the_difference(vec![-1, -2, 0])
/// 0
/// >>> double_the_difference(vec![9, -2])
/// 81
/// >>> double_the_difference(vec![0])
/// 0
/// If the input vector is empty, return 0.
fn double_the_difference(lst: Vec<f64>) -> isize {

===============================
-----------------------------
/// Given a vector of numbers, return the sum of squares of the numbers
/// in the vector that are odd. Ignore numbers that are negative or not integers.
/// >>> double_the_difference(vec![1, 3, 2, 0])
/// 10
/// >>> double_the_difference(vec![-1, -2, 0])
/// 0
/// >>> double_the_difference(vec![9, -2])
/// 81
/// >>> double_the_difference(vec![0])
/// 0
/// If the input vector is empty, return 0.
fn double_the_difference(lst: Vec<f64>) -> isize {

    // TODO: Write some code here!
    unimplemented!()
}

fn main() {
    let candidate = double_the_difference;
    assert_eq!(candidate(Vec::<f64>::new()), 0);
    assert_eq!(candidate(vec![5.0, 4.0]), 25);
    assert_eq!(candidate(vec![0.1, 0.2, 0.3]), 0);
    assert_eq!(candidate(vec![-10.0, -20.0, -30.0]), 0);
    assert_eq!(candidate(vec![-1.0, -2.0, 8.0]), 0);
    assert_eq!(candidate(vec![0.2, 3.0, 5.0]), 34);
    assert_eq!(candidate(vec![-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]), 165);
}

-----------------------------
/// Given a vector of numbers, return the sum of squares of the numbers
/// in the vector that are odd. Ignore numbers that are negative or not integers.
/// >>> double_the_difference(vec![1, 3, 2, 0])
/// 10
/// >>> double_the_difference(vec![-1, -2, 0])
/// 0
/// >>> double_the_difference(vec![9, -2])
/// 81
/// >>> double_the_difference(vec![0])
/// 0
/// If the input vector is empty, return 0.
fn double_the_difference(lst: Vec<f64>) -> isize {

    let mut sum = 0;
    for i in lst {
        if i.abs() as isize % 2 != 0 {
            sum += i.powi(2) as isize;
        }
    }
    return sum;
}

fn main() {
    let candidate = double_the_difference;
    assert_eq!(candidate(Vec::<f64>::new()), 0);
    assert_eq!(candidate(vec![5.0, 4.0]), 25);
    assert_eq!(candidate(vec![0.1, 0.2, 0.3]), 0);
    assert_eq!(candidate(vec![-10.0, -20.0, -30.0]), 0);
    assert_eq!(candidate(vec![-1.0, -2.0, 8.0]), 0);
    assert_eq!(candidate(vec![0.2, 3.0, 5.0]), 34);
    assert_eq!(candidate(vec![-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]), 165);
}

-----------------------------
/// Given a vector of numbers, return the sum of squares of the numbers
/// in the vector that are odd. Ignore numbers that are negative or not integers.
/// >>> double_the_difference(vec![1, 3, 2, 0])
/// 10
/// >>> double_the_difference(vec![-1, -2, 0])
/// 0
/// >>> double_the_difference(vec![9, -2])
/// 81
/// >>> double_the_difference(vec![0])
/// 0
/// If the input vector is empty, return 0.
fn double_the_difference(lst: Vec<f64>) -> isize {

    let mut sum_odd = 0;
    let mut sum_even = 0;
    for n in lst {
        let rounded = round_if_int(n);
        if rounded.is_none() {
            continue;
        }
        let rounded = rounded.unwrap();
        if rounded.is_odd() {
            sum_odd += (rounded.pow(2) - 1) as isize;
        } else {
            sum_even += rounded.pow(2) as isize;
        }
    }
    sum_odd + sum_even
}

fn main() {
    let candidate = double_the_difference;
    assert_eq!(candidate(Vec::<f64>::new()), 0);
    assert_eq!(candidate(vec![5.0, 4.0]), 25);
    assert_eq!(candidate(vec![0.1, 0.2, 0.3]), 0);
    assert_eq!(candidate(vec![-10.0, -20.0, -30.0]), 0);
    assert_eq!(candidate(vec![-1.0, -2.0, 8.0]), 0);
    assert_eq!(candidate(vec![0.2, 3.0, 5.0]), 34);
    assert_eq!(candidate(vec![-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]), 165);
}

-----------------------------
/// Given a vector of numbers, return the sum of squares of the numbers
/// in the vector that are odd. Ignore numbers that are negative or not integers.
/// >>> double_the_difference(vec![1, 3, 2, 0])
/// 10
/// >>> double_the_difference(vec![-1, -2, 0])
/// 0
/// >>> double_the_difference(vec![9, -2])
/// 81
/// >>> double_the_difference(vec![0])
/// 0
/// If the input vector is empty, return 0.
fn double_the_difference(lst: Vec<f64>) -> isize {

    lst.iter().filter(|x| x.is_integer() && x.is_sign_positive())
        .map(|x| x.powi(2) as isize)
        .sum()
}

fn main() {
    let candidate = double_the_difference;
    assert_eq!(candidate(Vec::<f64>::new()), 0);
    assert_eq!(candidate(vec![5.0, 4.0]), 25);
    assert_eq!(candidate(vec![0.1, 0.2, 0.3]), 0);
    assert_eq!(candidate(vec![-10.0, -20.0, -30.0]), 0);
    assert_eq!(candidate(vec![-1.0, -2.0, 8.0]), 0);
    assert_eq!(candidate(vec![0.2, 3.0, 5.0]), 34);
    assert_eq!(candidate(vec![-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]), 165);
}

-----------------------------
/// Given a vector of numbers, return the sum of squares of the numbers
/// in the vector that are odd. Ignore numbers that are negative or not integers.
/// >>> double_the_difference(vec![1, 3, 2, 0])
/// 10
/// >>> double_the_difference(vec![-1, -2, 0])
/// 0
/// >>> double_the_difference(vec![9, -2])
/// 81
/// >>> double_the_difference(vec![0])
/// 0
/// If the input vector is empty, return 0.
fn double_the_difference(lst: Vec<f64>) -> isize {

    lst.iter()
        .filter(|&x| x.is_finite() && x.is_integer() && x.abs() as usize % 2 == 1)
        .map(|x| x * x)
        .sum() as isize
}

fn main() {
    let candidate = double_the_difference;
    assert_eq!(candidate(Vec::<f64>::new()), 0);
    assert_eq!(candidate(vec![5.0, 4.0]), 25);
    assert_eq!(candidate(vec![0.1, 0.2, 0.3]), 0);
    assert_eq!(candidate(vec![-10.0, -20.0, -30.0]), 0);
    assert_eq!(candidate(vec![-1.0, -2.0, 8.0]), 0);
    assert_eq!(candidate(vec![0.2, 3.0, 5.0]), 34);
    assert_eq!(candidate(vec![-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]), 165);
}

===============================
/// I think we all remember that feeling when the result of some long-awaited
/// event is finally known. The feelings and thoughts you have at that moment are
/// definitely worth noting down and comparing.
/// Your task is to determine if a person correctly guessed the results of a number of matches.
/// You are given two vectors of scores and guesses of equal length, where each index shows a match. 
/// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,
/// the value is 0, and if not, the value is the absolute difference between the guess and the score.
/// example:
/// >>> compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2])
/// vec![0, 0, 0, 0, 3, 3]
/// >>> compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2])
/// vec![4, 4, 1, 0, 0, 6]
fn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {

===============================
-----------------------------
/// I think we all remember that feeling when the result of some long-awaited
/// event is finally known. The feelings and thoughts you have at that moment are
/// definitely worth noting down and comparing.
/// Your task is to determine if a person correctly guessed the results of a number of matches.
/// You are given two vectors of scores and guesses of equal length, where each index shows a match. 
/// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,
/// the value is 0, and if not, the value is the absolute difference between the guess and the score.
/// example:
/// >>> compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2])
/// vec![0, 0, 0, 0, 3, 3]
/// >>> compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2])
/// vec![4, 4, 1, 0, 0, 6]
fn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {

    let mut result: Vec<isize> = vec![];
    for i in 0..game.len() {
        if game[i] == guess[i] {
            result.push(0);
        } else {
            result.push(guess[i] - game[i]);
        }
    }
    result
}

fn main() {
    let candidate = compare;
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]), vec![0, 0, 0, 0, 3, 3]);
    assert_eq!(candidate(vec![0, 0, 0, 0, 0, 0], vec![0, 0, 0, 0, 0, 0]), vec![0, 0, 0, 0, 0, 0]);
    assert_eq!(candidate(vec![1, 2, 3], vec![-1, -2, -3]), vec![2, 4, 6]);
    assert_eq!(candidate(vec![1, 2, 3, 5], vec![-1, 2, 3, 4]), vec![2, 0, 0, 1]);
}

-----------------------------
/// I think we all remember that feeling when the result of some long-awaited
/// event is finally known. The feelings and thoughts you have at that moment are
/// definitely worth noting down and comparing.
/// Your task is to determine if a person correctly guessed the results of a number of matches.
/// You are given two vectors of scores and guesses of equal length, where each index shows a match. 
/// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,
/// the value is 0, and if not, the value is the absolute difference between the guess and the score.
/// example:
/// >>> compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2])
/// vec![0, 0, 0, 0, 3, 3]
/// >>> compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2])
/// vec![4, 4, 1, 0, 0, 6]
fn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {

    let mut res = vec![0; game.len()];
    for i in 0..game.len() {
        if game[i] == guess[i] {
            res[i] = 0;
        } else {
            res[i] = (guess[i] - game[i]).abs();
        }
    }
    res
}

fn main() {
    let candidate = compare;
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]), vec![0, 0, 0, 0, 3, 3]);
    assert_eq!(candidate(vec![0, 0, 0, 0, 0, 0], vec![0, 0, 0, 0, 0, 0]), vec![0, 0, 0, 0, 0, 0]);
    assert_eq!(candidate(vec![1, 2, 3], vec![-1, -2, -3]), vec![2, 4, 6]);
    assert_eq!(candidate(vec![1, 2, 3, 5], vec![-1, 2, 3, 4]), vec![2, 0, 0, 1]);
}

-----------------------------
/// I think we all remember that feeling when the result of some long-awaited
/// event is finally known. The feelings and thoughts you have at that moment are
/// definitely worth noting down and comparing.
/// Your task is to determine if a person correctly guessed the results of a number of matches.
/// You are given two vectors of scores and guesses of equal length, where each index shows a match. 
/// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,
/// the value is 0, and if not, the value is the absolute difference between the guess and the score.
/// example:
/// >>> compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2])
/// vec![0, 0, 0, 0, 3, 3]
/// >>> compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2])
/// vec![4, 4, 1, 0, 0, 6]
fn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {

    assert_eq!(game.len(), guess.len());
    let mut result = vec![];
    for i in 0..game.len() {
        if game[i] == guess[i] {
            result.push(0);
        } else {
            result.push(game[i] - guess[i].abs());
        }
    }
    result
}

fn main() {
    let candidate = compare;
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]), vec![0, 0, 0, 0, 3, 3]);
    assert_eq!(candidate(vec![0, 0, 0, 0, 0, 0], vec![0, 0, 0, 0, 0, 0]), vec![0, 0, 0, 0, 0, 0]);
    assert_eq!(candidate(vec![1, 2, 3], vec![-1, -2, -3]), vec![2, 4, 6]);
    assert_eq!(candidate(vec![1, 2, 3, 5], vec![-1, 2, 3, 4]), vec![2, 0, 0, 1]);
}

-----------------------------
/// I think we all remember that feeling when the result of some long-awaited
/// event is finally known. The feelings and thoughts you have at that moment are
/// definitely worth noting down and comparing.
/// Your task is to determine if a person correctly guessed the results of a number of matches.
/// You are given two vectors of scores and guesses of equal length, where each index shows a match. 
/// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,
/// the value is 0, and if not, the value is the absolute difference between the guess and the score.
/// example:
/// >>> compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2])
/// vec![0, 0, 0, 0, 3, 3]
/// >>> compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2])
/// vec![4, 4, 1, 0, 0, 6]
fn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {

    game
        .into_iter()
        .zip(guess.into_iter())
        .map(|(x, y)| (x - y).abs())
        .collect()
}

fn main() {
    let candidate = compare;
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]), vec![0, 0, 0, 0, 3, 3]);
    assert_eq!(candidate(vec![0, 0, 0, 0, 0, 0], vec![0, 0, 0, 0, 0, 0]), vec![0, 0, 0, 0, 0, 0]);
    assert_eq!(candidate(vec![1, 2, 3], vec![-1, -2, -3]), vec![2, 4, 6]);
    assert_eq!(candidate(vec![1, 2, 3, 5], vec![-1, 2, 3, 4]), vec![2, 0, 0, 1]);
}

-----------------------------
/// I think we all remember that feeling when the result of some long-awaited
/// event is finally known. The feelings and thoughts you have at that moment are
/// definitely worth noting down and comparing.
/// Your task is to determine if a person correctly guessed the results of a number of matches.
/// You are given two vectors of scores and guesses of equal length, where each index shows a match. 
/// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,
/// the value is 0, and if not, the value is the absolute difference between the guess and the score.
/// example:
/// >>> compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2])
/// vec![0, 0, 0, 0, 3, 3]
/// >>> compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2])
/// vec![4, 4, 1, 0, 0, 6]
fn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {

    game.into_iter().zip(guess.into_iter()).map(|(g, i)| if g == i {
        0
    } else {
        (g - i).abs()
    }).collect()
}

fn main() {
    let candidate = compare;
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]), vec![0, 0, 0, 0, 3, 3]);
    assert_eq!(candidate(vec![0, 0, 0, 0, 0, 0], vec![0, 0, 0, 0, 0, 0]), vec![0, 0, 0, 0, 0, 0]);
    assert_eq!(candidate(vec![1, 2, 3], vec![-1, -2, -3]), vec![2, 4, 6]);
    assert_eq!(candidate(vec![1, 2, 3, 5], vec![-1, 2, 3, 4]), vec![2, 0, 0, 1]);
}

===============================
/// You will be given the name of a class (a string) and a vector of extensions.
/// The extensions are to be used to load additional classes to the class. The
/// strength of the extension is as follows: Let CAP be the number of the uppercase
/// letters in the extension's name, and let SM be the number of lowercase letters 
/// in the extension's name, the strength is given by the fraction CAP - SM. 
/// You should find the strongest extension and return a string in this 
/// format: ClassName.StrongestExtensionName.
/// If there are two or more extensions with the same strength, you should
/// choose the one that comes first in the vector.
/// For example, if you are given "Slices" as the class and a vector of the
/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
/// (its strength is -1).
/// Example:
/// >>> Strongest_Extension(String::from("my_class"), vec![String::from("AA"), String::from("Be"), String::from("CC")])
/// String::from("my_class.AA")
fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {

===============================
-----------------------------
/// You will be given the name of a class (a string) and a vector of extensions.
/// The extensions are to be used to load additional classes to the class. The
/// strength of the extension is as follows: Let CAP be the number of the uppercase
/// letters in the extension's name, and let SM be the number of lowercase letters 
/// in the extension's name, the strength is given by the fraction CAP - SM. 
/// You should find the strongest extension and return a string in this 
/// format: ClassName.StrongestExtensionName.
/// If there are two or more extensions with the same strength, you should
/// choose the one that comes first in the vector.
/// For example, if you are given "Slices" as the class and a vector of the
/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
/// (its strength is -1).
/// Example:
/// >>> Strongest_Extension(String::from("my_class"), vec![String::from("AA"), String::from("Be"), String::from("CC")])
/// String::from("my_class.AA")
fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {

    let mut highest_strength: i32 = 0;
    let mut strongest_extension: String = String::from("");
    for extension in extensions.iter() {
        let mut strength: i32 = 0;
        let mut upper: i32 = 0;
        let mut lower: i32 = 0;
        for character in extension.chars() {
            if character.is_uppercase() {
                upper += 1;
            }
            if character.is_lowercase() {
                lower += 1;
            }
        }
        strength = upper - lower;
        if strength > highest_strength {
            highest_strength = strength;
            strongest_extension = extension.clone();
        }
    }
    if strongest_extension == String::from("") {
        format!("{}.{}", class_name, strongest_extension)
    }
    else {
        format!("{}.{}", class_name, strongest_extension)
    }
}

fn main() {
    let candidate = Strongest_Extension;
    assert_eq!(candidate(String::from("Watashi"), vec![String::from("tEN"), String::from("niNE"), String::from("eIGHt8OKe")]), String::from("Watashi.eIGHt8OKe"));
    assert_eq!(candidate(String::from("Boku123"), vec![String::from("nani"), String::from("NazeDa"), String::from("YEs.WeCaNe"), String::from("32145tggg")]), String::from("Boku123.YEs.WeCaNe"));
    assert_eq!(candidate(String::from("__YESIMHERE"), vec![String::from("t"), String::from("eMptY"), String::from("nothing"), String::from("zeR00"), String::from("NuLl__"), String::from("123NoooneB321")]), String::from("__YESIMHERE.NuLl__"));
    assert_eq!(candidate(String::from("K"), vec![String::from("Ta"), String::from("TAR"), String::from("t234An"), String::from("cosSo")]), String::from("K.TAR"));
    assert_eq!(candidate(String::from("__HAHA"), vec![String::from("Tab"), String::from("123"), String::from("781345"), String::from("-_-")]), String::from("__HAHA.123"));
    assert_eq!(candidate(String::from("YameRore"), vec![String::from("HhAas"), String::from("okIWILL123"), String::from("WorkOut"), String::from("Fails"), String::from("-_-")]), String::from("YameRore.okIWILL123"));
    assert_eq!(candidate(String::from("finNNalLLly"), vec![String::from("Die"), String::from("NowW"), String::from("Wow"), String::from("WoW")]), String::from("finNNalLLly.WoW"));
    assert_eq!(candidate(String::from("_"), vec![String::from("Bb"), String::from("91245")]), String::from("_.Bb"));
    assert_eq!(candidate(String::from("Sp"), vec![String::from("671235"), String::from("Bb")]), String::from("Sp.671235"));
}

-----------------------------
/// You will be given the name of a class (a string) and a vector of extensions.
/// The extensions are to be used to load additional classes to the class. The
/// strength of the extension is as follows: Let CAP be the number of the uppercase
/// letters in the extension's name, and let SM be the number of lowercase letters 
/// in the extension's name, the strength is given by the fraction CAP - SM. 
/// You should find the strongest extension and return a string in this 
/// format: ClassName.StrongestExtensionName.
/// If there are two or more extensions with the same strength, you should
/// choose the one that comes first in the vector.
/// For example, if you are given "Slices" as the class and a vector of the
/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
/// (its strength is -1).
/// Example:
/// >>> Strongest_Extension(String::from("my_class"), vec![String::from("AA"), String::from("Be"), String::from("CC")])
/// String::from("my_class.AA")
fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {

    if extensions.is_empty() {
        class_name
    } else {
        let mut strongest_strength = 0.0;
        let mut strongest_extension_name: String = String::new();
        for extension in &extensions {
            let mut extension_name: String = String::new();
            for character in extension.chars() {
                if character.is_lowercase() {
                    extension_name.push_str(&character.to_lowercase().to_string());
                } else {
                    extension_name.push_str(&character.to_uppercase().to_string());
                }
            }
            let extension_strength = extension_name.chars().filter(|c| c.is_uppercase()).count() as f32 - extension_name.chars().filter(|c| c.is_lowercase()).count() as f32;
            if extension_strength > strongest_strength {
                strongest_strength = extension_strength;
                strongest_extension_name = extension.clone();
            }
        }
        let mut strongest_extension: String = String::new();
        for character in strongest_extension_name.chars() {
            if character.is_lowercase() {
                strongest_extension.push_str(&character.to_lowercase().to_string());
            } else {
                strongest_extension.push_str(&character.to_uppercase().to_string());
            }
        }
        let mut class_with_strongest_extension: String = String::new();
        for character in class_name.chars() {
            if character.is_lowercase() {
                class_with_strongest_extension.push_str(&character.to_lowercase().to_string());
            } else {
                class_with_strongest_extension.push_str(&character.to_uppercase().to_string());
            }
        }
        format!("{}.{}", class_with_strongest_extension, strongest_extension)
    }
}

fn main() {
    let candidate = Strongest_Extension;
    assert_eq!(candidate(String::from("Watashi"), vec![String::from("tEN"), String::from("niNE"), String::from("eIGHt8OKe")]), String::from("Watashi.eIGHt8OKe"));
    assert_eq!(candidate(String::from("Boku123"), vec![String::from("nani"), String::from("NazeDa"), String::from("YEs.WeCaNe"), String::from("32145tggg")]), String::from("Boku123.YEs.WeCaNe"));
    assert_eq!(candidate(String::from("__YESIMHERE"), vec![String::from("t"), String::from("eMptY"), String::from("nothing"), String::from("zeR00"), String::from("NuLl__"), String::from("123NoooneB321")]), String::from("__YESIMHERE.NuLl__"));
    assert_eq!(candidate(String::from("K"), vec![String::from("Ta"), String::from("TAR"), String::from("t234An"), String::from("cosSo")]), String::from("K.TAR"));
    assert_eq!(candidate(String::from("__HAHA"), vec![String::from("Tab"), String::from("123"), String::from("781345"), String::from("-_-")]), String::from("__HAHA.123"));
    assert_eq!(candidate(String::from("YameRore"), vec![String::from("HhAas"), String::from("okIWILL123"), String::from("WorkOut"), String::from("Fails"), String::from("-_-")]), String::from("YameRore.okIWILL123"));
    assert_eq!(candidate(String::from("finNNalLLly"), vec![String::from("Die"), String::from("NowW"), String::from("Wow"), String::from("WoW")]), String::from("finNNalLLly.WoW"));
    assert_eq!(candidate(String::from("_"), vec![String::from("Bb"), String::from("91245")]), String::from("_.Bb"));
    assert_eq!(candidate(String::from("Sp"), vec![String::from("671235"), String::from("Bb")]), String::from("Sp.671235"));
}

-----------------------------
/// You will be given the name of a class (a string) and a vector of extensions.
/// The extensions are to be used to load additional classes to the class. The
/// strength of the extension is as follows: Let CAP be the number of the uppercase
/// letters in the extension's name, and let SM be the number of lowercase letters 
/// in the extension's name, the strength is given by the fraction CAP - SM. 
/// You should find the strongest extension and return a string in this 
/// format: ClassName.StrongestExtensionName.
/// If there are two or more extensions with the same strength, you should
/// choose the one that comes first in the vector.
/// For example, if you are given "Slices" as the class and a vector of the
/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
/// (its strength is -1).
/// Example:
/// >>> Strongest_Extension(String::from("my_class"), vec![String::from("AA"), String::from("Be"), String::from("CC")])
/// String::from("my_class.AA")
fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {

    let mut max_strength = 0;
    let mut max_strength_index = 0;
    for i in 0..extensions.len() {
        let mut num_of_uppercase = 0;
        let mut num_of_lowercase = 0;
        for c in extensions[i].chars() {
            if c.is_uppercase() {
                num_of_uppercase += 1;
            } else if c.is_lowercase() {
                num_of_lowercase += 1;
            }
        }
        let strength = num_of_uppercase - num_of_lowercase;
        if strength > max_strength {
            max_strength = strength;
            max_strength_index = i;
        }
    }
    return format!("{}.{}", class_name, extensions[max_strength_index]);
}

fn main() {
    let candidate = Strongest_Extension;
    assert_eq!(candidate(String::from("Watashi"), vec![String::from("tEN"), String::from("niNE"), String::from("eIGHt8OKe")]), String::from("Watashi.eIGHt8OKe"));
    assert_eq!(candidate(String::from("Boku123"), vec![String::from("nani"), String::from("NazeDa"), String::from("YEs.WeCaNe"), String::from("32145tggg")]), String::from("Boku123.YEs.WeCaNe"));
    assert_eq!(candidate(String::from("__YESIMHERE"), vec![String::from("t"), String::from("eMptY"), String::from("nothing"), String::from("zeR00"), String::from("NuLl__"), String::from("123NoooneB321")]), String::from("__YESIMHERE.NuLl__"));
    assert_eq!(candidate(String::from("K"), vec![String::from("Ta"), String::from("TAR"), String::from("t234An"), String::from("cosSo")]), String::from("K.TAR"));
    assert_eq!(candidate(String::from("__HAHA"), vec![String::from("Tab"), String::from("123"), String::from("781345"), String::from("-_-")]), String::from("__HAHA.123"));
    assert_eq!(candidate(String::from("YameRore"), vec![String::from("HhAas"), String::from("okIWILL123"), String::from("WorkOut"), String::from("Fails"), String::from("-_-")]), String::from("YameRore.okIWILL123"));
    assert_eq!(candidate(String::from("finNNalLLly"), vec![String::from("Die"), String::from("NowW"), String::from("Wow"), String::from("WoW")]), String::from("finNNalLLly.WoW"));
    assert_eq!(candidate(String::from("_"), vec![String::from("Bb"), String::from("91245")]), String::from("_.Bb"));
    assert_eq!(candidate(String::from("Sp"), vec![String::from("671235"), String::from("Bb")]), String::from("Sp.671235"));
}

-----------------------------
/// You will be given the name of a class (a string) and a vector of extensions.
/// The extensions are to be used to load additional classes to the class. The
/// strength of the extension is as follows: Let CAP be the number of the uppercase
/// letters in the extension's name, and let SM be the number of lowercase letters 
/// in the extension's name, the strength is given by the fraction CAP - SM. 
/// You should find the strongest extension and return a string in this 
/// format: ClassName.StrongestExtensionName.
/// If there are two or more extensions with the same strength, you should
/// choose the one that comes first in the vector.
/// For example, if you are given "Slices" as the class and a vector of the
/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
/// (its strength is -1).
/// Example:
/// >>> Strongest_Extension(String::from("my_class"), vec![String::from("AA"), String::from("Be"), String::from("CC")])
/// String::from("my_class.AA")
fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {

    // Write your code here
    let mut max_strength = 0.0;
    let mut strongest_extension_index = 0;

    for i in 0..extensions.len() {
        let strength = Strength(extensions[i].as_str());
        if strength > max_strength {
            max_strength = strength;
            strongest_extension_index = i;
        }
    }
    return format!("{}.{}", class_name, extensions[strongest_extension_index]);
}

fn main() {
    let candidate = Strongest_Extension;
    assert_eq!(candidate(String::from("Watashi"), vec![String::from("tEN"), String::from("niNE"), String::from("eIGHt8OKe")]), String::from("Watashi.eIGHt8OKe"));
    assert_eq!(candidate(String::from("Boku123"), vec![String::from("nani"), String::from("NazeDa"), String::from("YEs.WeCaNe"), String::from("32145tggg")]), String::from("Boku123.YEs.WeCaNe"));
    assert_eq!(candidate(String::from("__YESIMHERE"), vec![String::from("t"), String::from("eMptY"), String::from("nothing"), String::from("zeR00"), String::from("NuLl__"), String::from("123NoooneB321")]), String::from("__YESIMHERE.NuLl__"));
    assert_eq!(candidate(String::from("K"), vec![String::from("Ta"), String::from("TAR"), String::from("t234An"), String::from("cosSo")]), String::from("K.TAR"));
    assert_eq!(candidate(String::from("__HAHA"), vec![String::from("Tab"), String::from("123"), String::from("781345"), String::from("-_-")]), String::from("__HAHA.123"));
    assert_eq!(candidate(String::from("YameRore"), vec![String::from("HhAas"), String::from("okIWILL123"), String::from("WorkOut"), String::from("Fails"), String::from("-_-")]), String::from("YameRore.okIWILL123"));
    assert_eq!(candidate(String::from("finNNalLLly"), vec![String::from("Die"), String::from("NowW"), String::from("Wow"), String::from("WoW")]), String::from("finNNalLLly.WoW"));
    assert_eq!(candidate(String::from("_"), vec![String::from("Bb"), String::from("91245")]), String::from("_.Bb"));
    assert_eq!(candidate(String::from("Sp"), vec![String::from("671235"), String::from("Bb")]), String::from("Sp.671235"));
}

-----------------------------
/// You will be given the name of a class (a string) and a vector of extensions.
/// The extensions are to be used to load additional classes to the class. The
/// strength of the extension is as follows: Let CAP be the number of the uppercase
/// letters in the extension's name, and let SM be the number of lowercase letters 
/// in the extension's name, the strength is given by the fraction CAP - SM. 
/// You should find the strongest extension and return a string in this 
/// format: ClassName.StrongestExtensionName.
/// If there are two or more extensions with the same strength, you should
/// choose the one that comes first in the vector.
/// For example, if you are given "Slices" as the class and a vector of the
/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
/// (its strength is -1).
/// Example:
/// >>> Strongest_Extension(String::from("my_class"), vec![String::from("AA"), String::from("Be"), String::from("CC")])
/// String::from("my_class.AA")
fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {

    let mut strongest_class: String = String::from("");
    let mut strongest_extension: String = String::from("");
    let mut strongest_strength: f32 = 0.0;

    // Iterate through extensions
    for extension in extensions {
        // Calculate strength for current extension
        let mut strength: f32 = 0.0;
        for char in extension.chars() {
            if char.is_uppercase() {
                strength += 1.0;
            } else if char.is_lowercase() {
                strength -= 1.0;
            }
        }

        // If this extension is stronger than any other, update strongest values
        if strength > strongest_strength {
            strongest_strength = strength;
            strongest_extension = extension;
            strongest_class = class_name.clone();
        }
    }

    // Return final string
    format!("{}.{}", strongest_class, strongest_extension)
}

fn main() {
    let candidate = Strongest_Extension;
    assert_eq!(candidate(String::from("Watashi"), vec![String::from("tEN"), String::from("niNE"), String::from("eIGHt8OKe")]), String::from("Watashi.eIGHt8OKe"));
    assert_eq!(candidate(String::from("Boku123"), vec![String::from("nani"), String::from("NazeDa"), String::from("YEs.WeCaNe"), String::from("32145tggg")]), String::from("Boku123.YEs.WeCaNe"));
    assert_eq!(candidate(String::from("__YESIMHERE"), vec![String::from("t"), String::from("eMptY"), String::from("nothing"), String::from("zeR00"), String::from("NuLl__"), String::from("123NoooneB321")]), String::from("__YESIMHERE.NuLl__"));
    assert_eq!(candidate(String::from("K"), vec![String::from("Ta"), String::from("TAR"), String::from("t234An"), String::from("cosSo")]), String::from("K.TAR"));
    assert_eq!(candidate(String::from("__HAHA"), vec![String::from("Tab"), String::from("123"), String::from("781345"), String::from("-_-")]), String::from("__HAHA.123"));
    assert_eq!(candidate(String::from("YameRore"), vec![String::from("HhAas"), String::from("okIWILL123"), String::from("WorkOut"), String::from("Fails"), String::from("-_-")]), String::from("YameRore.okIWILL123"));
    assert_eq!(candidate(String::from("finNNalLLly"), vec![String::from("Die"), String::from("NowW"), String::from("Wow"), String::from("WoW")]), String::from("finNNalLLly.WoW"));
    assert_eq!(candidate(String::from("_"), vec![String::from("Bb"), String::from("91245")]), String::from("_.Bb"));
    assert_eq!(candidate(String::from("Sp"), vec![String::from("671235"), String::from("Bb")]), String::from("Sp.671235"));
}

===============================
/// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word
/// >>> cycpattern_check(String::from("abcd"), String::from("abd"))
/// false
/// >>> cycpattern_check(String::from("hello"), String::from("ell"))
/// true
/// >>> cycpattern_check(String::from("whassup"), String::from("psus"))
/// false
/// >>> cycpattern_check(String::from("abab"), String::from("baa"))
/// true
/// >>> cycpattern_check(String::from("efef"), String::from("eeff"))
/// false
/// >>> cycpattern_check(String::from("himenss"), String::from("simen"))
/// true
fn cycpattern_check(a: String, b: String) -> bool {

===============================
-----------------------------
/// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word
/// >>> cycpattern_check(String::from("abcd"), String::from("abd"))
/// false
/// >>> cycpattern_check(String::from("hello"), String::from("ell"))
/// true
/// >>> cycpattern_check(String::from("whassup"), String::from("psus"))
/// false
/// >>> cycpattern_check(String::from("abab"), String::from("baa"))
/// true
/// >>> cycpattern_check(String::from("efef"), String::from("eeff"))
/// false
/// >>> cycpattern_check(String::from("himenss"), String::from("simen"))
/// true
fn cycpattern_check(a: String, b: String) -> bool {

    if a.len() == 0 || b.len() == 0 {
        return false;
    }
    if a.len() < b.len() {
        return false;
    }
    let mut rot_b = b.clone();
    let mut i = 0;
    loop {
        if a.contains(&rot_b) {
            return true;
        }
        rot_b.insert(i, '0');
        rot_b.remove(0);
        i += 1;
        if i == b.len() {
            return false;
        }
    }
}

fn main() {
    let candidate = cycpattern_check;
    assert_eq!(candidate(String::from("xyzw"), String::from("xyw")), false);
    assert_eq!(candidate(String::from("yello"), String::from("ell")), true);
    assert_eq!(candidate(String::from("whattup"), String::from("ptut")), false);
    assert_eq!(candidate(String::from("efef"), String::from("fee")), true);
    assert_eq!(candidate(String::from("abab"), String::from("aabb")), false);
    assert_eq!(candidate(String::from("winemtt"), String::from("tinem")), true);
}

-----------------------------
/// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word
/// >>> cycpattern_check(String::from("abcd"), String::from("abd"))
/// false
/// >>> cycpattern_check(String::from("hello"), String::from("ell"))
/// true
/// >>> cycpattern_check(String::from("whassup"), String::from("psus"))
/// false
/// >>> cycpattern_check(String::from("abab"), String::from("baa"))
/// true
/// >>> cycpattern_check(String::from("efef"), String::from("eeff"))
/// false
/// >>> cycpattern_check(String::from("himenss"), String::from("simen"))
/// true
fn cycpattern_check(a: String, b: String) -> bool {

    if b.len() > a.len() {
        return false;
    }

    let b = b.chars().collect::<Vec<char>>();
    let mut rot_count = 0;

    for i in 0..b.len() {
        let rot_b = get_rotated_char(&b, i);

        if a.contains(&rot_b.to_string()) {
            rot_count += 1;
        }
    }

    if rot_count == 0 {
        return false;
    } else {
        return true;
    }
}

fn main() {
    let candidate = cycpattern_check;
    assert_eq!(candidate(String::from("xyzw"), String::from("xyw")), false);
    assert_eq!(candidate(String::from("yello"), String::from("ell")), true);
    assert_eq!(candidate(String::from("whattup"), String::from("ptut")), false);
    assert_eq!(candidate(String::from("efef"), String::from("fee")), true);
    assert_eq!(candidate(String::from("abab"), String::from("aabb")), false);
    assert_eq!(candidate(String::from("winemtt"), String::from("tinem")), true);
}

-----------------------------
/// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word
/// >>> cycpattern_check(String::from("abcd"), String::from("abd"))
/// false
/// >>> cycpattern_check(String::from("hello"), String::from("ell"))
/// true
/// >>> cycpattern_check(String::from("whassup"), String::from("psus"))
/// false
/// >>> cycpattern_check(String::from("abab"), String::from("baa"))
/// true
/// >>> cycpattern_check(String::from("efef"), String::from("eeff"))
/// false
/// >>> cycpattern_check(String::from("himenss"), String::from("simen"))
/// true
fn cycpattern_check(a: String, b: String) -> bool {

    for i in 0..b.len() {
        let a_rot = rotate(a.clone(), i);
        if a_rot.contains(b.as_str()) {
            return true;
        }
    }
    false
}

fn main() {
    let candidate = cycpattern_check;
    assert_eq!(candidate(String::from("xyzw"), String::from("xyw")), false);
    assert_eq!(candidate(String::from("yello"), String::from("ell")), true);
    assert_eq!(candidate(String::from("whattup"), String::from("ptut")), false);
    assert_eq!(candidate(String::from("efef"), String::from("fee")), true);
    assert_eq!(candidate(String::from("abab"), String::from("aabb")), false);
    assert_eq!(candidate(String::from("winemtt"), String::from("tinem")), true);
}

-----------------------------
/// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word
/// >>> cycpattern_check(String::from("abcd"), String::from("abd"))
/// false
/// >>> cycpattern_check(String::from("hello"), String::from("ell"))
/// true
/// >>> cycpattern_check(String::from("whassup"), String::from("psus"))
/// false
/// >>> cycpattern_check(String::from("abab"), String::from("baa"))
/// true
/// >>> cycpattern_check(String::from("efef"), String::from("eeff"))
/// false
/// >>> cycpattern_check(String::from("himenss"), String::from("simen"))
/// true
fn cycpattern_check(a: String, b: String) -> bool {

    let a_chars = a.chars().collect::<Vec<char>>();
    let b_chars = b.chars().collect::<Vec<char>>();
    let a_string: String = a_chars.into_iter().collect();
    let b_string: String = b_chars.into_iter().collect();
    if b_string.len() == 0 {
        return false;
    }
    let mut pattern_vec: Vec<String> = Vec::new();
    let mut rotated_string: String = b_string.clone();
    for _ in 1..=b_string.len() {
        let mut current_string: String = String::from(rotated_string.clone());
        for _ in 0..1 {
            current_string.push(b_chars.pop().unwrap());
        }
        pattern_vec.push(current_string);
        rotated_string = current_string;
    }
    for i in 0..a_string.len() {
        if pattern_vec.contains(&a_string[i..i + b_string.len()].to_string()) {
            return true;
        }
    }
    return false;
}

fn main() {
    let candidate = cycpattern_check;
    assert_eq!(candidate(String::from("xyzw"), String::from("xyw")), false);
    assert_eq!(candidate(String::from("yello"), String::from("ell")), true);
    assert_eq!(candidate(String::from("whattup"), String::from("ptut")), false);
    assert_eq!(candidate(String::from("efef"), String::from("fee")), true);
    assert_eq!(candidate(String::from("abab"), String::from("aabb")), false);
    assert_eq!(candidate(String::from("winemtt"), String::from("tinem")), true);
}

-----------------------------
/// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word
/// >>> cycpattern_check(String::from("abcd"), String::from("abd"))
/// false
/// >>> cycpattern_check(String::from("hello"), String::from("ell"))
/// true
/// >>> cycpattern_check(String::from("whassup"), String::from("psus"))
/// false
/// >>> cycpattern_check(String::from("abab"), String::from("baa"))
/// true
/// >>> cycpattern_check(String::from("efef"), String::from("eeff"))
/// false
/// >>> cycpattern_check(String::from("himenss"), String::from("simen"))
/// true
fn cycpattern_check(a: String, b: String) -> bool {

    // 1) find len of b
    let b_len = b.len();

    // 2) find if b is in a
    if a.contains(&b) {
        return true;
    }

    // 3) create cyc pattern
    let mut cyc_pattern = String::new();

    // 4) check if cyc_pattern is in a
    for i in 0..a_len {
        cyc_pattern.push(a[i]);

        if a.contains(&cyc_pattern) {
            return true;
        }

        cyc_pattern.remove(0);
    }

    false
}

fn main() {
    let candidate = cycpattern_check;
    assert_eq!(candidate(String::from("xyzw"), String::from("xyw")), false);
    assert_eq!(candidate(String::from("yello"), String::from("ell")), true);
    assert_eq!(candidate(String::from("whattup"), String::from("ptut")), false);
    assert_eq!(candidate(String::from("efef"), String::from("fee")), true);
    assert_eq!(candidate(String::from("abab"), String::from("aabb")), false);
    assert_eq!(candidate(String::from("winemtt"), String::from("tinem")), true);
}

===============================
/// Given an integer. return a tuple that has the number of even and odd digits respectively.
/// Example:
/// >>> even_odd_count(-12)
/// (1, 1)
/// >>> even_odd_count(123)
/// (1, 2)
fn even_odd_count(num: isize) -> (isize, isize) {

===============================
-----------------------------
/// Given an integer. return a tuple that has the number of even and odd digits respectively.
/// Example:
/// >>> even_odd_count(-12)
/// (1, 1)
/// >>> even_odd_count(123)
/// (1, 2)
fn even_odd_count(num: isize) -> (isize, isize) {

    if num < 0 {
        let (a, b) = even_odd_count(-num as usize);
        (b, a)
    } else {
        let mut count = 0;
        let mut e = 0;
        for digit in num.to_string().chars() {
            if digit.to_digit(10).unwrap() % 2 == 0 {
                e += 1;
            } else {
                count += 1;
            }
        }
        (e, count)
    }
}

fn main() {
    let candidate = even_odd_count;
    assert_eq!(candidate(7), (0, 1));
    assert_eq!(candidate(-78), (1, 1));
    assert_eq!(candidate(3452), (2, 2));
    assert_eq!(candidate(346211), (3, 3));
    assert_eq!(candidate(-345821), (3, 3));
    assert_eq!(candidate(-2), (1, 0));
    assert_eq!(candidate(-45347), (2, 3));
    assert_eq!(candidate(0), (1, 0));
}

-----------------------------
/// Given an integer. return a tuple that has the number of even and odd digits respectively.
/// Example:
/// >>> even_odd_count(-12)
/// (1, 1)
/// >>> even_odd_count(123)
/// (1, 2)
fn even_odd_count(num: isize) -> (isize, isize) {

    let mut even_count = 0;
    let mut odd_count = 0;

    for digit in num.abs().to_string().chars() {
        match digit.to_digit(10).unwrap() % 2 {
            0 => {
                even_count += 1;
            }
            _ => {
                odd_count += 1;
            }
        }
    }
    return (even_count, odd_count);
}

fn main() {
    let candidate = even_odd_count;
    assert_eq!(candidate(7), (0, 1));
    assert_eq!(candidate(-78), (1, 1));
    assert_eq!(candidate(3452), (2, 2));
    assert_eq!(candidate(346211), (3, 3));
    assert_eq!(candidate(-345821), (3, 3));
    assert_eq!(candidate(-2), (1, 0));
    assert_eq!(candidate(-45347), (2, 3));
    assert_eq!(candidate(0), (1, 0));
}

-----------------------------
/// Given an integer. return a tuple that has the number of even and odd digits respectively.
/// Example:
/// >>> even_odd_count(-12)
/// (1, 1)
/// >>> even_odd_count(123)
/// (1, 2)
fn even_odd_count(num: isize) -> (isize, isize) {

    let num_string = num.to_string();
    let mut even_counter = 0;
    let mut odd_counter = 0;
    for char in num_string.chars() {
        if char == '0' {
            continue;
        }
        if char % 2 == 0 {
            even_counter += 1;
        } else {
            odd_counter += 1;
        }
    }
    (even_counter, odd_counter)
}

fn main() {
    let candidate = even_odd_count;
    assert_eq!(candidate(7), (0, 1));
    assert_eq!(candidate(-78), (1, 1));
    assert_eq!(candidate(3452), (2, 2));
    assert_eq!(candidate(346211), (3, 3));
    assert_eq!(candidate(-345821), (3, 3));
    assert_eq!(candidate(-2), (1, 0));
    assert_eq!(candidate(-45347), (2, 3));
    assert_eq!(candidate(0), (1, 0));
}

-----------------------------
/// Given an integer. return a tuple that has the number of even and odd digits respectively.
/// Example:
/// >>> even_odd_count(-12)
/// (1, 1)
/// >>> even_odd_count(123)
/// (1, 2)
fn even_odd_count(num: isize) -> (isize, isize) {

    let mut even = 0;
    let mut odd = 0;

    let mut num = num;
    while num != 0 {
        if num % 2 == 0 {
            even += 1;
        } else {
            odd += 1;
        }

        num = num / 10;
    }

    (even, odd)
}

fn main() {
    let candidate = even_odd_count;
    assert_eq!(candidate(7), (0, 1));
    assert_eq!(candidate(-78), (1, 1));
    assert_eq!(candidate(3452), (2, 2));
    assert_eq!(candidate(346211), (3, 3));
    assert_eq!(candidate(-345821), (3, 3));
    assert_eq!(candidate(-2), (1, 0));
    assert_eq!(candidate(-45347), (2, 3));
    assert_eq!(candidate(0), (1, 0));
}

-----------------------------
/// Given an integer. return a tuple that has the number of even and odd digits respectively.
/// Example:
/// >>> even_odd_count(-12)
/// (1, 1)
/// >>> even_odd_count(123)
/// (1, 2)
fn even_odd_count(num: isize) -> (isize, isize) {

    let mut even_count = 0;
    let mut odd_count = 0;

    for digit in num.to_string().chars() {
        let is_even = digit.to_digit(10).unwrap() % 2 == 0;

        if is_even {
            even_count += 1;
        } else {
            odd_count += 1;
        }
    }

    (even_count, odd_count)
}

fn main() {
    let candidate = even_odd_count;
    assert_eq!(candidate(7), (0, 1));
    assert_eq!(candidate(-78), (1, 1));
    assert_eq!(candidate(3452), (2, 2));
    assert_eq!(candidate(346211), (3, 3));
    assert_eq!(candidate(-345821), (3, 3));
    assert_eq!(candidate(-2), (1, 0));
    assert_eq!(candidate(-45347), (2, 3));
    assert_eq!(candidate(0), (1, 0));
}

===============================
/// Given a positive integer, obtain its roman numeral equivalent as a string,
/// and return it in lowercase.
/// Restrictions: 1 <= num <= 1000
/// Examples:
/// >>> int_to_mini_roman(19)
/// String::from("xix")
/// >>> int_to_mini_roman(152)
/// String::from("clii")
/// >>> int_to_mini_roman(426)
/// String::from("cdxxvi")
fn int_to_mini_roman(number: isize) -> String {

===============================
-----------------------------
/// Given a positive integer, obtain its roman numeral equivalent as a string,
/// and return it in lowercase.
/// Restrictions: 1 <= num <= 1000
/// Examples:
/// >>> int_to_mini_roman(19)
/// String::from("xix")
/// >>> int_to_mini_roman(152)
/// String::from("clii")
/// >>> int_to_mini_roman(426)
/// String::from("cdxxvi")
fn int_to_mini_roman(number: isize) -> String {

    let mut result = String::new();
    let mut x = number;

    let mut thousand = 1000;
    let mut hundred = 100;
    let mut ten = 10;
    let mut one = 1;

    while x >= thousand {
        result.push('m');
        x -= thousand;
    }

    while x >= hundred {
        result.push('c');
        x -= hundred;
    }

    while x >= ten {
        result.push('x');
        x -= ten;
    }

    while x >= one {
        result.push('i');
        x -= one;
    }

    result
}

fn main() {
    let candidate = int_to_mini_roman;
    assert_eq!(candidate(19), String::from("xix"));
    assert_eq!(candidate(152), String::from("clii"));
    assert_eq!(candidate(251), String::from("ccli"));
    assert_eq!(candidate(426), String::from("cdxxvi"));
    assert_eq!(candidate(500), String::from("d"));
    assert_eq!(candidate(1), String::from("i"));
    assert_eq!(candidate(4), String::from("iv"));
    assert_eq!(candidate(43), String::from("xliii"));
    assert_eq!(candidate(90), String::from("xc"));
    assert_eq!(candidate(94), String::from("xciv"));
    assert_eq!(candidate(532), String::from("dxxxii"));
    assert_eq!(candidate(900), String::from("cm"));
    assert_eq!(candidate(994), String::from("cmxciv"));
    assert_eq!(candidate(1000), String::from("m"));
}

-----------------------------
/// Given a positive integer, obtain its roman numeral equivalent as a string,
/// and return it in lowercase.
/// Restrictions: 1 <= num <= 1000
/// Examples:
/// >>> int_to_mini_roman(19)
/// String::from("xix")
/// >>> int_to_mini_roman(152)
/// String::from("clii")
/// >>> int_to_mini_roman(426)
/// String::from("cdxxvi")
fn int_to_mini_roman(number: isize) -> String {

    if number < 0 {
        return String::new();
    } else if number < 10 {
        return number.to_string();
    } else if number >= 100 {
        let mut s = String::from("m");
        let n = number;
        let t = n % 100;
        s.push_str(&int_to_mini_roman(n - t));
        s.push_str(&int_to_mini_roman(t));
        return s;
    } else if number >= 10 && number < 100 {
        let mut s = String::new();
        let n = number;
        let t = n % 10;
        s.push_str(&int_to_mini_roman(n - t));
        s.push_str(&int_to_mini_roman(t));
        return s;
    } else if number >= 90 && number < 100 {
        return String::from("xc") + &int_to_mini_roman(number - 90);
    } else if number >= 80 && number < 90 {
        return String::from("xl") + &int_to_mini_roman(number - 80);
    } else if number >= 70 && number < 80 {
        return String::from("lxx") + &int_to_mini_roman(number - 70);
    } else if number >= 60 && number < 70 {
        return String::from("lxxx") + &int_to_mini_roman(number - 60);
    } else if number >= 50 && number < 60 {
        return String::from("dx") + &int_to_mini_roman(number - 50);
    } else if number >= 40 && number < 50 {
        return String::from("xl") + &int_to_mini_roman(number - 40);
    } else if number >= 30 && number < 40 {
        return String::from("xxx") + &int_to_mini_roman(number - 30);
    } else if number >= 20 && number < 30 {
        return String::from("xx") + &int_to_mini_roman(number - 20);
    } else if number >= 10 && number < 20 {
        return String::from("ix") + &int_to_mini_roman(number - 10);
    } else if number >= 9 && number < 10 {
        return String::from("viii") + &int_to_mini_roman(number - 9);
    } else if number >= 8 && number < 9 {
        return String::from("vii") + &int_to_mini_roman(number - 8);
    } else if number >= 7 && number < 8 {
        return String::from("vi") + &int_to_mini_roman(number - 7);
    } else if number >= 6 && number < 7 {
        return String::from("vi") + &int_to_mini_roman(number - 6);
    } else if number >= 5 && number < 6 {
        return String::from("v") + &int_to_mini_roman(number - 5);
    } else if number >= 4 && number < 5 {
        return String::from("iv") + &int_to_mini_roman(number - 4);
    } else if number >= 3 && number < 
}

fn main() {
    let candidate = int_to_mini_roman;
    assert_eq!(candidate(19), String::from("xix"));
    assert_eq!(candidate(152), String::from("clii"));
    assert_eq!(candidate(251), String::from("ccli"));
    assert_eq!(candidate(426), String::from("cdxxvi"));
    assert_eq!(candidate(500), String::from("d"));
    assert_eq!(candidate(1), String::from("i"));
    assert_eq!(candidate(4), String::from("iv"));
    assert_eq!(candidate(43), String::from("xliii"));
    assert_eq!(candidate(90), String::from("xc"));
    assert_eq!(candidate(94), String::from("xciv"));
    assert_eq!(candidate(532), String::from("dxxxii"));
    assert_eq!(candidate(900), String::from("cm"));
    assert_eq!(candidate(994), String::from("cmxciv"));
    assert_eq!(candidate(1000), String::from("m"));
}

-----------------------------
/// Given a positive integer, obtain its roman numeral equivalent as a string,
/// and return it in lowercase.
/// Restrictions: 1 <= num <= 1000
/// Examples:
/// >>> int_to_mini_roman(19)
/// String::from("xix")
/// >>> int_to_mini_roman(152)
/// String::from("clii")
/// >>> int_to_mini_roman(426)
/// String::from("cdxxvi")
fn int_to_mini_roman(number: isize) -> String {

    let mut num = number;
    let mut roman = String::new();
    if num >= 1000 {
        roman.push('m');
        num -= 1000;
    }

    if num >= 900 {
        roman.push_str("cm");
        num -= 900;
    }

    if num >= 500 {
        roman.push_str("d");
        num -= 500;
    }

    if num >= 400 {
        roman.push_str("cd");
        num -= 400;
    }

    if num >= 100 {
        roman.push('c');
        num -= 100;
    }

    if num >= 90 {
        roman.push_str("xc");
        num -= 90;
    }

    if num >= 50 {
        roman.push_str("l");
        num -= 50;
    }

    if num >= 40 {
        roman.push_str("xl");
        num -= 40;
    }

    if num >= 10 {
        roman.push('x');
        num -= 10;
    }

    if num >= 9 {
        roman.push_str("ix");
        num -= 9;
    }

    if num >= 5 {
        roman.push_str("v");
        num -= 5;
    }

    if num >= 4 {
        roman.push_str("iv");
        num -= 4;
    }

    if num >= 1 {
        roman.push('i');
        num -= 1;
    }

    roman
}

fn main() {
    let candidate = int_to_mini_roman;
    assert_eq!(candidate(19), String::from("xix"));
    assert_eq!(candidate(152), String::from("clii"));
    assert_eq!(candidate(251), String::from("ccli"));
    assert_eq!(candidate(426), String::from("cdxxvi"));
    assert_eq!(candidate(500), String::from("d"));
    assert_eq!(candidate(1), String::from("i"));
    assert_eq!(candidate(4), String::from("iv"));
    assert_eq!(candidate(43), String::from("xliii"));
    assert_eq!(candidate(90), String::from("xc"));
    assert_eq!(candidate(94), String::from("xciv"));
    assert_eq!(candidate(532), String::from("dxxxii"));
    assert_eq!(candidate(900), String::from("cm"));
    assert_eq!(candidate(994), String::from("cmxciv"));
    assert_eq!(candidate(1000), String::from("m"));
}

-----------------------------
/// Given a positive integer, obtain its roman numeral equivalent as a string,
/// and return it in lowercase.
/// Restrictions: 1 <= num <= 1000
/// Examples:
/// >>> int_to_mini_roman(19)
/// String::from("xix")
/// >>> int_to_mini_roman(152)
/// String::from("clii")
/// >>> int_to_mini_roman(426)
/// String::from("cdxxvi")
fn int_to_mini_roman(number: isize) -> String {

    // Write your code here
    if number < 1 || number > 1000 {
        panic!("Number out of range!")
    }
    let mut s = String::from("");
    let mut num = number;
    let mut tmp = 1000;
    while num > 0 {
        let (unit, tmp) = get_unit(num, tmp);
        num -= unit;
        s.push(unit);
    }
    return s;
}

fn main() {
    let candidate = int_to_mini_roman;
    assert_eq!(candidate(19), String::from("xix"));
    assert_eq!(candidate(152), String::from("clii"));
    assert_eq!(candidate(251), String::from("ccli"));
    assert_eq!(candidate(426), String::from("cdxxvi"));
    assert_eq!(candidate(500), String::from("d"));
    assert_eq!(candidate(1), String::from("i"));
    assert_eq!(candidate(4), String::from("iv"));
    assert_eq!(candidate(43), String::from("xliii"));
    assert_eq!(candidate(90), String::from("xc"));
    assert_eq!(candidate(94), String::from("xciv"));
    assert_eq!(candidate(532), String::from("dxxxii"));
    assert_eq!(candidate(900), String::from("cm"));
    assert_eq!(candidate(994), String::from("cmxciv"));
    assert_eq!(candidate(1000), String::from("m"));
}

-----------------------------
/// Given a positive integer, obtain its roman numeral equivalent as a string,
/// and return it in lowercase.
/// Restrictions: 1 <= num <= 1000
/// Examples:
/// >>> int_to_mini_roman(19)
/// String::from("xix")
/// >>> int_to_mini_roman(152)
/// String::from("clii")
/// >>> int_to_mini_roman(426)
/// String::from("cdxxvi")
fn int_to_mini_roman(number: isize) -> String {

    let (d, r) = number.div_rem(&1000);
    let mut result = String::with_capacity(4);

    result.push_str(match d {
        0 => "",
        1 => "m",
        2 => "mm",
        3 => "mmm",
        _ => unreachable!(),
    });
    result.push_str(match r {
        0 => "",
        1 => "c",
        2 => "cc",
        3 => "ccc",
        4 => "cd",
        5 => "d",
        6 => "dc",
        7 => "dcc",
        8 => "dccc",
        9 => "cm",
        _ => unreachable!(),
    });
    result.push_str(match r {
        0 => "",
        1 => "x",
        2 => "xx",
        3 => "xxx",
        4 => "xl",
        5 => "l",
        6 => "lx",
        7 => "lxx",
        8 => "lxxx",
        9 => "x
}

fn main() {
    let candidate = int_to_mini_roman;
    assert_eq!(candidate(19), String::from("xix"));
    assert_eq!(candidate(152), String::from("clii"));
    assert_eq!(candidate(251), String::from("ccli"));
    assert_eq!(candidate(426), String::from("cdxxvi"));
    assert_eq!(candidate(500), String::from("d"));
    assert_eq!(candidate(1), String::from("i"));
    assert_eq!(candidate(4), String::from("iv"));
    assert_eq!(candidate(43), String::from("xliii"));
    assert_eq!(candidate(90), String::from("xc"));
    assert_eq!(candidate(94), String::from("xciv"));
    assert_eq!(candidate(532), String::from("dxxxii"));
    assert_eq!(candidate(900), String::from("cm"));
    assert_eq!(candidate(994), String::from("cmxciv"));
    assert_eq!(candidate(1000), String::from("m"));
}

===============================
/// Given the lengths of the three sides of a triangle. Return true if the three
/// sides form a right-angled triangle, false otherwise.
/// A right-angled triangle is a triangle in which one angle is right angle or 
/// 90 degree.
/// Example:
/// >>> right_angle_triangle(3, 4, 5)
/// true
/// >>> right_angle_triangle(1, 2, 3)
/// false
fn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {

===============================
-----------------------------
/// Given the lengths of the three sides of a triangle. Return true if the three
/// sides form a right-angled triangle, false otherwise.
/// A right-angled triangle is a triangle in which one angle is right angle or 
/// 90 degree.
/// Example:
/// >>> right_angle_triangle(3, 4, 5)
/// true
/// >>> right_angle_triangle(1, 2, 3)
/// false
fn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {

    a * a + b * b == c * c || b * b + c * c == a * a || a * a + c * c == b * b
}

fn main() {
    let candidate = right_angle_triangle;
    assert_eq!(candidate(3, 4, 5), true);
    assert_eq!(candidate(1, 2, 3), false);
    assert_eq!(candidate(10, 6, 8), true);
    assert_eq!(candidate(2, 2, 2), false);
    assert_eq!(candidate(7, 24, 25), true);
    assert_eq!(candidate(10, 5, 7), false);
    assert_eq!(candidate(5, 12, 13), true);
    assert_eq!(candidate(15, 8, 17), true);
    assert_eq!(candidate(48, 55, 73), true);
    assert_eq!(candidate(1, 1, 1), false);
    assert_eq!(candidate(2, 2, 10), false);
}

-----------------------------
/// Given the lengths of the three sides of a triangle. Return true if the three
/// sides form a right-angled triangle, false otherwise.
/// A right-angled triangle is a triangle in which one angle is right angle or 
/// 90 degree.
/// Example:
/// >>> right_angle_triangle(3, 4, 5)
/// true
/// >>> right_angle_triangle(1, 2, 3)
/// false
fn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {

    let p = (a*a + b*b);
    return c*c == p;
}

fn main() {
    let candidate = right_angle_triangle;
    assert_eq!(candidate(3, 4, 5), true);
    assert_eq!(candidate(1, 2, 3), false);
    assert_eq!(candidate(10, 6, 8), true);
    assert_eq!(candidate(2, 2, 2), false);
    assert_eq!(candidate(7, 24, 25), true);
    assert_eq!(candidate(10, 5, 7), false);
    assert_eq!(candidate(5, 12, 13), true);
    assert_eq!(candidate(15, 8, 17), true);
    assert_eq!(candidate(48, 55, 73), true);
    assert_eq!(candidate(1, 1, 1), false);
    assert_eq!(candidate(2, 2, 10), false);
}

-----------------------------
/// Given the lengths of the three sides of a triangle. Return true if the three
/// sides form a right-angled triangle, false otherwise.
/// A right-angled triangle is a triangle in which one angle is right angle or 
/// 90 degree.
/// Example:
/// >>> right_angle_triangle(3, 4, 5)
/// true
/// >>> right_angle_triangle(1, 2, 3)
/// false
fn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {

    let p = (a + b + c) / 2;
    let area = p * (p - a) * (p - b) * (p - c);
    area == 0
}

fn main() {
    let candidate = right_angle_triangle;
    assert_eq!(candidate(3, 4, 5), true);
    assert_eq!(candidate(1, 2, 3), false);
    assert_eq!(candidate(10, 6, 8), true);
    assert_eq!(candidate(2, 2, 2), false);
    assert_eq!(candidate(7, 24, 25), true);
    assert_eq!(candidate(10, 5, 7), false);
    assert_eq!(candidate(5, 12, 13), true);
    assert_eq!(candidate(15, 8, 17), true);
    assert_eq!(candidate(48, 55, 73), true);
    assert_eq!(candidate(1, 1, 1), false);
    assert_eq!(candidate(2, 2, 10), false);
}

-----------------------------
/// Given the lengths of the three sides of a triangle. Return true if the three
/// sides form a right-angled triangle, false otherwise.
/// A right-angled triangle is a triangle in which one angle is right angle or 
/// 90 degree.
/// Example:
/// >>> right_angle_triangle(3, 4, 5)
/// true
/// >>> right_angle_triangle(1, 2, 3)
/// false
fn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {

    return a * a + b * b == c * c || a * a + c * c == b * b;
}

fn main() {
    let candidate = right_angle_triangle;
    assert_eq!(candidate(3, 4, 5), true);
    assert_eq!(candidate(1, 2, 3), false);
    assert_eq!(candidate(10, 6, 8), true);
    assert_eq!(candidate(2, 2, 2), false);
    assert_eq!(candidate(7, 24, 25), true);
    assert_eq!(candidate(10, 5, 7), false);
    assert_eq!(candidate(5, 12, 13), true);
    assert_eq!(candidate(15, 8, 17), true);
    assert_eq!(candidate(48, 55, 73), true);
    assert_eq!(candidate(1, 1, 1), false);
    assert_eq!(candidate(2, 2, 10), false);
}

-----------------------------
/// Given the lengths of the three sides of a triangle. Return true if the three
/// sides form a right-angled triangle, false otherwise.
/// A right-angled triangle is a triangle in which one angle is right angle or 
/// 90 degree.
/// Example:
/// >>> right_angle_triangle(3, 4, 5)
/// true
/// >>> right_angle_triangle(1, 2, 3)
/// false
fn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {

    a * a + b * b == c * c
}

fn main() {
    let candidate = right_angle_triangle;
    assert_eq!(candidate(3, 4, 5), true);
    assert_eq!(candidate(1, 2, 3), false);
    assert_eq!(candidate(10, 6, 8), true);
    assert_eq!(candidate(2, 2, 2), false);
    assert_eq!(candidate(7, 24, 25), true);
    assert_eq!(candidate(10, 5, 7), false);
    assert_eq!(candidate(5, 12, 13), true);
    assert_eq!(candidate(15, 8, 17), true);
    assert_eq!(candidate(48, 55, 73), true);
    assert_eq!(candidate(1, 1, 1), false);
    assert_eq!(candidate(2, 2, 10), false);
}

===============================
/// Write a function that accepts a vector of strings.
/// The vector contains different words. Return the word with maximum number
/// of unique characters. If multiple strings have maximum number of unique
/// characters, return the one which comes first in lexicographical order.
/// >>> find_max(vec![String::from("name"), String::from("of"), String::from("string")])
/// String::from("string")
/// >>> find_max(vec![String::from("name"), String::from("enam"), String::from("game")])
/// String::from("enam")
/// >>> find_max(vec![String::from("aaaaaaa"), String::from("bb"), String::from("cc")])
/// String::from("aaaaaaa")
fn find_max(words: Vec<String>) -> String {

===============================
-----------------------------
/// Write a function that accepts a vector of strings.
/// The vector contains different words. Return the word with maximum number
/// of unique characters. If multiple strings have maximum number of unique
/// characters, return the one which comes first in lexicographical order.
/// >>> find_max(vec![String::from("name"), String::from("of"), String::from("string")])
/// String::from("string")
/// >>> find_max(vec![String::from("name"), String::from("enam"), String::from("game")])
/// String::from("enam")
/// >>> find_max(vec![String::from("aaaaaaa"), String::from("bb"), String::from("cc")])
/// String::from("aaaaaaa")
fn find_max(words: Vec<String>) -> String {

    let mut max = String::new();
    let mut counter = 0;
    for word in words {
        let mut map: HashMap<char, i32> = HashMap::new();
        for ch in word.chars() {
            if !map.contains_key(&ch) {
                map.insert(ch, 1);
            } else {
                let val = map.get(&ch).unwrap();
                let new_val = val + 1;
                map.insert(ch, new_val);
            }
        }
        if map.len() > counter {
            max = word;
            counter = map.len();
        } else if map.len() == counter {
            if word < max {
                max = word;
            }
        }
    }
    max
}

fn main() {
    let candidate = find_max;
    assert_eq!(candidate(vec![String::from("name"), String::from("of"), String::from("string")]), String::from("string"));
    assert_eq!(candidate(vec![String::from("name"), String::from("enam"), String::from("game")]), String::from("enam"));
    assert_eq!(candidate(vec![String::from("aaaaaaa"), String::from("bb"), String::from("cc")]), String::from("aaaaaaa"));
    assert_eq!(candidate(vec![String::from("abc"), String::from("cba")]), String::from("abc"));
    assert_eq!(candidate(vec![String::from("play"), String::from("this"), String::from("game"), String::from("of"), String::from("footbott")]), String::from("footbott"));
    assert_eq!(candidate(vec![String::from("we"), String::from("are"), String::from("gonna"), String::from("rock")]), String::from("gonna"));
    assert_eq!(candidate(vec![String::from("we"), String::from("are"), String::from("a"), String::from("mad"), String::from("nation")]), String::from("nation"));
    assert_eq!(candidate(vec![String::from("this"), String::from("is"), String::from("a"), String::from("prrk")]), String::from("this"));
    assert_eq!(candidate(vec![String::from("b")]), String::from("b"));
    assert_eq!(candidate(vec![String::from("play"), String::from("play"), String::from("play")]), String::from("play"));
}

-----------------------------
/// Write a function that accepts a vector of strings.
/// The vector contains different words. Return the word with maximum number
/// of unique characters. If multiple strings have maximum number of unique
/// characters, return the one which comes first in lexicographical order.
/// >>> find_max(vec![String::from("name"), String::from("of"), String::from("string")])
/// String::from("string")
/// >>> find_max(vec![String::from("name"), String::from("enam"), String::from("game")])
/// String::from("enam")
/// >>> find_max(vec![String::from("aaaaaaa"), String::from("bb"), String::from("cc")])
/// String::from("aaaaaaa")
fn find_max(words: Vec<String>) -> String {

    let mut longest_word = String::from("");
    let mut longest_word_length = 0;
    let mut number_of_characters = 0;

    for word in words {
        number_of_characters = word.chars().collect::<Vec<char>>().len();

        if number_of_characters > longest_word_length {
            longest_word_length = number_of_characters;
            longest_word = word;
        } else if number_of_characters == longest_word_length {
            if word < longest_word {
                longest_word = word;
            }
        }
    }

    longest_word
}

fn main() {
    let candidate = find_max;
    assert_eq!(candidate(vec![String::from("name"), String::from("of"), String::from("string")]), String::from("string"));
    assert_eq!(candidate(vec![String::from("name"), String::from("enam"), String::from("game")]), String::from("enam"));
    assert_eq!(candidate(vec![String::from("aaaaaaa"), String::from("bb"), String::from("cc")]), String::from("aaaaaaa"));
    assert_eq!(candidate(vec![String::from("abc"), String::from("cba")]), String::from("abc"));
    assert_eq!(candidate(vec![String::from("play"), String::from("this"), String::from("game"), String::from("of"), String::from("footbott")]), String::from("footbott"));
    assert_eq!(candidate(vec![String::from("we"), String::from("are"), String::from("gonna"), String::from("rock")]), String::from("gonna"));
    assert_eq!(candidate(vec![String::from("we"), String::from("are"), String::from("a"), String::from("mad"), String::from("nation")]), String::from("nation"));
    assert_eq!(candidate(vec![String::from("this"), String::from("is"), String::from("a"), String::from("prrk")]), String::from("this"));
    assert_eq!(candidate(vec![String::from("b")]), String::from("b"));
    assert_eq!(candidate(vec![String::from("play"), String::from("play"), String::from("play")]), String::from("play"));
}

-----------------------------
/// Write a function that accepts a vector of strings.
/// The vector contains different words. Return the word with maximum number
/// of unique characters. If multiple strings have maximum number of unique
/// characters, return the one which comes first in lexicographical order.
/// >>> find_max(vec![String::from("name"), String::from("of"), String::from("string")])
/// String::from("string")
/// >>> find_max(vec![String::from("name"), String::from("enam"), String::from("game")])
/// String::from("enam")
/// >>> find_max(vec![String::from("aaaaaaa"), String::from("bb"), String::from("cc")])
/// String::from("aaaaaaa")
fn find_max(words: Vec<String>) -> String {

    words.iter().fold((String::from(""), 0), |(max, max_unique_chars), word| {
        if word.chars().count() > max_unique_chars {
            (word.clone(), word.chars().count())
        } else if word.chars().count() == max_unique_chars {
            (
                if word < &max { word.clone() } else { max.clone() },
                max_unique_chars,
            )
        } else {
            (max, max_unique_chars)
        }
    }).0
}

fn main() {
    let candidate = find_max;
    assert_eq!(candidate(vec![String::from("name"), String::from("of"), String::from("string")]), String::from("string"));
    assert_eq!(candidate(vec![String::from("name"), String::from("enam"), String::from("game")]), String::from("enam"));
    assert_eq!(candidate(vec![String::from("aaaaaaa"), String::from("bb"), String::from("cc")]), String::from("aaaaaaa"));
    assert_eq!(candidate(vec![String::from("abc"), String::from("cba")]), String::from("abc"));
    assert_eq!(candidate(vec![String::from("play"), String::from("this"), String::from("game"), String::from("of"), String::from("footbott")]), String::from("footbott"));
    assert_eq!(candidate(vec![String::from("we"), String::from("are"), String::from("gonna"), String::from("rock")]), String::from("gonna"));
    assert_eq!(candidate(vec![String::from("we"), String::from("are"), String::from("a"), String::from("mad"), String::from("nation")]), String::from("nation"));
    assert_eq!(candidate(vec![String::from("this"), String::from("is"), String::from("a"), String::from("prrk")]), String::from("this"));
    assert_eq!(candidate(vec![String::from("b")]), String::from("b"));
    assert_eq!(candidate(vec![String::from("play"), String::from("play"), String::from("play")]), String::from("play"));
}

-----------------------------
/// Write a function that accepts a vector of strings.
/// The vector contains different words. Return the word with maximum number
/// of unique characters. If multiple strings have maximum number of unique
/// characters, return the one which comes first in lexicographical order.
/// >>> find_max(vec![String::from("name"), String::from("of"), String::from("string")])
/// String::from("string")
/// >>> find_max(vec![String::from("name"), String::from("enam"), String::from("game")])
/// String::from("enam")
/// >>> find_max(vec![String::from("aaaaaaa"), String::from("bb"), String::from("cc")])
/// String::from("aaaaaaa")
fn find_max(words: Vec<String>) -> String {

    let mut ans = words[0].clone();
    let mut chars_counter = BTreeMap::new();
    for word in words {
        for c in word.chars() {
            chars_counter.insert(c, chars_counter.get(&c).unwrap_or(&0) + 1);
        }
        let chars = chars_counter.len();
        if chars > chars_counter.get(&ans.chars().nth(0).unwrap()).unwrap_or(&0) {
            ans = word;
        } else if chars == chars_counter.get(&ans.chars().nth(0).unwrap()).unwrap_or(&0) {
            if word < ans {
                ans = word;
            }
        }
        chars_counter.clear();
    }
    ans
}

fn main() {
    let candidate = find_max;
    assert_eq!(candidate(vec![String::from("name"), String::from("of"), String::from("string")]), String::from("string"));
    assert_eq!(candidate(vec![String::from("name"), String::from("enam"), String::from("game")]), String::from("enam"));
    assert_eq!(candidate(vec![String::from("aaaaaaa"), String::from("bb"), String::from("cc")]), String::from("aaaaaaa"));
    assert_eq!(candidate(vec![String::from("abc"), String::from("cba")]), String::from("abc"));
    assert_eq!(candidate(vec![String::from("play"), String::from("this"), String::from("game"), String::from("of"), String::from("footbott")]), String::from("footbott"));
    assert_eq!(candidate(vec![String::from("we"), String::from("are"), String::from("gonna"), String::from("rock")]), String::from("gonna"));
    assert_eq!(candidate(vec![String::from("we"), String::from("are"), String::from("a"), String::from("mad"), String::from("nation")]), String::from("nation"));
    assert_eq!(candidate(vec![String::from("this"), String::from("is"), String::from("a"), String::from("prrk")]), String::from("this"));
    assert_eq!(candidate(vec![String::from("b")]), String::from("b"));
    assert_eq!(candidate(vec![String::from("play"), String::from("play"), String::from("play")]), String::from("play"));
}

-----------------------------
/// Write a function that accepts a vector of strings.
/// The vector contains different words. Return the word with maximum number
/// of unique characters. If multiple strings have maximum number of unique
/// characters, return the one which comes first in lexicographical order.
/// >>> find_max(vec![String::from("name"), String::from("of"), String::from("string")])
/// String::from("string")
/// >>> find_max(vec![String::from("name"), String::from("enam"), String::from("game")])
/// String::from("enam")
/// >>> find_max(vec![String::from("aaaaaaa"), String::from("bb"), String::from("cc")])
/// String::from("aaaaaaa")
fn find_max(words: Vec<String>) -> String {

    let mut word = String::new();
    let mut max_chars = 0;
    for w in words {
        if w.len() > max_chars && w.chars().count() == w.chars().unique().count() {
            max_chars = w.len();
            word = w;
        }
    }
    word
}

fn main() {
    let candidate = find_max;
    assert_eq!(candidate(vec![String::from("name"), String::from("of"), String::from("string")]), String::from("string"));
    assert_eq!(candidate(vec![String::from("name"), String::from("enam"), String::from("game")]), String::from("enam"));
    assert_eq!(candidate(vec![String::from("aaaaaaa"), String::from("bb"), String::from("cc")]), String::from("aaaaaaa"));
    assert_eq!(candidate(vec![String::from("abc"), String::from("cba")]), String::from("abc"));
    assert_eq!(candidate(vec![String::from("play"), String::from("this"), String::from("game"), String::from("of"), String::from("footbott")]), String::from("footbott"));
    assert_eq!(candidate(vec![String::from("we"), String::from("are"), String::from("gonna"), String::from("rock")]), String::from("gonna"));
    assert_eq!(candidate(vec![String::from("we"), String::from("are"), String::from("a"), String::from("mad"), String::from("nation")]), String::from("nation"));
    assert_eq!(candidate(vec![String::from("this"), String::from("is"), String::from("a"), String::from("prrk")]), String::from("this"));
    assert_eq!(candidate(vec![String::from("b")]), String::from("b"));
    assert_eq!(candidate(vec![String::from("play"), String::from("play"), String::from("play")]), String::from("play"));
}

===============================
/// You're a hungry rabbit, and you already have eaten a certain number of carrots,
/// but now you need to eat more carrots to complete the day's meals.
/// you should return a vector of [ total number of eaten carrots after your meals,
/// the number of carrots left after your meals ]
/// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.
/// Example:
/// >>> eat(5, 6, 10)
/// vec![11, 4]
/// >>> eat(4, 8, 9)
/// vec![12, 1]
/// >>> eat(1, 10, 10)
/// vec![11, 0]
/// >>> eat(2, 11, 5)
/// vec![7, 0]
/// Variables:
/// @number : integer
/// the number of carrots that you have eaten.
/// @need : integer
/// the number of carrots that you need to eat.
/// @remaining : integer
/// the number of remaining carrots thet exist in stock
/// Constrain:
/// * 0 <= number <= 1000
/// * 0 <= need <= 1000
/// * 0 <= remaining <= 1000
/// Have fun :)
fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {

===============================
-----------------------------
/// You're a hungry rabbit, and you already have eaten a certain number of carrots,
/// but now you need to eat more carrots to complete the day's meals.
/// you should return a vector of [ total number of eaten carrots after your meals,
/// the number of carrots left after your meals ]
/// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.
/// Example:
/// >>> eat(5, 6, 10)
/// vec![11, 4]
/// >>> eat(4, 8, 9)
/// vec![12, 1]
/// >>> eat(1, 10, 10)
/// vec![11, 0]
/// >>> eat(2, 11, 5)
/// vec![7, 0]
/// Variables:
/// @number : integer
/// the number of carrots that you have eaten.
/// @need : integer
/// the number of carrots that you need to eat.
/// @remaining : integer
/// the number of remaining carrots thet exist in stock
/// Constrain:
/// * 0 <= number <= 1000
/// * 0 <= need <= 1000
/// * 0 <= remaining <= 1000
/// Have fun :)
fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {

    let mut number_remaining: isize = remaining;
    number_remaining += number;
    if number_remaining < need {
        number_remaining = need - number_remaining;
        vec![need, number_remaining]
    } else {
        vec![need + number_remaining, 0]
    }
}

fn main() {
    let candidate = eat;
    assert_eq!(candidate(5, 6, 10), vec![11, 4]);
    assert_eq!(candidate(4, 8, 9), vec![12, 1]);
    assert_eq!(candidate(1, 10, 10), vec![11, 0]);
    assert_eq!(candidate(2, 11, 5), vec![7, 0]);
    assert_eq!(candidate(4, 5, 7), vec![9, 2]);
    assert_eq!(candidate(4, 5, 1), vec![5, 0]);
}

-----------------------------
/// You're a hungry rabbit, and you already have eaten a certain number of carrots,
/// but now you need to eat more carrots to complete the day's meals.
/// you should return a vector of [ total number of eaten carrots after your meals,
/// the number of carrots left after your meals ]
/// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.
/// Example:
/// >>> eat(5, 6, 10)
/// vec![11, 4]
/// >>> eat(4, 8, 9)
/// vec![12, 1]
/// >>> eat(1, 10, 10)
/// vec![11, 0]
/// >>> eat(2, 11, 5)
/// vec![7, 0]
/// Variables:
/// @number : integer
/// the number of carrots that you have eaten.
/// @need : integer
/// the number of carrots that you need to eat.
/// @remaining : integer
/// the number of remaining carrots thet exist in stock
/// Constrain:
/// * 0 <= number <= 1000
/// * 0 <= need <= 1000
/// * 0 <= remaining <= 1000
/// Have fun :)
fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {

    let mut num = number;
    let mut neede = need;
    let mut rem = remaining;

    if neede > rem {
        num += rem;
        rem -= rem;
    } else {
        num += neede;
        rem -= neede;
    }
    vec![num, rem]
}

fn main() {
    let candidate = eat;
    assert_eq!(candidate(5, 6, 10), vec![11, 4]);
    assert_eq!(candidate(4, 8, 9), vec![12, 1]);
    assert_eq!(candidate(1, 10, 10), vec![11, 0]);
    assert_eq!(candidate(2, 11, 5), vec![7, 0]);
    assert_eq!(candidate(4, 5, 7), vec![9, 2]);
    assert_eq!(candidate(4, 5, 1), vec![5, 0]);
}

-----------------------------
/// You're a hungry rabbit, and you already have eaten a certain number of carrots,
/// but now you need to eat more carrots to complete the day's meals.
/// you should return a vector of [ total number of eaten carrots after your meals,
/// the number of carrots left after your meals ]
/// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.
/// Example:
/// >>> eat(5, 6, 10)
/// vec![11, 4]
/// >>> eat(4, 8, 9)
/// vec![12, 1]
/// >>> eat(1, 10, 10)
/// vec![11, 0]
/// >>> eat(2, 11, 5)
/// vec![7, 0]
/// Variables:
/// @number : integer
/// the number of carrots that you have eaten.
/// @need : integer
/// the number of carrots that you need to eat.
/// @remaining : integer
/// the number of remaining carrots thet exist in stock
/// Constrain:
/// * 0 <= number <= 1000
/// * 0 <= need <= 1000
/// * 0 <= remaining <= 1000
/// Have fun :)
fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {

    // write your code here

    let mut num = number;
    let mut need_ = need;
    let mut remaining_ = remaining;

    let mut eaten = vec![];

    if remaining_ < need_ {
        eaten.push(remaining_ + num);
        eaten.push(0);

        return eaten;
    }

    eaten.push(num + need_);

    if remaining_ > need_ {
        eaten.push(remaining_ - need_);
    } else {
        eaten.push(0);
    }

    return eaten;
}

fn main() {
    let candidate = eat;
    assert_eq!(candidate(5, 6, 10), vec![11, 4]);
    assert_eq!(candidate(4, 8, 9), vec![12, 1]);
    assert_eq!(candidate(1, 10, 10), vec![11, 0]);
    assert_eq!(candidate(2, 11, 5), vec![7, 0]);
    assert_eq!(candidate(4, 5, 7), vec![9, 2]);
    assert_eq!(candidate(4, 5, 1), vec![5, 0]);
}

-----------------------------
/// You're a hungry rabbit, and you already have eaten a certain number of carrots,
/// but now you need to eat more carrots to complete the day's meals.
/// you should return a vector of [ total number of eaten carrots after your meals,
/// the number of carrots left after your meals ]
/// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.
/// Example:
/// >>> eat(5, 6, 10)
/// vec![11, 4]
/// >>> eat(4, 8, 9)
/// vec![12, 1]
/// >>> eat(1, 10, 10)
/// vec![11, 0]
/// >>> eat(2, 11, 5)
/// vec![7, 0]
/// Variables:
/// @number : integer
/// the number of carrots that you have eaten.
/// @need : integer
/// the number of carrots that you need to eat.
/// @remaining : integer
/// the number of remaining carrots thet exist in stock
/// Constrain:
/// * 0 <= number <= 1000
/// * 0 <= need <= 1000
/// * 0 <= remaining <= 1000
/// Have fun :)
fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {

    let mut result: Vec<isize> = Vec::new();
    result.push(number + need);
    if number + need > remaining {
        result.push(0);
    } else {
        result.push(remaining - number - need);
    }
    result
}

fn main() {
    let candidate = eat;
    assert_eq!(candidate(5, 6, 10), vec![11, 4]);
    assert_eq!(candidate(4, 8, 9), vec![12, 1]);
    assert_eq!(candidate(1, 10, 10), vec![11, 0]);
    assert_eq!(candidate(2, 11, 5), vec![7, 0]);
    assert_eq!(candidate(4, 5, 7), vec![9, 2]);
    assert_eq!(candidate(4, 5, 1), vec![5, 0]);
}

-----------------------------
/// You're a hungry rabbit, and you already have eaten a certain number of carrots,
/// but now you need to eat more carrots to complete the day's meals.
/// you should return a vector of [ total number of eaten carrots after your meals,
/// the number of carrots left after your meals ]
/// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.
/// Example:
/// >>> eat(5, 6, 10)
/// vec![11, 4]
/// >>> eat(4, 8, 9)
/// vec![12, 1]
/// >>> eat(1, 10, 10)
/// vec![11, 0]
/// >>> eat(2, 11, 5)
/// vec![7, 0]
/// Variables:
/// @number : integer
/// the number of carrots that you have eaten.
/// @need : integer
/// the number of carrots that you need to eat.
/// @remaining : integer
/// the number of remaining carrots thet exist in stock
/// Constrain:
/// * 0 <= number <= 1000
/// * 0 <= need <= 1000
/// * 0 <= remaining <= 1000
/// Have fun :)
fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {

    if number >= need {
        vec![number, 0]
    } else {
        if remaining - need < 0 {
            vec![number + remaining, 0]
        } else {
            vec![number + need, remaining - need]
        }
    }
}

fn main() {
    let candidate = eat;
    assert_eq!(candidate(5, 6, 10), vec![11, 4]);
    assert_eq!(candidate(4, 8, 9), vec![12, 1]);
    assert_eq!(candidate(1, 10, 10), vec![11, 0]);
    assert_eq!(candidate(2, 11, 5), vec![7, 0]);
    assert_eq!(candidate(4, 5, 7), vec![9, 2]);
    assert_eq!(candidate(4, 5, 1), vec![5, 0]);
}

===============================
/// Given two vectors operator, and operand. The first vector has basic algebra operations, and 
/// the second vector is a vector of integers. Use the two given vectors to build the algebric 
/// expression and return the evaluation of this expression.
/// The basic algebra operations:
/// Addition ( + ) 
/// Subtraction ( - ) 
/// Multiplication ( * ) 
/// Floor division ( // ) 
/// Exponentiation ( ** ) 
/// Example:
/// operator['+', '*', '-']
/// vector = [2, 3, 4, 5]
/// result = 2 + 3 * 4 - 5
/// => result = 9
/// Note:
/// The length of operator vector is equal to the length of operand vector minus one.
/// Operand is a vector of of non-negative integers.
/// Operator vector has at least one operator, and operand vector has at least two operands.
fn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {

===============================
-----------------------------
/// Given two vectors operator, and operand. The first vector has basic algebra operations, and 
/// the second vector is a vector of integers. Use the two given vectors to build the algebric 
/// expression and return the evaluation of this expression.
/// The basic algebra operations:
/// Addition ( + ) 
/// Subtraction ( - ) 
/// Multiplication ( * ) 
/// Floor division ( // ) 
/// Exponentiation ( ** ) 
/// Example:
/// operator['+', '*', '-']
/// vector = [2, 3, 4, 5]
/// result = 2 + 3 * 4 - 5
/// => result = 9
/// Note:
/// The length of operator vector is equal to the length of operand vector minus one.
/// Operand is a vector of of non-negative integers.
/// Operator vector has at least one operator, and operand vector has at least two operands.
fn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {

    if operator.len() + 1 != operand.len() {
        return -1;
    }
    let mut stack: Vec<isize> = vec![];
    for (i, item) in operand.iter().enumerate() {
        match i {
            0 => stack.push(*item),
            1 => stack.push(*item),
            _ => {
                let operator_item = &operator[i-2];
                let a = stack.pop().unwrap();
                let b = stack.pop().unwrap();
                match operator_item {
                    "+" => stack.push(a + b),
                    "-" => stack.push(b - a),
                    "*" => stack.push(a * b),
                    "//" => stack.push(b / a),
                    "**" => stack.push(b.pow(a as u32)),
                    _ => return -1,
                }
            }
        }
    }
    stack.pop().unwrap()
}

fn main() {
    let candidate = do_algebra;
    assert_eq!(candidate(vec![String::from("**"), String::from("*"), String::from("+")], vec![2, 3, 4, 5]), 37);
    assert_eq!(candidate(vec![String::from("+"), String::from("*"), String::from("-")], vec![2, 3, 4, 5]), 9);
    assert_eq!(candidate(vec![String::from("//"), String::from("*")], vec![7, 3, 4]), 8);
}

-----------------------------
/// Given two vectors operator, and operand. The first vector has basic algebra operations, and 
/// the second vector is a vector of integers. Use the two given vectors to build the algebric 
/// expression and return the evaluation of this expression.
/// The basic algebra operations:
/// Addition ( + ) 
/// Subtraction ( - ) 
/// Multiplication ( * ) 
/// Floor division ( // ) 
/// Exponentiation ( ** ) 
/// Example:
/// operator['+', '*', '-']
/// vector = [2, 3, 4, 5]
/// result = 2 + 3 * 4 - 5
/// => result = 9
/// Note:
/// The length of operator vector is equal to the length of operand vector minus one.
/// Operand is a vector of of non-negative integers.
/// Operator vector has at least one operator, and operand vector has at least two operands.
fn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {

    let mut result: isize = 0;
    let mut prev = 0;
    let mut i = 0;
    for op in operator {
        match op.as_str() {
            "+" => result = prev + operand[i],
            "-" => result = prev - operand[i],
            "*" => result = prev * operand[i],
            "//" => result = prev / operand[i],
            "**" => result = prev.pow(operand[i] as u32),
            _ => {}
        }
        prev = result;
        i += 1;
    }
    result
}

fn main() {
    let candidate = do_algebra;
    assert_eq!(candidate(vec![String::from("**"), String::from("*"), String::from("+")], vec![2, 3, 4, 5]), 37);
    assert_eq!(candidate(vec![String::from("+"), String::from("*"), String::from("-")], vec![2, 3, 4, 5]), 9);
    assert_eq!(candidate(vec![String::from("//"), String::from("*")], vec![7, 3, 4]), 8);
}

-----------------------------
/// Given two vectors operator, and operand. The first vector has basic algebra operations, and 
/// the second vector is a vector of integers. Use the two given vectors to build the algebric 
/// expression and return the evaluation of this expression.
/// The basic algebra operations:
/// Addition ( + ) 
/// Subtraction ( - ) 
/// Multiplication ( * ) 
/// Floor division ( // ) 
/// Exponentiation ( ** ) 
/// Example:
/// operator['+', '*', '-']
/// vector = [2, 3, 4, 5]
/// result = 2 + 3 * 4 - 5
/// => result = 9
/// Note:
/// The length of operator vector is equal to the length of operand vector minus one.
/// Operand is a vector of of non-negative integers.
/// Operator vector has at least one operator, and operand vector has at least two operands.
fn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {

    let mut result = operand[0];
    for i in 1..operand.len() {
        result = match operator[i - 1].as_str() {
            "+" => result + operand[i],
            "-" => result - operand[i],
            "*" => result * operand[i],
            "//" => result / operand[i],
            "**" => result.pow(operand[i] as u32),
            _ => result,
        };
    }
    return result;
}

fn main() {
    let candidate = do_algebra;
    assert_eq!(candidate(vec![String::from("**"), String::from("*"), String::from("+")], vec![2, 3, 4, 5]), 37);
    assert_eq!(candidate(vec![String::from("+"), String::from("*"), String::from("-")], vec![2, 3, 4, 5]), 9);
    assert_eq!(candidate(vec![String::from("//"), String::from("*")], vec![7, 3, 4]), 8);
}

-----------------------------
/// Given two vectors operator, and operand. The first vector has basic algebra operations, and 
/// the second vector is a vector of integers. Use the two given vectors to build the algebric 
/// expression and return the evaluation of this expression.
/// The basic algebra operations:
/// Addition ( + ) 
/// Subtraction ( - ) 
/// Multiplication ( * ) 
/// Floor division ( // ) 
/// Exponentiation ( ** ) 
/// Example:
/// operator['+', '*', '-']
/// vector = [2, 3, 4, 5]
/// result = 2 + 3 * 4 - 5
/// => result = 9
/// Note:
/// The length of operator vector is equal to the length of operand vector minus one.
/// Operand is a vector of of non-negative integers.
/// Operator vector has at least one operator, and operand vector has at least two operands.
fn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {

    assert!(operator.len() == operand.len() - 1);
    let mut operand = operand;
    let operator = &operator[..operator.len() - 1];
    for i in 0..operator.len() {
        let result = match operator[i] {
            "+" => operand[i] + operand[i+1],
            "-" => operand[i] - operand[i+1],
            "*" => operand[i] * operand[i+1],
            "//" => operand[i] / operand[i+1],
            "**" => operand[i] as f64.powf(operand[i+1] as f64) as isize,
            _ => 0,
        };
        operand[i] = result;
        operand.remove(i + 1);
    }
    operand[0]
}

fn main() {
    let candidate = do_algebra;
    assert_eq!(candidate(vec![String::from("**"), String::from("*"), String::from("+")], vec![2, 3, 4, 5]), 37);
    assert_eq!(candidate(vec![String::from("+"), String::from("*"), String::from("-")], vec![2, 3, 4, 5]), 9);
    assert_eq!(candidate(vec![String::from("//"), String::from("*")], vec![7, 3, 4]), 8);
}

-----------------------------
/// Given two vectors operator, and operand. The first vector has basic algebra operations, and 
/// the second vector is a vector of integers. Use the two given vectors to build the algebric 
/// expression and return the evaluation of this expression.
/// The basic algebra operations:
/// Addition ( + ) 
/// Subtraction ( - ) 
/// Multiplication ( * ) 
/// Floor division ( // ) 
/// Exponentiation ( ** ) 
/// Example:
/// operator['+', '*', '-']
/// vector = [2, 3, 4, 5]
/// result = 2 + 3 * 4 - 5
/// => result = 9
/// Note:
/// The length of operator vector is equal to the length of operand vector minus one.
/// Operand is a vector of of non-negative integers.
/// Operator vector has at least one operator, and operand vector has at least two operands.
fn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {

    let mut result = operand[0];
    for i in 0..operator.len() {
        result = match operator[i] {
            "+" => result + operand[i + 1],
            "-" => result - operand[i + 1],
            "*" => result * operand[i + 1],
            "//" => result / operand[i + 1],
            "**" => result.pow(operand[i + 1] as u32),
            _ => panic!(),
        }
    }
    result
}

fn main() {
    let candidate = do_algebra;
    assert_eq!(candidate(vec![String::from("**"), String::from("*"), String::from("+")], vec![2, 3, 4, 5]), 37);
    assert_eq!(candidate(vec![String::from("+"), String::from("*"), String::from("-")], vec![2, 3, 4, 5]), 9);
    assert_eq!(candidate(vec![String::from("//"), String::from("*")], vec![7, 3, 4]), 8);
}

===============================
/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(String::from("1234"))
/// String::from("4321")
/// >>> solve(String::from("ab"))
/// String::from("AB")
/// >>> solve(String::from("#a@C"))
/// String::from("#A@c")
fn solve(s: String) -> String {

===============================
-----------------------------
/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(String::from("1234"))
/// String::from("4321")
/// >>> solve(String::from("ab"))
/// String::from("AB")
/// >>> solve(String::from("#a@C"))
/// String::from("#A@c")
fn solve(s: String) -> String {

    let mut res = String::from("");
    for ch in s.chars() {
        if ch.is_ascii_alphabetic() {
            let ch = if ch.is_ascii_uppercase() {
                ch.to_lowercase().nth(0).unwrap()
            } else {
                ch.to_uppercase().nth(0).unwrap()
            };
            res.push(ch);
        } else {
            res.push(ch);
        }
    }
    res
}

fn main() {
    let candidate = solve;
    assert_eq!(candidate(String::from("AsDf")), String::from("aSdF"));
    assert_eq!(candidate(String::from("1234")), String::from("4321"));
    assert_eq!(candidate(String::from("ab")), String::from("AB"));
    assert_eq!(candidate(String::from("#a@C")), String::from("#A@c"));
    assert_eq!(candidate(String::from("#AsdfW^45")), String::from("#aSDFw^45"));
    assert_eq!(candidate(String::from("#6@2")), String::from("2@6#"));
    assert_eq!(candidate(String::from("#$a^D")), String::from("#$A^d"));
    assert_eq!(candidate(String::from("#ccc")), String::from("#CCC"));
}

-----------------------------
/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(String::from("1234"))
/// String::from("4321")
/// >>> solve(String::from("ab"))
/// String::from("AB")
/// >>> solve(String::from("#a@C"))
/// String::from("#A@c")
fn solve(s: String) -> String {

    let mut result = String::new();
    for c in s.chars() {
        if c.is_ascii_alphabetic() {
            result.push((if c.is_ascii_lowercase() {
                c.to_ascii_uppercase()
            } else {
                c.to_ascii_lowercase()
            }));
        } else {
            result.push(c);
        }
    }
    return result;
}

fn main() {
    let candidate = solve;
    assert_eq!(candidate(String::from("AsDf")), String::from("aSdF"));
    assert_eq!(candidate(String::from("1234")), String::from("4321"));
    assert_eq!(candidate(String::from("ab")), String::from("AB"));
    assert_eq!(candidate(String::from("#a@C")), String::from("#A@c"));
    assert_eq!(candidate(String::from("#AsdfW^45")), String::from("#aSDFw^45"));
    assert_eq!(candidate(String::from("#6@2")), String::from("2@6#"));
    assert_eq!(candidate(String::from("#$a^D")), String::from("#$A^d"));
    assert_eq!(candidate(String::from("#ccc")), String::from("#CCC"));
}

-----------------------------
/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(String::from("1234"))
/// String::from("4321")
/// >>> solve(String::from("ab"))
/// String::from("AB")
/// >>> solve(String::from("#a@C"))
/// String::from("#A@c")
fn solve(s: String) -> String {

    let mut reversed_char_string: String = String::from("");
    let mut last_letter_was_lower = false;
    let mut last_letter_was_upper = false;
    let mut i: usize = 0;
    while i < s.len() {
        let char_to_check: char = s.chars().nth(i).unwrap();
        if char_to_check.is_lowercase() {
            if last_letter_was_lower {
                reversed_char_string.push_str(&(char_to_check.to_uppercase().collect::<String>()));
                last_letter_was_lower = false;
                last_letter_was_upper = true;
            } else {
                reversed_char_string.push(char_to_check.to_uppercase());
            }
        } else {
            if last_letter_was_upper {
                reversed_char_string.push_str(&(char_to_check.to_lowercase().collect::<String>()));
                last_letter_was_upper = false;
                last_letter_was_lower = true;
            } else {
                reversed_char_string.push(char_to_check.to_lowercase());
            }
        }
        i += 1;
    }
    if !last_letter_was_lower && !last_letter_was_upper {
        let mut s_char_vec: Vec<char> = s.chars().collect();
        s_char_vec.reverse();
        reversed_char_string.push_str(s_char_vec.into_iter().collect::<String>().as_str());
    }
    reversed_char_string
}

fn main() {
    let candidate = solve;
    assert_eq!(candidate(String::from("AsDf")), String::from("aSdF"));
    assert_eq!(candidate(String::from("1234")), String::from("4321"));
    assert_eq!(candidate(String::from("ab")), String::from("AB"));
    assert_eq!(candidate(String::from("#a@C")), String::from("#A@c"));
    assert_eq!(candidate(String::from("#AsdfW^45")), String::from("#aSDFw^45"));
    assert_eq!(candidate(String::from("#6@2")), String::from("2@6#"));
    assert_eq!(candidate(String::from("#$a^D")), String::from("#$A^d"));
    assert_eq!(candidate(String::from("#ccc")), String::from("#CCC"));
}

-----------------------------
/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(String::from("1234"))
/// String::from("4321")
/// >>> solve(String::from("ab"))
/// String::from("AB")
/// >>> solve(String::from("#a@C"))
/// String::from("#A@c")
fn solve(s: String) -> String {

    let mut result = s.clone();
    let mut flag = true;

    for (index, character) in result.chars().enumerate() {
        if character.is_alphabetic() {
            if character.is_lowercase() {
                result.replace_range(index..index + 1, character.to_uppercase().collect::<String>().as_str());
            } else {
                result.replace_range(index..index + 1, character.to_lowercase().collect::<String>().as_str());
            }
            flag = false;
        }
    }

    if flag {
        result.chars().rev().collect::<String>()
    } else {
        result
    }
}

fn main() {
    let candidate = solve;
    assert_eq!(candidate(String::from("AsDf")), String::from("aSdF"));
    assert_eq!(candidate(String::from("1234")), String::from("4321"));
    assert_eq!(candidate(String::from("ab")), String::from("AB"));
    assert_eq!(candidate(String::from("#a@C")), String::from("#A@c"));
    assert_eq!(candidate(String::from("#AsdfW^45")), String::from("#aSDFw^45"));
    assert_eq!(candidate(String::from("#6@2")), String::from("2@6#"));
    assert_eq!(candidate(String::from("#$a^D")), String::from("#$A^d"));
    assert_eq!(candidate(String::from("#ccc")), String::from("#CCC"));
}

-----------------------------
/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(String::from("1234"))
/// String::from("4321")
/// >>> solve(String::from("ab"))
/// String::from("AB")
/// >>> solve(String::from("#a@C"))
/// String::from("#A@c")
fn solve(s: String) -> String {

    let mut lowercase_letters = "abcdefghijklmnopqrstuvwxyz".to_string();
    let mut uppercase_letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".to_string();
    let mut new_s = String::from("");
    for c in s.chars() {
        if c.is_alphabetic() {
            if c.is_uppercase() {
                let index = lowercase_letters.find(c).unwrap();
                let lowercase_letter = lowercase_letters.remove(index);
                new_s.push_str(lowercase_letter);
                uppercase_letters.push(c);
            } else {
                let index = uppercase_letters.find(c).unwrap();
                let uppercase_letter = uppercase_letters.remove(index);
                new_s.push_str(uppercase_letter);
                lowercase_letters.push(c);
            }
        } else {
            new_s.push(c);
        }
    }
    new_s
}

fn main() {
    let candidate = solve;
    assert_eq!(candidate(String::from("AsDf")), String::from("aSdF"));
    assert_eq!(candidate(String::from("1234")), String::from("4321"));
    assert_eq!(candidate(String::from("ab")), String::from("AB"));
    assert_eq!(candidate(String::from("#a@C")), String::from("#A@c"));
    assert_eq!(candidate(String::from("#AsdfW^45")), String::from("#aSDFw^45"));
    assert_eq!(candidate(String::from("#6@2")), String::from("2@6#"));
    assert_eq!(candidate(String::from("#$a^D")), String::from("#$A^d"));
    assert_eq!(candidate(String::from("#ccc")), String::from("#CCC"));
}

===============================
/// Given a string 'text', return its md5 hash equivalent string.
/// If 'text' is an empty string, return None.
/// >>> string_to_md5(String::from("Hello world"))
/// Some(String::from("3e25960a79dbc69b674cd4ec67a72c62"))
fn string_to_md5(text: String) -> Option<String> {

===============================
-----------------------------
/// Given a string 'text', return its md5 hash equivalent string.
/// If 'text' is an empty string, return None.
/// >>> string_to_md5(String::from("Hello world"))
/// Some(String::from("3e25960a79dbc69b674cd4ec67a72c62"))
fn string_to_md5(text: String) -> Option<String> {

    if text.is_empty() {
        None
    } else {
        let text_to_hash = text.as_str();
        let hashed = md5::compute(text_to_hash);
        Some(format!("{:x}", hashed))
    }
}

fn main() {
    let candidate = string_to_md5;
    assert_eq!(candidate(String::from("Hello world")), Some(String::from("3e25960a79dbc69b674cd4ec67a72c62")));
    assert_eq!(candidate(String::from("")), None);
    assert_eq!(candidate(String::from("A B C")), Some(String::from("0ef78513b0cb8cef12743f5aeb35f888")));
    assert_eq!(candidate(String::from("password")), Some(String::from("5f4dcc3b5aa765d61d8327deb882cf99")));
}

-----------------------------
/// Given a string 'text', return its md5 hash equivalent string.
/// If 'text' is an empty string, return None.
/// >>> string_to_md5(String::from("Hello world"))
/// Some(String::from("3e25960a79dbc69b674cd4ec67a72c62"))
fn string_to_md5(text: String) -> Option<String> {

    let bytes = text.into_bytes();
    let hash = md5::compute(&bytes);
    let mut hex_string = String::with_capacity(32);
    for byte in hash {
        hex_string.push_str(&format!("{:02x}", byte));
    }
    Some(hex_string)
}

fn main() {
    let candidate = string_to_md5;
    assert_eq!(candidate(String::from("Hello world")), Some(String::from("3e25960a79dbc69b674cd4ec67a72c62")));
    assert_eq!(candidate(String::from("")), None);
    assert_eq!(candidate(String::from("A B C")), Some(String::from("0ef78513b0cb8cef12743f5aeb35f888")));
    assert_eq!(candidate(String::from("password")), Some(String::from("5f4dcc3b5aa765d61d8327deb882cf99")));
}

-----------------------------
/// Given a string 'text', return its md5 hash equivalent string.
/// If 'text' is an empty string, return None.
/// >>> string_to_md5(String::from("Hello world"))
/// Some(String::from("3e25960a79dbc69b674cd4ec67a72c62"))
fn string_to_md5(text: String) -> Option<String> {

    // use md5 hash algorithm
    let mut md5 = Md5::new();

    // convert text to bytes
    md5.input_str(&text);

    // output the result of the hash in hexadecimal
    let result = md5.result_str();
    Some(result)
}

fn main() {
    let candidate = string_to_md5;
    assert_eq!(candidate(String::from("Hello world")), Some(String::from("3e25960a79dbc69b674cd4ec67a72c62")));
    assert_eq!(candidate(String::from("")), None);
    assert_eq!(candidate(String::from("A B C")), Some(String::from("0ef78513b0cb8cef12743f5aeb35f888")));
    assert_eq!(candidate(String::from("password")), Some(String::from("5f4dcc3b5aa765d61d8327deb882cf99")));
}

-----------------------------
/// Given a string 'text', return its md5 hash equivalent string.
/// If 'text' is an empty string, return None.
/// >>> string_to_md5(String::from("Hello world"))
/// Some(String::from("3e25960a79dbc69b674cd4ec67a72c62"))
fn string_to_md5(text: String) -> Option<String> {

    if text == "" {
        return None;
    }

    let mut hasher = Md5::new();
    hasher.update(&text);
    let mut result = hasher.finalize();

    let mut final_result = String::new();
    for byte in result.iter() {
        final_result.push_str(&format!("{:02x}", byte));
    }

    Some(final_result)
}

fn main() {
    let candidate = string_to_md5;
    assert_eq!(candidate(String::from("Hello world")), Some(String::from("3e25960a79dbc69b674cd4ec67a72c62")));
    assert_eq!(candidate(String::from("")), None);
    assert_eq!(candidate(String::from("A B C")), Some(String::from("0ef78513b0cb8cef12743f5aeb35f888")));
    assert_eq!(candidate(String::from("password")), Some(String::from("5f4dcc3b5aa765d61d8327deb882cf99")));
}

-----------------------------
/// Given a string 'text', return its md5 hash equivalent string.
/// If 'text' is an empty string, return None.
/// >>> string_to_md5(String::from("Hello world"))
/// Some(String::from("3e25960a79dbc69b674cd4ec67a72c62"))
fn string_to_md5(text: String) -> Option<String> {

    md5::compute(text).iter().map(|b| format!("{:02x}", b)).collect()
}

fn main() {
    let candidate = string_to_md5;
    assert_eq!(candidate(String::from("Hello world")), Some(String::from("3e25960a79dbc69b674cd4ec67a72c62")));
    assert_eq!(candidate(String::from("")), None);
    assert_eq!(candidate(String::from("A B C")), Some(String::from("0ef78513b0cb8cef12743f5aeb35f888")));
    assert_eq!(candidate(String::from("password")), Some(String::from("5f4dcc3b5aa765d61d8327deb882cf99")));
}

===============================
/// Given two positive integers a and b, return the even digits between a
/// and b, in ascending order.
/// For example:
/// >>> generate_integers(2, 8)
/// vec![2, 4, 6, 8]
/// >>> generate_integers(8, 2)
/// vec![2, 4, 6, 8]
/// >>> generate_integers(10, 14)
/// Vec::<isize>::new()
fn generate_integers(a: isize, b: isize) -> Vec<isize> {

===============================
-----------------------------
/// Given two positive integers a and b, return the even digits between a
/// and b, in ascending order.
/// For example:
/// >>> generate_integers(2, 8)
/// vec![2, 4, 6, 8]
/// >>> generate_integers(8, 2)
/// vec![2, 4, 6, 8]
/// >>> generate_integers(10, 14)
/// Vec::<isize>::new()
fn generate_integers(a: isize, b: isize) -> Vec<isize> {

    let mut result = Vec::<isize>::new();
    if a > b {
        return result;
    }
    for i in a..=b {
        if i % 2 == 0 {
            result.push(i);
        }
    }
    result
}

fn main() {
    let candidate = generate_integers;
    assert_eq!(candidate(2, 10), vec![2, 4, 6, 8]);
    assert_eq!(candidate(10, 2), vec![2, 4, 6, 8]);
    assert_eq!(candidate(132, 2), vec![2, 4, 6, 8]);
    assert_eq!(candidate(17, 89), Vec::<isize>::new());
}

-----------------------------
/// Given two positive integers a and b, return the even digits between a
/// and b, in ascending order.
/// For example:
/// >>> generate_integers(2, 8)
/// vec![2, 4, 6, 8]
/// >>> generate_integers(8, 2)
/// vec![2, 4, 6, 8]
/// >>> generate_integers(10, 14)
/// Vec::<isize>::new()
fn generate_integers(a: isize, b: isize) -> Vec<isize> {

    if a > b {
        return vec![];
    }
    if a > 9 || b < 0 {
        return vec![];
    }
    if a == b {
        return vec![a];
    }
    let mut a = a;
    let mut b = b;
    let mut result = Vec::new();
    if a > 0 {
        a -= 1;
    }
    while a < b {
        a += 1;
        if a % 2 == 0 {
            result.push(a);
        }
    }
    result
}

fn main() {
    let candidate = generate_integers;
    assert_eq!(candidate(2, 10), vec![2, 4, 6, 8]);
    assert_eq!(candidate(10, 2), vec![2, 4, 6, 8]);
    assert_eq!(candidate(132, 2), vec![2, 4, 6, 8]);
    assert_eq!(candidate(17, 89), Vec::<isize>::new());
}

-----------------------------
/// Given two positive integers a and b, return the even digits between a
/// and b, in ascending order.
/// For example:
/// >>> generate_integers(2, 8)
/// vec![2, 4, 6, 8]
/// >>> generate_integers(8, 2)
/// vec![2, 4, 6, 8]
/// >>> generate_integers(10, 14)
/// Vec::<isize>::new()
fn generate_integers(a: isize, b: isize) -> Vec<isize> {

    assert!(a >= 2 && b >= 2);
    let a = a as u32;
    let b = b as u32;
    let mut result = Vec::new();
    for x in a..b {
        if x.count_ones() & 1 == 0 {
            result.push(x as isize);
        }
    }
    result
}

fn main() {
    let candidate = generate_integers;
    assert_eq!(candidate(2, 10), vec![2, 4, 6, 8]);
    assert_eq!(candidate(10, 2), vec![2, 4, 6, 8]);
    assert_eq!(candidate(132, 2), vec![2, 4, 6, 8]);
    assert_eq!(candidate(17, 89), Vec::<isize>::new());
}

-----------------------------
/// Given two positive integers a and b, return the even digits between a
/// and b, in ascending order.
/// For example:
/// >>> generate_integers(2, 8)
/// vec![2, 4, 6, 8]
/// >>> generate_integers(8, 2)
/// vec![2, 4, 6, 8]
/// >>> generate_integers(10, 14)
/// Vec::<isize>::new()
fn generate_integers(a: isize, b: isize) -> Vec<isize> {

    // Write some code here
    let a = if a < b { a } else { b };
    let b = if a < b { b } else { a };
    let mut ans = Vec::<isize>::new();
    for i in a..=b {
        if i < 10 && i % 2 == 0 {
            ans.push(i);
        }
    }
    ans
}

fn main() {
    let candidate = generate_integers;
    assert_eq!(candidate(2, 10), vec![2, 4, 6, 8]);
    assert_eq!(candidate(10, 2), vec![2, 4, 6, 8]);
    assert_eq!(candidate(132, 2), vec![2, 4, 6, 8]);
    assert_eq!(candidate(17, 89), Vec::<isize>::new());
}

-----------------------------
/// Given two positive integers a and b, return the even digits between a
/// and b, in ascending order.
/// For example:
/// >>> generate_integers(2, 8)
/// vec![2, 4, 6, 8]
/// >>> generate_integers(8, 2)
/// vec![2, 4, 6, 8]
/// >>> generate_integers(10, 14)
/// Vec::<isize>::new()
fn generate_integers(a: isize, b: isize) -> Vec<isize> {

    if a > b {
        return Vec::<isize>::new();
    }

    let mut result = Vec::new();
    let mut current = a;

    while current <= b {
        if current.is_even() {
            result.push(current);
        }

        current += 1;
    }

    result
}

fn main() {
    let candidate = generate_integers;
    assert_eq!(candidate(2, 10), vec![2, 4, 6, 8]);
    assert_eq!(candidate(10, 2), vec![2, 4, 6, 8]);
    assert_eq!(candidate(132, 2), vec![2, 4, 6, 8]);
    assert_eq!(candidate(17, 89), Vec::<isize>::new());
}

